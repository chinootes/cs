{"keys":[{"path":["title"],"id":"title","weight":1,"src":"title","getFn":null},{"path":["body"],"id":"body","weight":1,"src":"body","getFn":null}],"records":[{"i":0,"$":{"0":{"v":"This page has not yet sprouted","n":0.408},"1":{"v":"[Dendron](https://dendron.so/) (the tool used to generate this site) lets authors selective publish content. You will see this page whenever you click on a link to an unpublished page\n\n![](https://foundation-prod-assetspublic53c57cce-8cpvgjldwysl.s3-us-west-2.amazonaws.com/assets/images/not-sprouted.png)","n":0.189}}},{"i":1,"$":{"0":{"v":"Computer Science","n":0.707},"1":{"v":"\n\nThese notes are arranged into the below topics:\n\n- AI (Sorry this is on the top, list is alphabetic)\n- [[arch]]\n- Data\n- Execution\n- Languages\n- Semantics\n- [[paradigm]]\n- Philosophy\n- Dev\n- Tools\n- Type Theory\n\n## References\n\n- Hierarchy inpiration - [Map of Computer Science](https://www.flickr.com/photos/95869671@N08/36231833334/in/photostream/lightbox/)","n":0.164}}},{"i":2,"$":{"0":{"v":"Zzz Template","n":0.707}}},{"i":3,"$":{"0":{"v":"Lang","n":1}}},{"i":4,"$":{"0":{"v":"Ds","n":1}}},{"i":5,"$":{"0":{"v":"Stack","n":1},"1":{"v":"\n_Last element = topmost element_\n\n_Last = Top_\n\n## Creating\n\n```\n\n```\n\n## Pushing\n\nAdds element to the top.\n```\n\n```\n\n## Popping\n\nRemoves and returns the last element.\n```\n\n```\n\n## Peeking\n\nReturns last element without removing.\n\n```\n\n```\n\n## Searching\n\n```\n\n```","n":0.2}}},{"i":6,"$":{"0":{"v":"Syntax","n":1},"1":{"v":"\n\n## Hello World\n\n## Rules\n\n## Naming Conventions\n\n## Comments\n\n## Variables \n\n### Declaration\n\n### Initialization\n\n### Both at once\n\n## Constants\n\n## Data types\n\n### Primitives\n\n### Compound\n \n#### Array\n\n##### Defining\n\n##### Declaring\n\n#### Strings\n\n\n\n#### Structures\n#### Interfaces\n\n#### Classes\n\n##### Creating objects\n\n##### Using objects\n\n\n\n## Operators\n\n## Flow\n\n### Conditionals\n\n### Loops\n\n## Functions/Methods\n\n### main\n\n\n\n","n":0.164}}},{"i":7,"$":{"0":{"v":"Exceptions","n":1},"1":{"v":"\n## [[dev.issues.exception.types.checked]]\n\n\n## [[dev.issues.exception.types.unchecked]]\n\n\n## Handling\n\n### Catching\n\n- ``\n    - Used to specify a block of code which can throw an exception.\n    - Must be followed by a ``.\n    - Can't be used alone\n\n- ``\n    - Block used to handle the error.\n    - Must be preceded by ``\n    - Can't be used alone\n\n### Always execute\n\n- ``\n\nContains the code which must be executed irrespective of whether an exception is handled or not\n\n### Throwing\n\n- ``\n\nUsed to throw an exception\n\n### Declaring \n\n- ``\n    - Used to declare exceptions\n    - Doesn't throw error\n    - Specifies that an exception may occur in a method\n    - Used with method signature\n\n### Creating Custom Exceptions\n\n- How to create?\n\n- How to return your custom message while throwing exception?\n\n- Are custom exceptions checked or unchecked?\n\n## Propagation\n\n## Exceptions in main() method\n\n- What happens when main() throws an error?\n\n\n- Can *throws* keyword be used with main()?\n\n\n\n## Exceptions raised in common scenarios\n\n\nScenario | Exception | \n----------------|-----------|\n Divide by zero | `` |\n Operation on Null Pointer   | `` |\n Operating on incorrect/non-existant index    | `` | \n\n","n":0.076}}},{"i":8,"$":{"0":{"v":"Os","n":1}}},{"i":9,"$":{"0":{"v":"Memory","n":1}}},{"i":10,"$":{"0":{"v":"RAM","n":1},"1":{"v":"\nRAM holds the actively used portions of a process's memory during a program execution.\n\nIt provides fast access for executing instructions and storing data.","n":0.209}}},{"i":11,"$":{"0":{"v":"Spaces","n":1}}},{"i":12,"$":{"0":{"v":"Stack Space","n":0.707},"1":{"v":"\n> Har thread ka ek stack. Har method ka ek stack frame.\n\n- Used for [[dev.memory management.alloc.static]].\n- Used for local variables, function call frames, static thangs, with short lifespan.\n- Limited size, more predictable.\n- Automatically managed by OS\n- Has [[execution.concurrency.multithreading.thread safety]] - Each thread has its own stack.\n\n## Stack allocation\n\nThis is controlled by the OS. One stack is allocated to the program for each running thread.\n\n### Stack Size Estimation\n\n- The OS allocates a stack for each system-level thread when the thread is created.\n- The size of the stack is typically determined by the OS and compiler settings.\n- For instance, on many systems, the default stack size might be around 1 MB to 2 MB.\n- This default size is generally sufficient for most routine operations and function calls.\n\n\n### Dynamic Allocation and Swapping\n\n\n- Some systems can automatically grow the stack if there’s room in the virtual address space.\n\n\n### Customization\n\nWhile the OS provides a default stack size, some applications or languages allow customization. Developers can adjust the stack size based on their specific requirements.\n\nBe careful of [[dev.issues.error.stack overflow]] though.","n":0.076}}},{"i":13,"$":{"0":{"v":"Stack Frame","n":0.707},"1":{"v":"\n\n# aka Activation Record\n\nStack frame is created for function calls. A new one is created each time a function is called.\n\n## Components\n\n### Function Return Address\n\nThe return address (memory address) of the instruction to execute after the function call completes.\n\nPushed onto the stack first.\n\n### Function Arguments\n\nSpace for function arguments (parameters) passed to the method.\nFollowed by any local variables.\n\n### Local Variables\n\nVariables declared within the method.\nAllocated space for these variables.\n\n### Frame Pointer (Optional)\nSome architectures use a frame pointer (FP) to point to the start of the stack frame.\n\nHelps access local variables and function arguments efficiently.\n\nNot always present (depends on the calling convention).\n\n\n## Lifecycle\n\n### Function Call\n\nWhen a method is called, a new stack frame is pushed onto the call stack.\n\nThe return address, arguments, and local variables are set up.\n\n### Function Execution\n\nThe method executes, accessing its local variables and performing computations.\n\n### Function Return\n\nWhen the method completes, its stack frame is popped from the stack.\n\nThe return address is used to continue execution from where the method was called.\n","n":0.079}}},{"i":14,"$":{"0":{"v":"Heap Space","n":0.707},"1":{"v":"\n- For objects and data structures with longer lifespan.\n- It is a **dynamic memory pool** provided by the OS which can be allocated and deallocated by the programs. Therefore, the applications have control of the heap memory. It is not managed by OS.\n- Not [[execution.process.thread]]-specific. All threads can access it => Not as safe as [[os.memory.ram.spaces.stack]]\n- Heap memory can lead to memory leaks.\n- Bigger than [[os.memory.ram.spaces.stack]]\n- Can have [[dev.memory management.manual]] or [[dev.memory management.implicit]] depending upon the implementation. But even an implicit memory management strategy needs to have an entity ([[dev.memory management.implicit.gc]]) cleaning up the data.\n- Prone to [[dev.memory management.leaks]]","n":0.101}}},{"i":15,"$":{"0":{"v":"User Space","n":0.707},"1":{"v":"\nPortion of a process’s virtual memory address space that is accessible to user-level applications.\n\nContains data, code, stack, and heap specific to the user process.\nUser programs execute in this space.\n\nUser , while dynamic allocations (\nUser space is isolated from other processes.\nUser applications interact with the kernel through system calls (syscalls) when they need restricted services.","n":0.136}}},{"i":16,"$":{"0":{"v":"Stack Space","n":0.707},"1":{"v":"\n> Har thread ka ek stack. Har method ka ek stack frame.\n\n- Used for [[dev.memory management.alloc.static]].\n- Used for local variables, function call frames, static thangs, with short lifespan.\n- Limited size, more predictable.\n- Automatically managed by OS\n- Has [[execution.concurrency.multithreading.thread safety]] - Each thread has its own stack.\n- Stack grows downward to lower addresses.\n\n## Stack allocation\n\nThis is controlled by the OS. One stack is allocated to the program for each running thread.\n\n### Stack Size Estimation\n\n- The OS allocates a stack for each system-level thread when the thread is created.\n- The size of the stack is typically determined by the OS and compiler settings.\n- For instance, on many systems, the default stack size might be around 1 MB to 2 MB.\n- This default size is generally sufficient for most routine operations and function calls.\n\n\n### Dynamic Allocation and Swapping\n\n\n- Some systems can automatically grow the stack if there’s room in the virtual address space.\n\n\n### Customization\n\nWhile the OS provides a default stack size, some applications or languages allow customization. Developers can adjust the stack size based on their specific requirements.\n\nBe careful of [[dev.issues.error.stack overflow]] though.\n\n## Why choose [[data.structure.secondary.stack]] for this purpose?\n\nThe design decision by OS Gods to choose this data structure to represent this memory space comes from the below reasoning.\n\nEach function call creates a new [[os.memory.ram.user.stack.frame]] on the stack, containing local variables, return addresses, and other bookkeeping information.\n\nThe LIFO (last in, first out) structure of the stack ensures that function calls are properly nested and managed.","n":0.064}}},{"i":17,"$":{"0":{"v":"Stack Frame","n":0.707},"1":{"v":"\n\n# aka Activation Record\n\nStack frame is created for function calls. A new one is created each time a function is called.\n\n## Components\n\n### Function Return Address\n\nThe return address (memory address) of the instruction to execute after the function call completes.\n\nPushed onto the stack first.\n\n### Function Arguments\n\nSpace for function arguments (parameters) passed to the method.\nFollowed by any local variables.\n\n### Local Variables\n\nVariables declared within the method.\nAllocated space for these variables.\n\n### Frame Pointer (Optional)\nSome architectures use a frame pointer (FP) to point to the start of the stack frame.\n\nHelps access local variables and function arguments efficiently.\n\nNot always present (depends on the calling convention).\n\n\n## Lifecycle\n\n### Function Call\n\nWhen a method is called, a new stack frame is pushed onto the call stack.\n\nThe return address, arguments, and local variables are set up.\n\n### Function Execution\n\nThe method executes, accessing its local variables and performing computations.\n\n### Function Return\n\nWhen the method completes, its stack frame is popped from the stack.\n\nThe return address is used to continue execution from where the method was called.\n","n":0.079}}},{"i":18,"$":{"0":{"v":"Heap Space","n":0.707},"1":{"v":"\n- For objects and data structures with longer lifespan.\n- It is a **dynamic memory pool** provided by the OS which can be allocated and deallocated by the programs. Therefore, the applications have control of the heap memory. It is not managed by OS.\n- Not [[execution.process.thread]]-specific. All threads can access it => Not as safe as [[os.memory.ram.user.stack]]\n- Heap memory can lead to memory leaks.\n- Bigger than [[os.memory.ram.user.stack]]\n- Needs [[dev.memory management.manual]]. \n\n    💡 Some virtual machines can provide [[dev.memory management.implicit]]. But even an implicit memory management strategy needs to have an entity ([[dev.memory management.implicit.gc]]) cleaning up the data.\n\n- Heap grow upwards to higher addresses.\n- Prone to [[dev.memory management.leaks]]\n\n\n## Why choose heap data structure for this memory space?\n\nThe Heap space doesn't actually adhere to the heap data structure. It is just called so because it is a free store where memory blocks are allocated and deallocated dynamically - like a \"heap\" of memory blocks.","n":0.081}}},{"i":19,"$":{"0":{"v":"Kernel Space","n":0.707},"1":{"v":"\n- Higher part of the virtual memory address space.\n- Contains the operating system kernel and its components (such as device drivers, file systems, and process management).\n- Not directly accessible from a user process.\n- Kernel code and data structures reside here.\n- Handles privileged operations (e.g., hardware access, memory management, scheduling).\n- Provides services to user processes via syscalls.\n- Kernel stack is part of the kernel space and is used for handling interrupts and exceptions.","n":0.118}}},{"i":20,"$":{"0":{"v":"Memory Management","n":0.707},"1":{"v":"\n\n## Components used by OS for managing memory\n\n### Physical Memory ([[os.memory.ram]])\n\nPhysical memory is the actual hardware component installed in the system. \n\n### Virtual Memory\n\nMemory management technique that allows the system to run larger applications or execute more programs than the available physical RAM would allow.\n\nIt is a conceptual layer on top of physical memory.\n\nIt is typically larger than the available physical [[os.memory.ram]]. The illusion of a larger address space is what makes it “virtual.” How is this possible? Read on to find. \n\n#### Virtual Address Space\n\nAddresses of virtual memory locations -> also bigger than the physical address space.\n\n### Page table\n\nPage tables store mappings between virtual addresses and physical addresses. These are also stored in [[os.memory.ram]], more specifically in [[os.memory.ram.kernel]].\n\n### Pagefile (Swap space)\n\nSpace or file on disk (not RAM).\n\n## Processes involved in managing memory\n\n### Swapping\n\nSwapping involves moving parts of a process’s memory between RAM (physical memory) and disk (usually a swap file or partition) at [[execution.lifecycle.runtime]].\n\n\n## Managing memory - Lifecycle of an address space\n\n- The OS assigns virtual memory for the [[os.memory.ram.user.stack]] when a [[execution.process.thread]] is created.\n- Physical memory is assigned to that virtual memory on demand using the [[#page-table]].\n- The OS identifies “swappable” pages (memory chunks) based on their usage patterns. Basically, any memory chunk not being used that frequently or actively.\n- These pages are swapped in and out as needed.\n\nSwapping allows the OS to free up RAM for other processes but doing it frequently can degrade system performance - so there is a sweet spot to reach for the OS.\n","n":0.063}}},{"i":21,"$":{"0":{"v":"Lang","n":1}}},{"i":22,"$":{"0":{"v":"TS","n":1}}},{"i":23,"$":{"0":{"v":"Lib","n":1}}},{"i":24,"$":{"0":{"v":"forEach","n":1},"1":{"v":"\nUsed to execute a `callback` function for all elements in ascending order.\n\n## Parameters\n\n### `callback` function\n\n#### Arguments of the `callback` function\n\nAll three are _optional_.\n\n- `element value`: The current value of the item.\n- `element index`: The index of the current element being processed in the array.\n- `array`: The array being iterated.\n\nNote: These three arguments are optional.\n\n\n### `thisObject`\n\nAn object to use as this when executing the callback.\n\n\n## Example \n\n```ts\nconst fruits: string[] = ['Apple', 'Orange', 'Banana'];\n\n// Example 1: Using all parameters\nfruits.forEach((currentValue: string, index: number, arr: string[]) => {\n    console.log(`Fruit at index ${index}: ${currentValue}`);\n});\n\n// Example 2: Using a custom 'this' value\nconst myObject = {\n    greeting: 'Hello',\n    displayFruit: function (fruit: string) {\n        console.log(`${this.greeting}, ${fruit}!`);\n    },\n};\n\nfruits.forEach(myObject.displayFruit, myObject);\n```","n":0.095}}},{"i":25,"$":{"0":{"v":"Arrays","n":1},"1":{"v":"\n- `push()`: Adds one or more elements to the end of the array.\n- `pop()`: Removes and returns the last element.\n- `shift()`: Removes and returns the first element.\n- [[lang.ts.lib.foreach]]","n":0.189}}},{"i":26,"$":{"0":{"v":"Ds","n":1}}},{"i":27,"$":{"0":{"v":"Hashmap","n":1},"1":{"v":"\nHashmaps can be implemented using the Map data structure.\n\n## Creating\n\n```ts\nlet hashmap: Map<KeyType, ValueType> = new Map();\n```\n\n## Adding values\n\n```ts\nhashmap.set(key, value);\n```\n\n## Getting values\n\n```ts\nval = hashmap.get(key)\n```\n\n## Check if key exists\n\n```ts\nhashmap.has(key)\n```\n\n## Deleting\n\n```ts\nhashmap.delete(key)\n```\n\n## Size\n\n```ts\nhashmap.size\n```\n\n## Clearing\n\n```ts\nhashmap.clear()\n```","n":0.183}}},{"i":28,"$":{"0":{"v":"Syntax","n":1},"1":{"v":"\n\n\n## Hello World\n\n```ts\nconsole.log(\"Hello world!\");\n```\n\n## Rules\n\n## Naming Conventions\n\n## Comments\n\n```ts\n//Single line comment\n\n/* Multi \n line \n comment */\n \n```\n## Variables \n\n### Declaration\n\n```ts\n    let x;\n    \n    // with type\n    let x: number; //types are specified using type annotations\n```\n### Initialization\n\n```ts\n    x = true // type-automatically inferred as boolean\n    x = 123; //compile-time error\n```\n### Both at once\n\n```ts\n    let x = true // type-automatically inferred as boolean\n    x = 123; //compile-time error\n```\n\n## Constants\n\n```ts\n    const PI = 3.14;\n    const PI = 3.14;\n```\n\n## Data types\n\n### Primitives\n\n- `string`\n- `number`: No int or float. Every number is simply `number`.\n- `boolean`\n\n💡The type names String, Number, and Boolean (starting with capital letters) are legal, but refer to some special built-in types that will very rarely appear in your code. Always use string, number, or boolean for types.\n\n- `any`: Special type which you can use whenever you don't want a particular value to cause typechecking errors.\n\n    ```ts\n    let obj: any = { x: 0 };\n    // None of the following lines of code will throw compiler errors.\n    // Using `any` disables all further type checking, and it is assumed\n    // you know the environment better than TypeScript.\n    obj.foo();\n    obj();\n    obj.bar = 100;\n    obj = \"hello\";\n    const n: number = obj;\n    ```\n\n    Can be disabled by setting `noImplicitAny` flag in [[lang.ts.config]] \n    \n\n### Compound\n \n#### Array\n\n##### Declaration\n\n```ts\nlet x: number[]\n```\n\n```ts\nArray<number> arr;\n```\n\n##### Initialization\n\n```ts\nx = [1,2,3] // type inferred as Array\n```\n##### Both at once\n\n```ts\nlet x = [1,2,3] // type inferred as Array\n```\n\n#### Strings\n\n```ts\n let gina: string;\n gina = \"boyle\";\n\n let holt = \"kevin\"; // type inferred as string\n```\n\n#### Objects (kind of like structures)\n\n```ts\n// The parameter's type annotation is an object type\nfunction printCoord(pt: { x: number; y: number }) { // here the type of pt is defined as composed of x and y\n\n  console.log(\"The coordinate's x value is \" + pt.x);\n  console.log(\"The coordinate's y value is \" + pt.y);\n}\nprintCoord({ x: 3, y: 7 });\n```\n\n##### Optional properties\n\n```ts\nfunction printName(obj: { first: string; last?: string }) {\n  // ...\n}\n// Both OK\nprintName({ first: \"Bob\" });\nprintName({ first: \"Alice\", last: \"Alisson\" });\n```\n\nChecking for `undefined` mandatory for optional properties\n\n```ts\nfunction printName(obj: { first: string; last?: string }) {\n  \n  // Error - might crash if 'obj.last' wasn't provided!\n  console.log(obj.last.toUpperCase()); //'obj.last' is possibly 'undefined'.\n\n  if (obj.last !== undefined) {\n    console.log(obj.last.toUpperCase());\n  }\n \n  //modern JavaScript syntax:\n  console.log(obj.last?.toUpperCase());\n}\n```\n#### Union Types\n\nCombination of multiple types. Union type basically says that a variable/parameter can be either of the types within the union.\n\n```ts\nfunction printId(id: number | string) {\n  console.log(\"Your ID is: \" + id);\n}\n// OK\nprintId(101);\n// OK\nprintId(\"202\");\n// Error\nprintId({ myID: 22342 });\n```\n\nAny operation on such parameter/variable will only work if the operation is valid for both all types in the union.\n\n```ts\nfunction printId(id: number | string) {\n  console.log(id.toUpperCase()); //Error - method not applicable for number\n\n//Solution to this - narrow down the type\n  if (typeof id === \"string\") {\n    // In this branch, id is of type 'string'\n    console.log(id.toUpperCase());\n  } else {\n    // Here, id is of type 'number'\n    console.log(id);\n  }\n}\n```\n💡It might be confusing that a union of types appears to have the intersection of those types’ properties. This is not an accident - the name union comes from type theory. The union number | string is composed by taking the union of the values from each type. Notice that given two sets with corresponding facts about each set, only the intersection of those facts applies to the union of the sets themselves. For example, if we had a room of tall people wearing hats, and another room of Spanish speakers wearing hats, after combining those rooms, the only thing we know about every person is that they must be wearing a hat.\n\n#### Type Aliases\n\n```ts\n// For object types\ntype Point = {\n  x: number;\n  y: number;\n};\n\n//For union types\ntype ID = number | string;\n\n// For primitive - Unnecessary but legal\ntype UserInputString = string;\n```\n\n#### Interfaces\n\n```ts\ninterface Point {\n  x: number;\n  y: number;\n}\n```\n\n#### Classes\n\n##### Creating objects\n\n##### Using objects\n\n\n\n## Operators\n\n## Flow\n\n### Conditionals\n\n### Loops\n\n#### Traditional \n\n```ts\nfor (let i = 0; i < fruits.length; i++) {\n    console.log(fruits[i]);\n}\n```\n\n#### for...of\n\nLoops on elements.\n```ts\nfor (let index of fruits) {\n    console.log(fruits[index]);\n}\n```\n\n#### for...in\n\nLoops on indexes/keys.\n```ts\nfor (let index in fruits) {\n    console.log(fruits[index]);\n}\n```\n\n💡 You'd think that `index` will be a `number`, but no, index here is a `string`. What's more? You can access elements using this index (as showm above), because its converted by [[type theory.casting.implicit]]. But if you use it to initialize another variable, like `j=i+1`, you can't use `j` as a `number`, `j` will also be a `string`. Weird stuff.\n\nSo prefer for..of or traditional for loop for arrays. Use for..in for things like Maps.\n\n\n## Functions/Methods\n\n### Parameter type annotation\n\n```ts\nfunction greet(name: string) {\n  console.log(\"Hello\" name.toUpperCase() + \"!!\");\n}\n```\n\n### Return type annotation\n\n```ts\nfunction getFavoriteNumber(): number {\n  return 26;\n}\n```\n\n### Functions which return Promises\n\n```ts\nasync function getFavoriteNumber(): Promise<number> {\n  return 26;\n}\n```\n\n### Anonymous functions\n\n```ts\nconst names = [\"Alice\", \"Bob\", \"Eve\"];\n\n//using function keyword\nnames.forEach(function (s) {\n  console.log(s.toUpperCase());\n});\n \n// Arrow functions\nnames.forEach((s) => {\n  console.log(s.toUpperCase());\n});\n\n```\n\n### main\n\n\n\n## References\n\n- [TypeScript Docs](https://www.typescriptlang.org/docs/)","n":0.036}}},{"i":29,"$":{"0":{"v":"JS","n":1}}},{"i":30,"$":{"0":{"v":"V","n":1}}},{"i":31,"$":{"0":{"v":"ES6","n":1}}},{"i":32,"$":{"0":{"v":"Org","n":1}}},{"i":33,"$":{"0":{"v":"package.json","n":1},"1":{"v":"\nFile used to specify project metadata, dependencies, scripts, versions and other configuration.","n":0.289}}},{"i":34,"$":{"0":{"v":"Modules","n":1},"1":{"v":"\nModules in a proper sense emerged in JavaScript with arrival of libraries like CommonJS and Asynchronous Module Definitions (AMD).\n\n## CommonJS Modules\n\n- `require()` and `module.exports`\n- [[execution.synchronicity.async]] \n\n### Exporting \n\n```js\n// myModule.js\nfunction greet(name) {\n    return `Hello, ${name}!`;\n}\n\nmodule.exports = greet;\n\n```\nFor multiple exports\n```js\n// myModule.js\nexports.greet = function(name) {\n    return `Hello, ${name}!`;\n};\n\nexports.farewell = function(name) {\n    return `Goodbye, ${name}!`;\n};\n```\n\n\n### Importing\n\n```js\n// main.js\nconst greet = require('./myModule.js');\nconsole.log(greet('Alice')); // Output: Hello, Alice!\n\n// Or, if using multiple exports:\nconst myModule = require('./myModule.js');\nconsole.log(myModule.greet('Alice')); // Output: Hello, Alice!\nconsole.log(myModule.farewell('Alice')); // Output: Goodbye, Alice!\n\n\n```\n\n\n### Selectively loading modules\n\nIn [[lang.js.node]], you can load certain parts of modules selectively.\n\n```js \nconst { Buffer } = require('node:buffer');\n```\n\n## ES6 Modules\n\nWith arrival of [[lang.js.v.6]], modules were introduced natively in JS.\n\nThe existing `require` syntax was not used since `require` is asynchronous.\n\n### Exporting\n\nNamed exports\n```js\n// utils.js\nexport const add = (x, y) => x + y;\nexport const multiply = (x, y) => x * y;\n```\n\nDefault export\n\n```js\n// greeting.js\nexport default function greet(name) {\n    return `Hello, ${name}!`;\n}\n```\n\n### Importing\n\nNamed import \n\n```js\n// main.js\nimport { add, multiply } from './utils.js';\nconsole.log(add(2, 3)); // Output: 5\nconsole.log(multiply(2, 3)); // Output: 6\n```\n\nDefault import\n\n```js\n// main.js\nimport greet from './greeting.js';\nconsole.log(greet('Alice')); // Output: Hello, Alice!\n```\n\n### Selectively loading\n\n```js\n// main.js\nimport { add } from './utils.js';\nconsole.log(add(2, 3)); // Output: 5\n```\n\n\n\n## Es6 vs CommonJS\n\n### [[execution.synchronicity]] and [[systems.char.performance.i.throughput]]\n\nLoading is synchronous(step by step) for require on the other hand import can be asynchronous(without waiting for previous import) so it can perform a little better than require.\n\n### Compatibility \n\nES modules are compatible with Common JS modules. That is, you can import commonJS modules if you're using ES modules.\n\nBut you can't import ES modules if you're using CommonJS modules. A workaround is to use `import()` syntax.\n\nSince the modules are not compatible you have to be careful while shipping your packages. \n\n\n\n#### Dual Package Hazard\n\nIts a situation in which two versions of the same package get loaded within the same runtime environment. Of course, an application or package wouldn't do this intentionally, but it is common that the application itself loads one version, while a dependency of the application loads another version.\n\n\n## Which module system?\n\n### Default\n\nBrowsers didn't have module systems early on. Although, [[dev.tools.build.transformation.bundler]]s can process them. Even today, most modern browsers support only ES modules and have limited support for CommonJS modules.\n\n[[lang.js.node]] treats all JS code as CommonJS modules.\n\nWhy though? => **Backward Compatibility** \n\nMany existing projects used commonJS modules, since it came first and  nodeJS also traditionally supported CommonJS. Keeping ES as default would mean rewriting or transpiling all that code. Keeping CommonJS as default maintains compatiblity with existing projects.\n\nThis allows the developers to gradually adopt the newer spec and stick with CommonJS until the benefits of migration outweigh the compatibility concerns. \n\n\n### Configuration\n\n- **[[lang.js.org.packagejson]]**: `\"type\":\"module\"` indicates that the project uses ES modules.\n- **File extensions** _(optional)_\n    - `.cjs`: CommonJS module (Even in ES module project)\n    - `.mjs`: ES Module (Differentiates ES modules from default `.js` CommonJS modules)\n\n### Final Outcome of bundler\n\nEven if you use an ES module system in your project, if your [[dev.tools.build.transformation.bundler]] emits commonJS code, then you are not really shipping an ES package.\n\n### Interoperability\n\nThere are certain workarounds to ensure interoperability of both module systems in your project.\n\n1. [[dev.tools.build.transformation.bundler]]: Bundlers can be configured to handle both modules. It takes care of dependencies and compatibility.\n2. Use `import()` syntax to import ES modules in CommonJS modules. `import` statement works the same for ES and CommonJS modules in an ES module.\n\n\n## References\n\n- [import() - MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/import)\n- [Dual Package Hazard - GeoffreyBooth/dual-package-hazard - Github](https://github.com/GeoffreyBooth/dual-package-hazard): Example illustrating the hazard posed by dual CommonJS/ES module packages\n- [JS Modules - GFG](https://www.w3schools.com/js/js_modules.asp)\n- [Migrating from CommonJS - Pure ESM package](https://gist.github.com/sindresorhus/a39789f98801d908bbc7ff3ecc99d99c)\n- [Import vs Require - The Biggest JavaScript Divide - Matt Pocock - YouTube](https://youtu.be/6_JNPmjSevo?si=jpqZRov9HMwS7QM0)\n- [The difference between \"require(x)\" and \"import x\"](https://stackoverflow.com/questions/46677752/the-difference-between-requirex-and-import-x)","n":0.041}}},{"i":35,"$":{"0":{"v":"V8 Engine","n":0.707},"1":{"v":"\n\nV8 JavaScript Engine was developed by Google to run JavaScript in Chrome Browser. It compiles JS code into machine code.","n":0.224}}},{"i":36,"$":{"0":{"v":"Syntax","n":1},"1":{"v":"\n\n## Hello World\n\n## Rules\n\n## Naming Conventions\n\n## Comments\n\n## Variables \n\n### Declaration\n\n### Initialization\n\n### Both at once\n\n## Constants\n\n## Data types\n\n### Primitives\n\n### Compound\n \n#### Array\n\n##### Defining\n\n##### Declaring\n\n#### Strings\n\n\n\n#### Structures\n#### Interfaces\n\n#### Classes\n\n##### Creating objects\n\n##### Using objects\n\n\n\n## Operators\n\n### Spread/rest operator\n\n- `...`\n    - **Spread**: Used to expand iterables (like array and objects) into individual elements\n        - Array Expansion\n            ```js\n                const arr1 = [1, 2, 3];\n                const arr2 = [...arr1, 4, 5];\n                console.log(arr2); // Output: [1, 2, 3, 4, 5]\n            ```\n        - Function Arguments\n            ```js\n            const numbers = [1, 2, 3];\n            const sum = (a, b, c) => a + b + c;\n            console.log(sum(...numbers)); // Output: 6\n            ```\n        - Object Spread\n            ```js\n                const obj1 = { a: 1, b: 2 };\n                const obj2 = { ...obj1, c: 3 };\n                console.log(obj2); // Output: { a: 1, b: 2, c: 3 }\n            ```\n    - **Rest**: Used to collect all arguments into an array.\n    ```js\n        function sum(...args) {\n                return args.reduce((acc, val) => acc + val, 0);\n            }   \n\n            console.log(sum(1, 2, 3, 4)); // Output: 10\n    ```\n\n    Context within which it is used whether it is a spread or rest operator.\n\n## Flow\n\n### Conditionals\n\n### Loops\n\n## Functions/Methods\n\n### main\n\n\n\n","n":0.074}}},{"i":37,"$":{"0":{"v":"React","n":1},"1":{"v":"\n## Why React? \n\n#interview-question\n\n1. Abstracts DOM Manipulation - predictable behavior, easier to debug\n2. Component-based Architecture - Modularized and reusable approach. Easier to maintain\n3. Virtual DOM efficiently manages updates and rendering of components - Actual DOM Manipulation is slow and resource consuming\n4. Rich ecosystem - quite popular\n5. Flexibility - not a framework - focuses solely on view layer - can be used with other libraries and frameworks\n6. React Native - Unified experience across devices\n\n\n\n## Props \n\n- Object received by components - contain value passed by the parent component.\n- Read only \n\n\n## References\n\n- [Higher-Order Functions (HOC)](https://medium.com/segmentify-tech/higher-order-component-hoc-2b671559e576)","n":0.103}}},{"i":38,"$":{"0":{"v":"React Component","n":0.707},"1":{"v":"\n#interview-question\n\nBuilding blocks of React application. Independent, reusable pieces.\n\n### Functional Components\n\nFunctions that take props as argument and return React elements.\n\n```js\nfunction Greeting(props) {\n  return <h1>Hello, {props.name}</h1>;\n}\n```\nFunctional components can hold state via React Hooks.\n\n### Class Components\n\nES6 Classes that extend from `React.Component` and must have a `render` method.\n\n```js\nclass Greeting extends React.Component {\n  render() {\n    return <h1>Hello, {this.props.name}</h1>;\n  }\n}\n```\n\nClass components can hold state.\n\n### Higher-Order Components\n\nReact HOCs are like [[paradigm.func.components.higher-order]]s. They take in a component, modify or add state or behavior to it, and return a new component.\n\n","n":0.11}}},{"i":39,"$":{"0":{"v":"React Component Lifecycle","n":0.577},"1":{"v":"![react lifecycle stages](lang.js.react.components.lifecycle.png)\n\n1. **Mounting**: When an instance of a [[lang.js.react.components]] is created and inserted into the DOM\n2. **Updating**: When component is re-rendered due to changes to props or state\n3. **Unmounting**: When component is being removed from DOM\n4. **Error Handling**: \n\n## Lifecycle methods\n\nReact offers several methods which are automatically called in different stages of lifecycle of a component.\n\n### Mounting\n\n- `constructor(props)`: \n    - Called: before component is mounted\n    - Used for: initializing state, binding event handlers\n- `static getDerivedStateFromProps(props, state)`: \n    - Called: right before rendering, both on the initial mount and on subsequent updates.\n    - Used for: updating state based on props -> returned object is used to update state - `null` to update nothing. \n- `render()`: **Required**. Returns JSX to render.\n- `componentDidMount()`: \n    - Called immediately after component is mounted.\n    - Used for: making network requests, setting up subscriptions, interacting with DOM\n\n### Updating\n\n- `static getDerivedStateFromProps(props, state)`: \n    - Called: again before rendering.\n- `shouldComponentUpdate(nextProps, nextState)`: Determines whether component should re-render\n    - Called: before render\n    - Used for: #optimization.performance - returning false skips update (true by default)\n- `render()`: Re-renders the component\n- `getSnapshotBeforeUpdate(prevProps, prevState)`: \n    - Called: right before DOM is updated. \n    - Used for: passing something to `componentDidUpdate()` - you can return it from this method.\n- `componentDidUpdate(prevProps, prevState, snapshot)`: \n    - Called: immediately after component updates \n    - Used for: working with DOM or sending network requests after updates.\n\n\n### Unmounting\n\n`componentWillUnmount()`:\n    - Called: right before component is unmounted/destroyed\n    - Used for: cleanup(e.g. cleaning timers, cancelling network requests, removing event listeners)\n\n### Error Handling\n\n- `static getDerivedStateFromError(error)`\n    - Used for: updating state based on the error so that error is not propagated to next render -> returned object is used to update state - `null` to update nothing.\n- `componentDidCatch(error)`: \n    - Called: when error has been thrown by descendant component\n    - Used for: logging error info","n":0.058}}},{"i":40,"$":{"0":{"v":"NodeJS","n":1},"1":{"v":"\nNodeJS is based on Chrome's [[lang.js.v8]]. Initially, [[lang.js]] was intended for use in browser. In the browser, V8 was the compiler for JS. The creator of nodeJS simply made a runtime on top of this V8 engine.\n\nEven though it is single-threaded, nodeJS still allows [[execution.synchronicity.async]] execution via [[paradigm.event driven]] architecture. It uses the [[paradigm.event driven.main loop]] or **event loop** to stay in the memory, while spinning up seperate worker threads for blocking operations. The threads are not created on-demand, but rather fetched from a [[arch.pattern.concurrency.thread pool]].\n\nNon-blocking operations are executed in the main execution itself. The blocking operations are moved to an event queue.\n\n## Flow of a request coming to a node JS server\n\n```mermaid\nsequenceDiagram\n    Client      ->> Event Queue: Non-blocking request\n    Event Loop  ->> Event Queue: New request aaya kya?\n    Event Queue ->> Event Loop:  Yes\n    Event Loop  ->> Event Loop:  Blocking hai ya non blocking?\n    Event Loop  ->> Event Loop:  Non-Blocking\n    Event Loop  ->> Event Loop:  Ye to main khud hi kar lunga\n\n    Client      ->> Event Queue: Blocking request\n    Event Loop  ->> Event Queue: New request aaya kya?\n    Event Queue ->> Event Loop:  Yes\n    Event Loop  ->> Event Loop:  Blocking hai ya non blocking?\n    Event Loop  ->> Event Loop:  Blocking\n    Event Loop  ->> Thread Pool: Dekh le bhai. Call karna fir\n    Thread Pool ->> Event Loop: Ho gaya. Dekh lo\n    Event Loop  ->> Event Loop:  Call back function    \n```\n\n\n","n":0.066}}},{"i":41,"$":{"0":{"v":"Bun","n":1},"1":{"v":"\nRuntime for javascript.\n\n- Fast\n- Fixes interoperability problem of CommonJS and ES [[lang.js.org.modules]]\n\n[Bun 1.0 is here- YouTube](https://youtu.be/BsnCpESUEqM?si=nRj7QSVK0a8EfYI0)","n":0.25}}},{"i":42,"$":{"0":{"v":"Java","n":1}}},{"i":43,"$":{"0":{"v":"Paradigms","n":1}}},{"i":44,"$":{"0":{"v":"Oo","n":1}}},{"i":45,"$":{"0":{"v":"Polymorphism","n":1}}},{"i":46,"$":{"0":{"v":"Overriding","n":1}}},{"i":47,"$":{"0":{"v":"Overriding by Return Types","n":0.5},"1":{"v":"\n\nBefore Java 5 it wasn't possible to override a method based on its return type. Now, we can override a method if its return types are in the same direction as the subclass, that is, if the methods have [[paradigm.oo.components.covariant return type]]s.","n":0.154}}},{"i":48,"$":{"0":{"v":"Final","n":1}}},{"i":49,"$":{"0":{"v":"Member","n":1}}},{"i":50,"$":{"0":{"v":"Blank Final Member","n":0.577},"1":{"v":"\n\n## or Blank final variable\n\n> Technically, its not correct to call it variable since by definition, `final` means constant, so by behaviour, it doesn't vary.\n>\nBut people being people sometimes call it that. So we got to live with it.\n\n\nFinal variable not initialised during declaration\n\nAll final variables must be initialised, or else => Compile time error\n\n## Ways to initialise\n  \n- Can be initialised within an [[lang.java.paradigms.oo.instantiation.iib]]\n- Can be initialised within a constructor\n- If there are multiple constructors\n- Initialise in all of them, or else => Compile time error\n\n\n## Blank static final member/_variable_\n\nBlank final _variable_ which is [[paradigm.oo.components.modifiers.static]].\n\n## Initialisation\n\nOnly within static block.\n","n":0.1}}},{"i":51,"$":{"0":{"v":"Objects","n":1}}},{"i":52,"$":{"0":{"v":"Serialization","n":1},"1":{"v":"\n\n- \n- An object can be made Serializable by implementing the [[lang.java.lib.interfaces.marker.serializable]].\n\n## SerialVersionUID\n\n- Serialization process associates an ID with each serializable class on runtime → SerialVersionID\n- Used to verify that sender and reciever of the serialized object are the same. Throws InvalidClassException otherwise.\n- We can generate our own SerialVersionUID by creating a static final long serialVersionUID field in the class. Suggested to have it private and declare it in the class itself.\n\n\n## `transient` keyword\n\nIf you don't want to serialize any data member of the class - that is, you don't want it to be stored - mark it (prefix it) with transient.\n","n":0.099}}},{"i":53,"$":{"0":{"v":"Object Context Qualifiers in Java","n":0.447},"1":{"v":"\n\n[[paradigm.oo.context.object.qualifiers]] in Java are:\n\n- `this` - [[paradigm.oo.context.object.self-reference]]\n- `super` - [[paradigm.oo.context.object.super]]\n","n":0.316}}},{"i":54,"$":{"0":{"v":"Object Cloning in Java","n":0.5},"1":{"v":"\n\n\nThe usual [[paradigm.oo.components.object.cloning]] ways work just as well in Java. However, clone() method is much easier and can be used to overcome the limitations of those methods.\n\n```java\nA obj1 = (A) obj.clone();\n```\n\n\n`clone` is a member function of [[lang.java.lib.classes.object]] which throws an exception when used. Why?\n\nCloning a class is [[tags.not allowed by default]] for security reasons. But if the class itself allows you i.e. the class implements [[lang.java.lib.interfaces.marker.cloneable]], then you can use `clone()` method.\n\n","n":0.118}}},{"i":55,"$":{"0":{"v":"Instantiation","n":1}}},{"i":56,"$":{"0":{"v":"Static Blocks","n":0.707},"1":{"v":"\n\n- An unnamed block in a class prefixed by the static keyword.\n- Invokation\n  - Invoked once at the beginning of the program (when the class is loaded in the memory).\n  - Invoked before constructor\n\nFor details, [[lang.java.paradigms.oo.instantiation.order of invokation]]\n","n":0.162}}},{"i":57,"$":{"0":{"v":"Order of Invokation of initializer blocks and constructor","n":0.354},"1":{"v":"\n\n1. Parent static block\n2. Child static block\n3. Parent initialization  block\n4. Parent Constructor\n5. Child initialization block\n6. Child Constructor\n\n👆🏽 output of the code below\n\n```java\npublic class Parent {    \n    public Parent() {\n        System.out.println(\"Parent Constructor\");\n    }    \n    static {\n        System.out.println(\"Parent static block\");    \n    }    \n    {\n        System.out.println(\"Parent initialisation  block\");\n    }\n}\n\npublic class Child extends Parent {    \n    {\n        System.out.println(\"Child initialisation block\");\n    }\n    static {\n        System.out.println(\"Child static block\");\n    }\n\n    public Child() {\n        System.out.println(\"Child Constructor\");\n    }    \n    public static void main(String[] args) {\n        new Child();    \n    }\n}\n```\n\nInitialization blocks get invoked in the order they're written in the code.\n\n## References\n\n- [In what order do static blocks and initialization blocks execute when using inheritance? - Stack Overflow](https://stackoverflow.com/questions/19561332/in-what-order-do-static-blocks-and-initialization-blocks-execute-when-using-inhe)\n- [Order of execution of Initialization blocks and Constructors in Java](https://www.geeksforgeeks.org/order-execution-initialization-blocks-constructors-java/#:~:text=Initialization%20blocks%20run%20in%20the,above%20the%20constructors%20within%20braces.)\n","n":0.092}}},{"i":58,"$":{"0":{"v":"Instance Initializer Block","n":0.577},"1":{"v":"\n\nInstance initialisation block can be included in a class. Its simply a block with no name and is called whenever an instance is initialised.\n\n## Order of invokation\n\nHere is the order in which it is invoked with respect to constructors.\n**Constructor of parent class → Constructor → Instance initialisation block**\n\nOn surface, it looks like the initialisation block is executed first. But what happens is that the compiler copies the block in the constructor at the top. So the constructor is called within which the instance initialiser block runs.\n\nFor more details, [[lang.java.paradigms.oo.instantiation.order of invokation]]\n","n":0.105}}},{"i":59,"$":{"0":{"v":"Encapsulation","n":1}}},{"i":60,"$":{"0":{"v":"Sealed Classes","n":0.707},"1":{"v":"\nSealed classes restrict which classes can inherit them, enhancing encapsulation and giving more control.\n\n```java\npublic abstract sealed class Shape permits Circle, Rectangle {\n    // Common methods and fields\n}\n\npublic final class Circle extends Shape {\n    // Circle-specific implementation\n}\n\npublic final class Rectangle extends Shape {\n    // Rectangle-specific implementation\n}\n\n```\n\nIntroduced in [[lang.java.v.17]].","n":0.146}}},{"i":61,"$":{"0":{"v":"Access","n":1}}},{"i":62,"$":{"0":{"v":"default","n":1},"1":{"v":"\n\n## Access Modifier\n\nIf no [[paradigm.oo.components.modifiers.access]] are used with a member, it becomes default.\n\n\nAlso a Keyword (post Java 8) for [[paradigm.oo.components.modifiers.default]] methods.","n":0.218}}},{"i":63,"$":{"0":{"v":"Static in Java","n":0.577},"1":{"v":"\n\n## Example of class containing static members\n\n```java\npublic class Example\n{\nint x; // Instance variable\nstatic int y; // Static member variable\n\npublic void fun() { static int a; } // Instance member function\npublic static void fun2() { } // Static member function \n\nstatic class Test //Static inner class\n{ }\n}\n```\n\n## [[paradigm.oo.components.modifiers.static.variable]]s\n\n- Initialization\n\n    Values can be assigned in special static initializer blocks / [[lang.java.paradigms.oo.instantiation.static blocks]]\n\n- Accessing\n\n    Accessing outside class - `ClassName.VariableName`\n\n- Naming\n\n    When declaring class variables as public static final, then variable names (constants) are all in upper case. If the static variables are not final, the naming syntax is the same as instance and local variables.\n\n## [[lang.java.paradigms.oo.instantiation.static blocks]]\n\n## [[paradigm.oo.components.modifiers.static.method]]s\n\n## Static class\n\n[[lang.java.paradigms.oo.inner class.static]]\n","n":0.096}}},{"i":64,"$":{"0":{"v":"Inner Class","n":0.707}}},{"i":65,"$":{"0":{"v":"Static Inner Class","n":0.577},"1":{"v":"\n\nIf static class B is inside class A => class B is static and an [[paradigm.oo.components.class.inner]]\n\n```java\nmain()\n{ \nA.B obj1 = new A.B();\n}\n\n//If j is member of class B\nobj1.j=5;\n```\n","n":0.192}}},{"i":66,"$":{"0":{"v":"Member Inner Class","n":0.577},"1":{"v":"\n\n\nIf class B is inside class A => B is a member and an [[lang.java.paradigms.oo.inner class]]\n\n```java\n\nmain()\n{ \nA obj = new A();\nA.B obj1 = obj.new B();\n}\n\n//If j is member of class B\nobj1.j=5;\n```\n\n## `.class` files generated in this case:\n\n`A.class`\n`A$B.class`\n","n":0.164}}},{"i":67,"$":{"0":{"v":"Qualified this construct","n":0.577},"1":{"v":"\n[[lang.java.paradigms.oo.inner class.member]] have an implicit reference to an instance of the enclosing (outer) class. **Qualified This** refers to this instance.\n\nIf the outer class is A and inner class is B, you can refer to this instance of A from B as `A.this`.\n\nSince we are using a [[dev.lingo.identifiers.qualifier]] along with `this` [[lang.java.paradigms.oo.objects.context qualifiers]], to form a fully [[dev.lingo.identifiers.qualified]], it is called \"Qualified\" `this`.\n\n\n## Reference\n\n[What does \"qualified this\" construct mean in java?](https://stackoverflow.com/questions/11276994/what-does-qualified-this-construct-mean-in-java)\n\n> In Effective Java inside the item \"Item 22: Favor static member classes over nonstatic\" Josh Bloch says:    \n>\nEach instance of a nonstatic member class is implicitly associated with an enclosing instance of its containing class. Within instance methods of a nonstatic member class, you can invoke methods on the enclosing instance or obtain a reference to the enclosing instance using the qualified this construct.","n":0.086}}},{"i":68,"$":{"0":{"v":"Anonymous Inner Class","n":0.577},"1":{"v":"\n\n```java\nmain()\n{ \nA obj = new A();\n {\n func(){\n Syso(\"This is an anonymous class\")\n  }\n }\n}\n```\n\nOR (post Java 8)\n\n```java\nmain()\n{ \nA obj = () -> Syso(\"anonymous class\")\n\n}\n```\n","n":0.2}}},{"i":69,"$":{"0":{"v":"Inheritance","n":1},"1":{"v":"\n\n- Implemented by\n\n    extends keyword\n\n## Types of Inheritance in Java\n\n- [[paradigm.oo.principles.inheritance.types.single]]\n- [[paradigm.oo.principles.inheritance.types.multilevel]]\n- [[paradigm.oo.principles.inheritance.types.hierarchical]]\n- [[paradigm.oo.principles.inheritance.types.hybrid]]\n\n[[paradigm.oo.principles.inheritance.types.multiple.not allowed]]\n\n\n## Inheritance in case of [[lang.java.paradigms.oo.encapsulation.access.default]]\n\n- Are fields and methods with `default` access inherited?\n\n    Only if the subclass is located in the same package as the superclass.\n\n- How is multiple inheritance handled in case of methods with `default` access?\n\n    In case both parent interfaces have a default method with same method signature, the implementing class should explicitly tell which one its trying to use or it should override the default method.\n\n    ```java\n    //If I1 and I2 both have a fun() as default method\n    class C implements I1, I2{\n    I1.super.fun(); //Use I1's fun() method\n    }\n    ```\n","n":0.096}}},{"i":70,"$":{"0":{"v":"Func","n":1}}},{"i":71,"$":{"0":{"v":"Lambda","n":1},"1":{"v":"\nIn Java [[paradigm.func.components.lambda]]s are defined as below:\n\n```java\n(parameters) -> expression;\n```\n\nBrackets for parameters are optional if there is only one parameter and its type is inferred.\n\n\n```java\nList<String> list = Arrays.asList(\"a\", \"b\", \"c\");\nlist.forEach(item -> System.out.println(item));\n```\n","n":0.18}}},{"i":72,"$":{"0":{"v":"Functional Interface","n":0.707},"1":{"v":"\nInterfaces in Java which have only one abstract method.\n\nIn other (natively functional) languages like JavaScript, you can assign functions to variables. This was not possible in Java. \n\nIf an interface however had only one abstract method, and we assign a function to a reference of that interface, the language can automatically assign the function to the abstract method - thereby supporting assigning and passing the functions.\n","n":0.123}}},{"i":73,"$":{"0":{"v":"Db","n":1}}},{"i":74,"$":{"0":{"v":"API","n":1}}},{"i":75,"$":{"0":{"v":"JDBC","n":1},"1":{"v":"\n|                             |                                                                               |\n|-----------------------------|-------------------------------------------------------------------------------|\n| 1. Import the package       | import java.sql.*                                                             |\n| 2a. Load driver             | Steps to load and add connector jar                                           |\n| 2b. Register driver         | Class.forName(\"com.mysql.jdbc.Driver\");                                       |\n| 3. Establish the connection | Connection con= DriverManager.getConnection(\"URL\",\"Username\",\"Password\");     |\n| 4. Create the statement     | Statement st = con.createStatement();                                         |\n| 5. Execute the Query        | ResultSet rs = st.executeQuery(query); / int count = st.executeUpdate(query); |\n| 6. Process Result           | rs.next(); String s = rs.getString(column number);                            |\n| 7. Close                    | st.close();                                                                   |\n|                             | con.close();                                                                  |\n\n\n## Use PreparedStatement for user input\n\nUse PreparedStatement instead of Statement to give user input in queries\n\nquery - (?,?) // question marks for parameters you want to take as user input in the query\n\n```java\nPrepared Statement st = con.prepareStatement(query); \nst.setInt(1, input1); \nst.setString(2, input2);\n```\n","n":0.091}}},{"i":76,"$":{"0":{"v":"V","n":1}}},{"i":77,"$":{"0":{"v":"Java 9","n":0.707}}},{"i":78,"$":{"0":{"v":"Java 8","n":0.707},"1":{"v":"\nFeatures introduced in Java 8\n\n- [[lang.java.paradigms.func.lambda]] expressions\n- [[lang.java.paradigms.func.interface]]\n- [[lang.java.lib.interfaces.streams]] API\n- [[paradigm.oo.components.modifiers.default]] methods\n- [[lang.java.lib.classes.optional]] Class\n- New Date and Time API (java.time package)\n- Nashorn JavaScript Engine\n- Concurrent Accumulators\n- Parallel Array Sorting\n- Type Annotations\n- JDBC 4.2\n- Base64 Encoding and Decoding\n- StampedLock\n- [[lang.java.lib.classes.collectors]] API\n- Repeatable Annotations\n- Method References\n- CompletableFuture","n":0.149}}},{"i":79,"$":{"0":{"v":"Java 17","n":0.707}}},{"i":80,"$":{"0":{"v":"Typing","n":1}}},{"i":81,"$":{"0":{"v":"Casting","n":1}}},{"i":82,"$":{"0":{"v":"Widening Conversion in Java","n":0.5},"1":{"v":"\n\n[[type theory.casting.primitive.widening]]\n[[type theory.casting.implicit]]\n\n## Syntax\n\nNo notation required\n\nWhy?\n\nMoving to larger primitive types - does not loose any information.\n\n```java\nint a = 34;\nfloat b = a;\n\ndouble c = b;\n```\n","n":0.2}}},{"i":83,"$":{"0":{"v":"String Conversion","n":0.707},"1":{"v":"\n\n- Conversion from primitive type to String\n  - Done through [[lang.java.lib.classes.wrappers]] which override the toString() method\n  - Syntax\n\n        ```java\n        Integer a = 130;\n        String s = a.toString();\n        ```\n\n- Conversion from String to primitive type\n  - Each wrapper class has a *parse* method → parseXXX()\n  - Syntax\n\n        ```java\n        int a = Integer.parseInt(s);\n        byte b = Byte.parseByte(s);\n        \n        //Exception\n        //Since String is made of chars anyway \n        //considering the String is made of a single character\n        char c = s.charAt(0)\n        \n        ```\n","n":0.112}}},{"i":84,"$":{"0":{"v":"Object Type Conversion","n":0.577},"1":{"v":"\n\n- Similarity with primitive conversion\n\n    Converting from one type to another\n\n- Difference\n\n    Primitive type variables store values. So when we convert from a larger to type to smaller type, we might end up loosing information.\n\n    Reference variables on the other hand do not contain the object itself, but its reference. So when we convert types of objects, we're not changing the object, but we're just changing the label on the object, expanding or narrowing the opportunities to work with.\n\n    Upcasting narrows the list of methods and properties available to this object and down casting can extend it.\n\n## [[type theory.casting.object.upcasting]] in Java\n\n[[type theory.casting.implicit]]\n\n## [[type theory.casting.object.downcasting]] in Java\n\n## Syntax\n\n- [[type theory.casting.explicit]]\n- Same as narrowing conversion in primitive data types\n\n    ```java\n    float a = 10.5;\n    int b = (int) a;\n\n    print(a) -→ 10.5\n    print(b) -→ 10\n    \n    Animal animal = new Animal();\n    Cat cat = (Animal) animal;    \n    ```\n\n- Another way\n\n    ```java\n    Animal animal = new Animal();\n    if (Cat.class.isInstance(animal)) {\n    Cat cat = Cat.class.cast(animal);\n    ```\n\n## [[ClassCastException|dev.issues.exception.types.unchecked.class cast exception]]\n\nThat is why it is advised to use *instanceOf* check before downcasting.\n\n- instanceOf\n\n    Used to avoid the ClassCastException by checking if the object belongs to a certain type\n\n    ```java\n    //Example \n    if (animal instanceof Cat) {\n        ((Cat) animal).meow();\n    }\n    \n    ```\n\n    ```java\n    //case 1\n    Dog dog = new Dog();\n    Animal animal = dog;\n\n    if(Cat.class.instanceOf(animal)) -→ false\n\n    //case 2\n    Cat cat = new Cat();\n    Animal animal = cat;\n\n    cat.meow();\n\n    Cat.class.instanceOf(animal) -→ true\n    ```\n\n","n":0.065}}},{"i":85,"$":{"0":{"v":"Numeric Promotion in Inter-type operations","n":0.447},"1":{"v":"\n\nIt is necessary both numeric operands are compatible in size in an operation. If not, they're converted.\n\nHere's how that happens (Rules)\n\n- If one operand is double, float or long\n\n    the other promoted to double, float or long respectively\n\n- Else\n\n    both are considered int\n","n":0.152}}},{"i":86,"$":{"0":{"v":"Narrowing Conversion in Java","n":0.5},"1":{"v":"\n\n[[lang.java.typing.casting.narrowing conversion]]\n[[type theory.casting.explicit]]\n\n## Syntax\n\nNeed to explicitly state that we're fine with the resulting loss of information\n\n```java\nfloat b;\nint a = (int) b;\n\n//show(int a)\n\nshow((int)b);\n```\n","n":0.213}}},{"i":87,"$":{"0":{"v":"Boxing Unboxing","n":0.707},"1":{"v":"\n\n\n- Conversion from Wrapper class to primitive type and vice-versa\n- Syntax\n  - No notation required","n":0.258}}},{"i":88,"$":{"0":{"v":"Generics","n":1},"1":{"v":"\n- Generics are **parameterized types** in Java.\n- This allows types like Integer, String or user-defined types to be a parameter to methods, classes or interfaces.\n\n## Types\n\n- Generic classes\n- Generic methods\n- Generic interfaces\n\n## Defining \n\n### Naming convention\n\n- T – Type\n- E – Element\n- K – Key\n- N – Number\n- V – Value\n\n### Classes\n\n```java\nclass Test<T> {\n    T obj;\n    Test(T obj) { this.obj = obj; } \n    public T useT() { return this.obj; }\n}\n```\n\nMultiple types\n```java\nclass Test<T, U>{\n    T obj1;  \n    U obj2;   \n\n    Test(T obj1, U obj2){\n        this.obj1 = obj1;\n        this.obj2 = obj2;\n    }\n}\n```\n\n### Methods\n```java\nclass Test {\n    static <T> void genericMethod(T element)\n    {\n//        element...\n    }\n \n```\n\n## Usage\n\n- Generics work only with reference types\n    ```java\n    Test<int> obj = new Test<int>(20); //compile time error\n    ```\n- They work with primitive arrays since those are also references.\n    ```java\n    ArrayList<int[]> a = new ArrayList<>();\n    ```\n- Generic types maintain type safety. Different types behave differently. For example, you can't assign a generic initialized with `Integer` to a generic initialized with `String`.\n\n\n## References\n\n- [Generics in Java - GFG](https://www.geeksforgeeks.org/generics-in-java/)","n":0.077}}},{"i":89,"$":{"0":{"v":"Tool","n":1}}},{"i":90,"$":{"0":{"v":"JDK","n":1},"1":{"v":"\n\nProvides environment and tools to develop and run java applications.\n\n[[lang.java.jre]] + Development Tools\n","n":0.277}}},{"i":91,"$":{"0":{"v":"Lib","n":1}}},{"i":92,"$":{"0":{"v":"Interfaces","n":1}}},{"i":93,"$":{"0":{"v":"Streams","n":1},"1":{"v":"\nFramework for processing sequences of data in declarative and functional style.\n\nBasically, you can specify an operation and perform it for all items in the collection.\n\n\n## Intermediate Operations\n\nIntermediate operations return a stream.\n\n### `filter`([[lang.java.lib.interfaces.func.function.predicate]])\n\nFilters elements based on a condition.\n\n ```java\n List<Integer> evens = numbers.stream()\n                             .filter(n -> n % 2 == 0)\n                             .collect(Collectors.toList());\n  ```\n\n### `map`([[lang.java.lib.interfaces.func.function]])\n\nTransform each element of the stream.\n\n```java\nList<String> upperNames = names.stream()\n                               .map(String::toUpperCase)\n                               .collect(Collectors.toList());\n```\n\n### `flatMap`([[lang.java.lib.interfaces.func.function]])\n \nFlattens stream of streams into a single stream.\n\n```java\nList<String> allWords = sentences.stream()\n                                 .flatMap(sentence -> Arrays.stream(sentence.split(\" \")))\n                                 .collect(Collectors.toList());\n\n```\n```java\nStream<List<Integer>> nestedStream = Stream.of(List.of(1, 2), List.of(3, 4));\nStream<Integer> flattenedStream = nestedStream.flatMap(List::stream);\n```\n\n\n### `distinct()`\n\nRemoves duplicates.\n```java\nList<Integer> uniqueNumbers = numbers.stream()\n                                     .distinct()\n                                     .collect(Collectors.toList());\n\n```\n\n### `sorted()` and `sorted`([[lang.java.lib.interfaces.func.comparator]])\n\nSorts by natural order or by Comparator, if passed.\n```java\nList<String> sortedNames = names.stream()\n                                .sorted()\n                                .collect(Collectors.toList());\n```\n\n```java\nList<Person> sortedByAge = people.stream()\n                                 .sorted(Comparator.comparing(Person::getAge))\n                                 .collect(Collectors.toList());\n```\n\n### `peek`([[lang.java.lib.interfaces.func.consumer]])\n\nPerforms an action on each element without altering the stream.\n\n```java\nnumbers.stream()\n       .peek(n -> System.out.println(\"Processing number: \" + n))\n       .collect(Collectors.toList());\n```\n\n### `limit(long n)`\n\nLimits the stream to first n elements.\n\n```java\nList<Integer> firstThree = numbers.stream()\n                                  .limit(3)\n                                  .collect(Collectors.toList());\n```\n\n### `skip(long n)`\n\nSkips the first n elements.\n\n```java\nList<Integer> withoutFirstTwo = numbers.stream()\n                                       .skip(2)\n                                       .collect(Collectors.toList());\n\n```\n\n\n### Terminal Operations\n\nThese operations consume the stream and return a result.\n\n### `forEach`([[lang.java.lib.interfaces.func.consumer]])\n\nPerforms an operation for each element.\n```java\nnames.stream().forEach(System.out::println);\n```\n\n### `collect(Collector)`\n\nCollects the stream into a collection.\nInstance of Collector can be fetched from [[lang.java.lib.classes.collectors]] API.\n\n\n```java\nList<String> collectedNames = names.stream().collect(Collectors.toList());\n```\n\n### `<U> U reduce(U identity,` [[lang.java.lib.interfaces.func.function.BinaryOperator]]` accumulator)`\n\nReduces stream to a single value.\n\n- `identity` value is used as the initial value\n- `accumulator` function is used to combine all the elements.\n\n```java\nint sum = numbers.stream()\n                 .reduce(0, Integer::sum);\n\n```\n\n### `toArray()`\nConverts stream into array.\n```java\nString[] nameArray = names.stream().toArray(String[]::new);\n```\n\n### `min`([[lang.java.lib.interfaces.func.comparator]]) and  `max`([[lang.java.lib.interfaces.func.comparator]])\n\n```java\nOptional<Integer> min = numbers.stream()\n                               .min(Comparator.naturalOrder());\n\n```\n\n### `count()` \n```java\nlong count = numbers.stream().count();\n```\n### `anyMatch`([[lang.java.lib.interfaces.func.function.predicate]]), `allMatch`([[lang.java.lib.interfaces.func.function.predicate]]) and `noneMatch`([[lang.java.lib.interfaces.func.function.predicate]])\n\n```java\nboolean hasEven = numbers.stream()\n                         .anyMatch(n -> n % 2 == 0);\n```\n\n### `findFirst()`\n```java\nOptional<Integer> first = numbers.stream()\n                                 .findFirst();\n\n```\n### `findAny()` \n\n```java\nOptional<Integer> any = numbers.stream()\n                               .findAny();\n\n```\n\n---\nIntroduced in [[lang.java.v.8]]","n":0.061}}},{"i":94,"$":{"0":{"v":"Marker Interface","n":0.707},"1":{"v":"\n\n[[arch.design.oo.patterns.gof.structural.marker]]s in Java.\n","n":0.577}}},{"i":95,"$":{"0":{"v":"Serializable","n":1},"1":{"v":"\nFor allowing [[paradigm.oo.components.object.serialization]].\n","n":0.577}}},{"i":96,"$":{"0":{"v":"Cloneable","n":1},"1":{"v":"\nThis interface can be implemented by the class for allowing [[paradigm.oo.components.object.cloning]].\n","n":0.302}}},{"i":97,"$":{"0":{"v":"RandomAccess","n":1},"1":{"v":"\n[[lang.java.lib.interfaces.marker]] from java.util.","n":0.577}}},{"i":98,"$":{"0":{"v":"Functional Interface","n":0.707},"1":{"v":"\n[[lang.java.paradigms.func.interface]]s provided by Java.","n":0.5}}},{"i":99,"$":{"0":{"v":"Function","n":1},"1":{"v":"\n- Represents a function that takes one argument and produces one result. \n- Used for expressing computations and transformations.\n\n\n## Definition\n\n```java\n@FunctionalInterface\npublic interface Function<T, R> {\n    R apply(T t);\n}\n```\nT - input type\nR - output type\n\n\n## Usage\n\n```java\nFunction<String, Integer> stringLength = s -> s.length();\nint lengthOfHello = stringLength.apply(\"Hello\"); // 5\n```","n":0.149}}},{"i":100,"$":{"0":{"v":"Predicate","n":1},"1":{"v":"\n- [[lang.java.paradigms.func.interface]] which represents a boolean-values function that takes **one** argument.\n- Provides a convenient way to define and pass around functions that return a true or false value based on their input.\n\n## Definition\n\n```java\n@FunctionalInterface\npublic interface Predicate<T> {\n    boolean test(T t);\n}\n```\n\nIt is also [[Generic|lang.java.typing.generics]].\n\n## Usage\n\n```java\nPredicate<String> isEvenLength = s -> s.length() % 2 == 0;\nboolean result = isEvenLength.test(\"Hello\");\n```","n":0.135}}},{"i":101,"$":{"0":{"v":"BinaryOperator","n":1},"1":{"v":"\n- Takes two inputs and returns one - all of the same type.\n- Great for performing binary operations on objects like 2+5=7\n\n## Definition\n\n```java\n@FunctionalInterface\npublic interface BinaryOperator<T> {\n    T apply(T t, T u);\n}\n```\n\n\n## Usage\n\n```java\nBinaryOperator<Integer> sum = (x, y) -> x + y;\nint result = sum.apply(5, 3); // 8\n```","n":0.147}}},{"i":102,"$":{"0":{"v":"Consumer","n":1},"1":{"v":"\nRepresents an action that takes in a single input and returns no result.\n\n## Definition\n\n```java\n@FunctionalInterface\npublic interface Consumer<T> {\n    void accept(T t);\n}\n```","n":0.224}}},{"i":103,"$":{"0":{"v":"Comparator","n":1},"1":{"v":"\nAllows to define custom ordering of objects. For example, while sorting.\n\n## Definition\n```java\n@FunctionalInterface\npublic interface Comparator<T> {\n    int compare(T o1, T o2);\n}\n```\n\n## Usage\n\n```java\nclass AgeComparator implements Comparator<Person> {\n    @Override\n    public int compare(Person p1, Person p2) {\n        return p1.getAge() - p2.getAge();   \n\n    }\n}\n\npublic class ComparatorExample {\n    public static void main(String[] args) {\n        List<Person> people = new ArrayList<>();\n\n        Collections.sort(people, new AgeComparator());\n    }\n}\n```\n\n```java\nCollections.sort(people, (p1, p2) -> p1.getAge() - p2.getAge());\n```\n\n### Default methods\n\nIn addition to the abstract method `compare`, it also provides a bunch of utility methods to easily define a Comparator.\n\nFor example,\n\n```java\nList<Person> sortedByAge = people.stream()\n                                 .sorted(Comparator.comparing(Person::getAge))\n                                 .collect(Collectors.toList());\n\n```\n\nHere's a list of all such methods:\n\n- **static comparing([[lang.java.lib.interfaces.func.function]] keyExtractor)**: Like the example above\n- **static comparing([[lang.java.lib.interfaces.func.function]], Comparator)**: Like the example above but with Comparator for the given key.\n\nSimilar methods but for specific types:\n\n- static comparingDouble\n- static comparingInt\n- static comparingLong\n\nLexicographic order sorting (to be used after the above methods):\n- thenComparing\n- thenComparingDouble\n- thenComparingInt\n- thenComparingLong\n\nMethods for null friendly Comparator\n- nullsFirst(Comparator)\n- nullsLast(Comparator)\n\nTo modify ordering or comparator: \n- **static naturalOrder**: returns Comparator which compares [[lang.java.lib.collection.comparable]] objects in natural order\n- static reverseOrder()\n- reversed()\n\n\n","n":0.077}}},{"i":104,"$":{"0":{"v":"andThen","n":1},"1":{"v":"\n`andThen` is a method present in functional interfaces such as [[lang.java.lib.interfaces.func.function]], [[lang.java.lib.interfaces.func.function.predicate]] and [[lang.java.lib.interfaces.func.consumer]] to allow you to chain the operations together.\n\nYou can pass it a second operation which is supposed to follow the first.\n\n## Definition\n\n```java\nR andThen(Function<? super T, ? extends R> after) //R is a functional interface\n```\n\n## Usage\n\n\n```java\nFunction<String, Integer> stringLength = s -> s.length();\nFunction<Integer, String> intToString = i -> String.valueOf(i);\n\nFunction<String, String> lengthToString = stringLength.andThen(intToString);\nString result = lengthToString.apply(\"Hello\"); // \"5\"\n```","n":0.12}}},{"i":105,"$":{"0":{"v":"Classes","n":1}}},{"i":106,"$":{"0":{"v":"Wrapper Classes","n":0.707},"1":{"v":"\n\n- There is a wrapper class for every primitive data type in Java. For example, there’s `Integer` for `int`, `Character` for `char`, `Float` for `float`, `Double` for `double` and so on. That is, the class names are same as the data types’ name (Except char and int) apart from the fact that the class names begin with uppercase letters, which is a convention in Java.\n- We can create objects of these wrapper classes instead of variables of primitive data types.\n    - `Boolean`\n    - `Byte`\n    - `Short`\n    - `Integer`\n    - `Long`\n    - `Float`\n    - `Double`\n- Wrapper classes contains one variable (data member) of their respective primitive data type. They also contain certain functions to manipulate these values.\n- Why?\n  - Java — primitive data types ⇒ Not objects ⇒ Wrapper classes\n  - Also, to make methods available to operate on primitive data types.\n- All wrapper classes are [[arch.design.oo.patterns.immutable class]]es\n- All wrapper classes implement [[lang.java.lib.collection.comparable]].\n\n## Useful Methods\n\n### valueOf()\n\n- Static Method\n- Returns object reference of corresponding wrapper class.\n- **Syntax**\n\n    ```java\n    WrapperClass reference_variable = WrapperClass.valueOf(“Number in string format”, base-decimal by default);\n    ```\n\n- **Example**\n\n    ```java\n    Integer i1=Integer.valueOf(“123”);\n    Integer i2=Integer.valueOf(“101011”,2);\n    Double d1=Double.valueOf(“3.14”);\n    ```\n\n## parseXxx()\n\n- Static Method\n- Xxx can be replaced with any primitive data type\n- Similar to valueOf() but returns reference to xxx type rather than a wrapper class object.\n- Syntax\n\n    ```java\n    xxx**.**varname = WrapperClass**.**parseXxx(“Number in string format”);\n    ```\n\n- Example\n\n    ```java\n    int a=Integer.parseInt(“123”);\n    double b=Double.parseDouble(“13.45”);\n    ```\n\n## xxxValue()\n\n- Instance method\n- Xxx can be replaced with any primitive data type\n- Returns corresponding primitive data type.\n- Used to convert from/get the value of a wrapper class object to a primitive data type.\n- **Syntax**\n\n    ```java\n    xxx varname=objectname.xxxValue();\n    ```\n\n- **Example**\n\n    ```java\n    //i1 contains a reference of object of Integer class.\n    int c = i1.intValue();\n    ```\n\n\n### Methods for [[lang.java.typing.casting.string conversion]]","n":0.059}}},{"i":107,"$":{"0":{"v":"Throwable","n":1},"1":{"v":"\n\nRoot class of Java [[lang.java.exceptions]] hierarchy\n\n# Class Hierarchy\n\n- **`Java.lang.Throwable`**\n  - `Exception`\n    - `IOException`\n    - `SQLException`\n    - `ClassNotFoundException`\n    - `RuntimeException`\n      - `ArithmeticException`\n      - `NullPointerException`\n      - `NumberFormatException`\n      - `IndexOutOfBoundsException`\n        - `ArrayIndexOutOfBoundsException`\n        - `StringIndexOutOfBoundsException`\n  - `Error`\n    - `StackOverflowError`\n    - `VirtualMachineError`\n    - `OutOfMemoryError`\n","n":0.16}}},{"i":108,"$":{"0":{"v":"System","n":1},"1":{"v":"\n\n```java\nclass Java.lang.System extends Object\n```\n\nSystem class provides means and interfaces to interact with the [[lang.java.jre]],[[lang.java.jre.jvm]] and [[lang.java.jre.system]].\n\n## Facilities provided by System Class\n\n1. Standard input stream\n2. Standard output stream\n3. Error output stream\n4. Access to externally defined properties and environment variables\n5. Means of loading files and libraries\n6. Some utility methods for quickly copying a portion of an array and getting hashcode.\n\n## Fields\n\nFollowing are the standard streams within the System class. All streams are open and ready to supply data.\n\n- **`public static final InputStream in`:**\n\n    Typically this stream corresponds to keyboard input or another input source specified by the host environment or user.\n\n- **`public static final PrintStream out`:**\n\n    Typically this stream corresponds to display output or another output destination specified by the host environment or user.\n\n    💡`println()` is a method of the `PrintStream` class. We can access it from the `out` static member of `System` class. Thus, `System.out.println()`.\n\n- **`public static final PrintStream err`:**\n\n    Typically this stream corresponds to display output or another output destination specified by the host environment or user.\n\n---\n\n- Why are there two separate streams for output and error when error can be displayed on the output screen itself?\n\n    By convention, this output stream is used to display error messages or other information that should come to the immediate attention of a user even if the principal output stream, the value of the variable out, has been redirected to a file or other destination that is typically not continuously monitored.\n\n\n## Methods\n\nAll methods in System class are [[paradigm.oo.components.modifiers.static]].\n\n\n\n### To interact with [[lang.java.jre]] and [[lang.java.jre.system]] \n- `String clearProperty(String key)`\n- `String getProperty(String key)`\n- `String getProperty(String key, String def)`\n- `String setProperty(String key, String def)`\n- `Properties getProperties()`\n    Determines the current Java System Properties\n- `Map getenv()`\n    Returns an unmodifiable String Map view of the current system environment\n- `String getenv(String name)`\n    Gets the value of the specified environment variable.\n- `SecurityManager getSecurityManager()`\n    Get the system security interface\n- `void setSecurityManager(SecurityManager s)`\n    Sets the system security\n- `String lineSeperator()`\n    Returns the system-dependent line separator String    \n\n### To interact with [[lang.java.jre.jvm]] \n\n- `Console console()`\n    Returns the unique Console object associated with the current Java virtual machine, if any.\n- `long currentTimeMillis`\n    Returns current time in milliseconds\n- `long nanoTime()`\n   Returns the current value of the running Java Virtual Machine’s high-resolution time source, in nanoseconds.\n\n- `void exit()`\n   \n    Terminates the currently running JVM\n\n    ```java\n        class Runtime{\n            void exit(int status){...}\n        }\n    ```\n\n    - The argument serves as a status code; by convention, a nonzero status code indicates abnormal termination.\n    - This method calls the exit method in class Runtime. This method never returns normally.\n    - The call `System.exit(n)` is effectively equivalent to the call: `Runtime.getRuntime().exit(n)`\n\n- `void gc()`\n\n    Calling the gc method suggests that the Java Virtual Machine expend effort toward recycling unused objects in order to make the memory they currently occupy available for quick reuse. When control returns from the method call, the Java Virtual Machine has made a best effort to reclaim space from all discarded objects.\n\n- `void runFinalization()`\n    Request to JVM to run finalization for discarded objects.\n- `Channel inheritedChannel`\n    Return the channel inherited from the entity that created this JVM\n\n\n### I/O Methods\n\n- `void setErr(PrintStream err)`\n    Reassigns the \"standard\" error output stream\n- `void setIn(InputStream in)`\n    Reassigns the \"standard\" input stream\n- `void setOut(PrintStream out)`\n    Reassigns the \"standard\" output stream               \n\n\n### Methods for loading files/libraries\n\n- `void load(String filename)`\n\n    Loads a code file with the specified filename from the local file system as a dynamic library.\n\n    filename = complete path + name\n\n- `void loadLibrary(String libname)`\n\n    Loads the system library specified by the libname argument (The manner in which a library name is mapped to the actual system library is system dependent)\n\n\n- `String mapLibraryName(String libname)`\n\n    Maps a library name into a platform-specific string representing a native library\n\n\n## Utility Methods\n\n- `void arrayCopy(Object source, int sourceStart, Object Target, int targetStart, int Size)`\n\n- `int identityHashCode(Object x)`\n\n    Returns the same hash code for the given object as would be returned by the default method hashCode().\n\n","n":0.039}}},{"i":109,"$":{"0":{"v":"Runtime","n":1},"1":{"v":"\nGetting count of available cores\n\n```java\nint coreCount = Runtime.getRuntime().availableProcessors();\n```","n":0.354}}},{"i":110,"$":{"0":{"v":"Optional","n":1},"1":{"v":"\n- Represents a value that may or may not be present.\n- Useful for handling situations where a value might be null, preventing [[dev.issues.exception.types.unchecked.null pointer]]s.\n\n\n## Usage\n\n```java\n  public void box(Cat schrodingers){\n    Optional<String> optionalName = Optional.ofNullable(schrodingers);\n\n    if (optionalName.isPresent()) {\n        System.out.println(\"Cat is alive\");\n    } else {\n        System.out.println(\"Cat is dead\");\n    }\n  }\n```","n":0.146}}},{"i":111,"$":{"0":{"v":"Object","n":1},"1":{"v":"\n\nGod class in Java - every class inherits this class implicitly\n\n- Why?\n  - By having the Object as the super class of all Java classes, without knowing the type we can pass around objects using the Object declaration.\n  - Before generics was introduced, imagine the state of heterogeneous Java collections. A collection class like ArrayList allows to store any type of classes. It was made possible only by Object class hierarchy.\n  - The other reason would be to bring a common blueprint for all classes and have some list of functions same among them — methods like [hashCode()](https://javapapers.com/core-java/hashcode-and-equals-methods-override/), clone(), toString() and methods for threading which is defined in Object class.\n\n\n## Methods\n\nAll method are public, final and void unless mentioned otherwise.\n\n| Access and Return Type       | Method      | Parameters              |Function                                                                                 |\n|------------------------------|-------------|-------------------------|------------------------------------------------------------------------------------------|\n| Object                       | **getClass()**  |                         | returns class object                                                                     |\n| int (not final)              | **hashCode()**  |                         | returns hashcode number of the object                                                    |\n| boolean (not final)          | **equals()**    | Object                  | compares the provided object with the current object                                     |\n| protected Object (not final) | **clone()**     |                         | creates and returns exact copy of object (throws CloneNotSupportedException)             |\n| String (not final)           | **toString()**  |                         | returns String representation of the object                                              |\n|                              | **notify()**    |                         | wakes up single thread                                                                   |\n|                              | **notifyAll()** |                         | wakes up all threads                                                                     |\n|                              | **wait()**      | long timeout            | wait for specified milliseconds (throws InterruptedException)                            |\n|                              | **wait()**      | long timeout, int nanos | Same as above. Only increases precision.                                                 |\n|                              | **wait()**      |                         | Waits until notify() or notifyAll() is invoked by another thread                         |\n| protected                    | **finalize()**  |                         | Invoked by garbage collector before object is being garbage collected (throws Throwable) |\n\n### Contract of hashcode() and equals() method\n\n> Equal objects must have equal hashcodes.\n\n💡 If two objects have same hashcode, they may or may not be equal.\n\nAlways override hashCode when you override equals. Failure to do so will prevent your class from functioning properly in conjunction with all hash-based collections i.e. HashMap, HashSet etc\n\nIt's a common source of bugs.\n\n## References\n\n[hashCode And equals Methods Override - javapapers](https://javapapers.com/core-java/hashcode-and-equals-methods-override/)\n\n","n":0.054}}},{"i":112,"$":{"0":{"v":"Collectors","n":1},"1":{"v":"\nUtility class which provides implementation of `Collector` interface, which is then used to get a [[collection|lang.java.lib.collection]] or other data form from a [[stream|lang.java.lib.interfaces.streams]].\n\n## Methods\n\n- toList()\n- toSet()\n- toMap()","n":0.192}}},{"i":113,"$":{"0":{"v":"String","n":1},"1":{"v":"\n- **String literal**: A string [[dev.lingo.literal]] in Java is basically a sequence of characters from the source character set. \n- String literals initialised are an object of this String class.\n\n💡 While printing an object, Java compiler implicitly calls toString() method.\n\n## String Memory Management\n\n![[lang.java.jre.memory.string]]\n\n## Immutability\n\nString in Java is an [[arch.design.oo.patterns.immutable class]].\n\n\n![[arch.design.oo.patterns.immutable class#benefits]]\n\n- String Pooling: Memory management using string pool is only possible because strings are immutable.\n\n\n\n## null vs empty String\n\n```java\nString getSome;\nString getMose = \"\";\n```\n\nBoth of them are not the same. `\"\"` is a literal and has a reference pointing to it in the String constant pool, while `getSome` has no value/reference in it so its null → default value for String.\n","n":0.095}}},{"i":114,"$":{"0":{"v":"String Comparison","n":0.707},"1":{"v":"\n\nStrings class implements [[lang.java.lib.collection.comparable]].\n\n### 1. `equals()` method (**authentication**)\n\n- Two variants\n  - public boolean equals (Object another)\n  - public boolean equalsIgnoreCase (String another)\n- Function\n    Compares original content of the String\n\n### 2. `==` operator (**reference matching**)\n\nCompares references not values\n\n### 3. `compareTo()` method (**sorting**)\n\n- Compares _lexicographically_ (dictionary)\n- Returns integer value based on the comparison\n- s1.compareTo(s2)\n  - s1 == s2 ⇒ 0\n  - s1 > s2 ⇒ +ve value\n  - s1 < s2 ⇒ -ve value\n","n":0.118}}},{"i":115,"$":{"0":{"v":"String Builder","n":0.707},"1":{"v":"\n\n\n- Same as [[lang.java.lib.string]] - except its **mutable**\n- Same as [[lang.java.lib.string.buffer]] - except its non-synchronized\n- That is, NOT thread safe","n":0.224}}},{"i":116,"$":{"0":{"v":"String Buffer","n":0.707},"1":{"v":"\n\n- Same as [[lang.java.lib.string]] - except its **mutable**\n- Same as [[lang.java.lib.string.builder]] - except its synchronized\n- [[execution.multithreading.thread safe]] (Multiple threads can't access it simultaneously) ⇒ safe - will result in an order\n","n":0.18}}},{"i":117,"$":{"0":{"v":"Multithreading","n":1},"1":{"v":"\n### Creating a thread\n\nTwo ways-\n\n1. extend [[lang.java.lib.multithreading.thread]] class\n2. implement [[lang.java.lib.multithreading.runnable]] interface\n\nImplement the `run()` method -> this is the code which will get executed when the thread runs.\n\n### Executing Threads\n\n- Call `start()` method\n\n    The part after start method call is executed immediately. If you want to execute some part of the code after the thread execution, use `join()` method.\n\n    ```java\n        Thread thread = new ApnaThread();\n\n        thread.start();\n\n        //this part gets executed immediately after start() is called - while the thread is running\n\n        thread.join();\n\n        //this part gets executed after the thread execution is completed.\n    ```\n\n- Use [[lang.java.lib.multithreading.executor service]]","n":0.103}}},{"i":118,"$":{"0":{"v":"Thread","n":1},"1":{"v":"\n\n## Constants\n\n- `NORM_PRIORITY` = 5 (Default priority)\n- `MAX_PRIORITY` = 10\n- `MIN_PRIORITY` = 1\n\n\n## Methods\n\n- [[lang.java.lib.multithreading.runnable]].`run()`\n- `start()`: Starts thread execution - [[lang.java.jre.jvm]] calls `run()`\n- `sleep(ms)`: Causes the thread to sleep for specified milliseconds.\n- `join()`: Waits for the thread to die.\n- `getPriority()`: Returns priority of thread\n- `setPriority(int)`: changes priority of a thread\n- [[lang.java.lib.classes.object]].`wait()`: stops the function until notified\n- [[lang.java.lib.classes.object]].`notify()`: notifies other threads\n","n":0.129}}},{"i":119,"$":{"0":{"v":"Runnable","n":1},"1":{"v":"\n\n## `run()` \n\nThis method needs to be overridden in your thread and actions for a thread are written in this method.\n","n":0.218}}},{"i":120,"$":{"0":{"v":"ExecutorService","n":1},"1":{"v":"\n\n`ExecutorService` is an interface which allows us to execute tasks on thread asynchronously\n\n\n## Instantiation using `Executors` Factory class\n\nInstance can be retrieved from `Executors` factory class using different factory methods based on the number and types of threads needed. \n\n### For single thread\n\n```java\nExecutorService es = Executors.newSingleThreadExecutor();  \n```\n\n### For thread pool\n    \n```java\nExecutorService es = Executors.newFixedThreadPool(10); \n```    \n\n### For scheduled thread pool\nIn scheduled thread pool, we can schedule tasks of the threads.\n\n```java\nExecutorService es = Executors.newScheduledThreadPool(10); \n```\n\n## Methods\n\n### Executing Threads\n\n```java\n//We can use the following methods\nexecute(Runnable task)\nsubmit(Runnable task) / submit(Callable<T> task)\ninvokeAny(Collection<? extends Callable<T>> tasks)\ninvokeAll(Collection<? extends Callable<T>> tasks);\n```\n\n### Shutting down\n\nWe can use the following methods after we're done. If we don't, the threads will keep running and JVM won't shut down.\n\n- `shutdown()` method\n- `shutdownNow()` method\n- `awaitTermination()` method\n\n","n":0.091}}},{"i":121,"$":{"0":{"v":"Java Native Interfaces (JNI)","n":0.5},"1":{"v":"\nJNI serves as an interface between Java Platform independent byte code to and native code (machine code).\n\n## References\n\n- [Java Native Interface - Oracle Docs](https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/intro.html)\n- [JNI APIs and Developer Guides - Oracle Docs](https://docs.oracle.com/javase/8/docs/technotes/guides/jni/)\n- [Guide to JNI - Baeldung](https://www.baeldung.com/jni)\n- [Java Programming Tutorial - Java Native Interface(JNI)](https://www3.ntu.edu.sg/home/ehchua/programming/java/javanativeinterface.html)\n","n":0.151}}},{"i":122,"$":{"0":{"v":"Enums","n":1},"1":{"v":"\n\n[[type theory.data types.enum]] in Java.\n\n## Syntax\n\n```java\n//Syntax\nenum Laptop{\nAPPLE, DELL, HTC; //Semicolon not mandatory\n}\n```\n  \n## Values of an Enum and Constructor of Enums\n\nCompiler adds a constructor to the enum. We can enter custom values for enums too.  We need to create a parameterized constructor for that.\n\n- Example\n\n    ```java\n    enum  Fruits\n    {\n        APPLE(“RED”), BANANA(“YELLOW”), GRAPES(“GREEN”);\n    }\n    ```\n\n    Thus, the value of enum APPLE is not \"APPLE\". It is \"RED\" instead.\n\n    ```java\n    //Example\n    enum Mobile { \n    int price;\n    APPLE(1200), SAMSUNG(700), HTC(400);\n    Mobile(int p){ price = p} //Constructor\n    }\n    ```\n\n- Although, the constructor is private and hence, enums can't be initialised by new().\n\n## Methods\n\n- Functions values(), valueOf() and ordinal() are added by compiler/JVM to the enum\n\n### `values()`\n\n- Returns all values in the enum in form of an array.\n- Usage\n\n```java\nLaptop.values(); \n//Output - APPLE,HTC,SAMSUNG\n\n```\n\n### `valueOf()`\n\n- Returns value of given constant enum\n- Usage\n\n    ```java\n    Laptops.valueOf(\"APPLE\") \n    //APPLE\n    ```\n\n### `ordinal()`\n\n- Returns index of an enum constant.\n- Usage\n\n    ```java\n    Laptops.HTC.ordinal() //2\n    ```\n\n## Internal Code Generated by Compiler for enums\n\n```java\nenum Laptop{ APPLE, DELL, HTC }\n```\n\n**All enums get converted to class**. This 👆🏽 is same as writing 👇🏽\n\n```java\nclass Laptop{\npublic static final String APPLE = \"Apple\";\npublic static final String SAMSUNG = \"Samsung\";\npublic static final String HTC = \"HTC\";\n}\n```\n\n### Detailed version of the above enum code\n\n```java\nfinal class Laptop extends Enum{\n\npublic static Laptop[] values{                         //values()\n    return (Laptop[])$VALUES.clone();\n}\n\npublic static Laptop valueOf(String s){                //valueOf()\n    return (Laptop)Enum.ValueOf(Laptop, s);\n}\n\nprivate Laptop(String s, int i, int j){             //Constructor - is private\n    super(s,i);\n    value = j;\n}\n\npublic static final Laptop APPLE;\npublic static final Laptop SAMSUNG;\npublic static final Laptop HTC;\nprivate int value;\nprivate static final $VALUES[];\n\nstatic{\n    APPLE = new Laptop(\"APPLE\", 0, 1200);\n    SAMSUNG = new Laptop(\"SAMSUNG\", 1, 700);\n    HTC = new Laptop(\"HTC\", 2, 400);\n    $VALUES = (new Laptop[]{\n    APPLE, SAMSUNG, HTC\n    });\n    }\n}\n```\n## Enums in Switch statement\n\nSwitch statement cases can only include values which are in enum.\n\n```java\nenum Laptop{ APPLE, DELL, SAMSUNG }\n.\n.\n.\nLaptop l = Laptop.SAMSUNG; //Creating object of enum\nswitch(l){\n    case APPLE:\n    case SAMSUNG:\n    case LUDO: //Will give error.\n}\n```\n\n# Enums and Classes\n\n- \"Inner\" Enum\n  - In Java, enums can be created inside a class as well.\n- Class extended by all enums\n  - All enums extends a class called **Enum** which in turn extends Object class.\n- Inheritance in enums\n  - Enums can't extend classes but can implement interfaces.\n- Difference between C++ and Java enums\n    Data members and methods can be created inside Java enum\n\n## Difference between enums and class\n\n- Enum constants are public, static, final\n- Enums can't extend other classes\n","n":0.05}}},{"i":123,"$":{"0":{"v":"Collection Framework","n":0.707},"1":{"v":"\nJava Collection Framework defines several classes and interfaces to represent group of individual objects as single entity, i.e. [[data.structure]].  \n\nAlthough, referred to as a framework, it functions more like a library with a collection of classes and interfaces.\n\n## Collection Hierarchy\n\n```mermaid\n    classDiagram\n        class Collection\n        <<interface>> Collection\n\n        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n        class List\n        <<interface>> List\n\n            class ArrayList\n            class LinkedList\n            class Vector\n                class Stack\n\n        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n        class Queue\n        <<interface>> Queue        \n\n            class PriorityQueue\n            class BlockingQueue\n                class PriorityBlockingQueue\n                class LinkedBlockingQueue\n\n        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n        class Set\n        <<interface>> Set\n            \n            class HashSet\n                class LinkedHashSet\n            class SortedSet \n            <<interface>> SortedSet\n                class NavigableSet\n                <<inteface>> NavigableSet\n                class TreeSet\n            \n\n        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n        Collection <|-- List\n            List <|-- ArrayList\n            List <|-- LinkedList\n            List <|-- Vector\n                Vector <|-- Stack\n\n        Collection <|-- Queue\n            Queue <|-- LinkedList\n            Queue <|-- PriorityQueue\n            Queue <|-- BlockingQueue\n                BlockingQueue <|-- PriorityBlockingQueue\n                BlockingQueue <|-- LinkedBlockingQueue\n\n        Collection <|-- Set\n            Set <|-- HashSet\n                HashSet <|-- LinkedHashSet\n            Set <|-- SortedSet\n                SortedSet <|-- NavigableSet\n                    NavigableSet <|-- TreeSet\n        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n```\n\n```mermaid\n   classDiagram\n        class Map\n        <<interface>> Map\n            class HashMap\n            class Hashtable\n                class Properties\n            class IdentityHashMap\n            class SortedMap\n            <<interface>> SortedMap\n                class NavigableMap\n                <<interface>> NavigableMap\n                    class TreeMap\n                class WeakHashMap\n            class Dictionary\n            <<abstract>> Dictionary\n\n        Map <|-- HashMap\n        Map <|-- Hashtable\n        Dictionary <|-- Hashtable\n                    Hashtable <|-- Properties\n        Map <|-- IdentityHashMap\n        Map <|-- SortedMap\n            SortedMap <|-- NavigableMap                                        \n                NavigableMap <|-- TreeMap\n            SortedMap <|-- WeakHashMap\n```\n\n### Interfaces\n\n#### Collection \n\n- Said to be root interface of collection framework (not really though)\n- No class implements Collection interface directly\n\n#### Dequeue\n\n- Double-ended Queue.\n- Like a doubly linked list.\n- Any collection which implements these can be used to implement Stack and Queue.\n\n    Some specific methods for this purpose\n    - `void addFirst(Object O)`\n    - `void addLast(Object O)`\n    - `Object getFirst()`\n    - `Object getLast()`\n    - `Object removeFirst()`\n    - `Object removeLast()`\n\n    Usually `LinkedList` is used for this.\n\n### Classes\n\n- Every Collection class is based on some standard data structure.\n- Important ones are listed below along with some use-cases\n\n\n| Collection Class  | **Data Structure**      | **Suitable for**                                           | **NOT suited for**                   | **Thread Safe** |\n|-------------------|-------------------------|------------------------------------------------------------|--------------------------------------|-----------------|\n| **ArrayList**     | Resizable Array         | Frequent Retrieval                                         | Frequent Insertion/deleting from mid |  No             |\n| **LinkedList**    | Doubly Linked List      | Implementing stack and queue,  Insertion/deleting from mid | Frequent retrieval                   |  No             |\n| **Vector**        | Resizable Array         | Frequent Retrieval                                         | Frequent Insertion/deleting from mid |                 |\n| **Stack**         | Stack                   | LIFO                                                       |                                      |                 |\n|                   |                         |                                                            |                                      |                 |\n| **HashSet**       | Hashtable               | Search Operations                                          |                                      |  No             |\n| **LinkedHashSet** | Hashtable + Linked List | Cache-based Applications                                   |                                      |  No             |\n| **TreeSet**       | Balanced Tree           | Cache-based Applications                                   |                                      |  No             |\n|                   |                         |                                                            |                                      |                 |\n| **HashMap**       |                         |                                                            |                                      |  No             |\n| **Hashtable**     |                         |                                                            |                                      |  Yes            |\n| **TreeMap**       |                         |                                                            |                                      |  No             |\n\n\n### Groups of collections with similar behavior/implementations\n\nCertain groups of collection adhere to a common implementation strategy. Apart from these implementations, these group may also share some of the [[##Behavior]]s.\n\n#### All Collections\n\nCollections are meant to be used for transferring data => All Collection Classes implement: \n\n- **[[lang.java.lib.interfaces.marker.serializable]]**: To transfer object from one place to another\n- **[[lang.java.lib.interfaces.marker.cloneable]]**: When sent from one place to another, the receiver makes a copy of it and operates on it\n- Constructors:\n\n\n#### Legacy Collections\n\n`Vector`, `Stack` and `Hashtable`\n\n- Some legacy collections have additional \"legacy\" methods along with the other methods which they have inherited. These names may sound a bit boomer or longer, since they are legacy.\n\nFor example, ˇaddElements(Object O)` in Vector and `enumeration()` in all legacy classes.\n\nIt is recommended to use the modern methods and the legacy methods are only kept for backward compatibility.\n\n\n#### Sorted, Navigable, Tree\n\n`TreeSet` and `TreeMap`\n\n##### Sorted\n\n| Methods |Returns |\n|-----------|---------------|\n| `first()` | first element |\n| `last()`  | last element  |\n| `headSet(a)` | elements less than *a*  |\n| `tailSet(a)` | elements greater than or equal to *a* |\n| `subSet(a,b)` | elements between *a* and *b* including *a* |\n| `comparator()` | Comparator object which defines underlying sorting technique  |\n|                   |   (If we're using default natural sorting order, then it simply returns null) |\n\nSorted collections use [[lang.java.lib.collection.comparable]] or [[lang.java.lib.interfaces.func.comparator]] to determine the natural ordering of the objects. If the class doesn't implement `Comparable` and no `Comparator` is passed, adding elements to the collection will result in a [[NullPointerException|dev.issues.exception.types.unchecked.null pointer]].\n\nSame methods are also applicable for Map.\n\n#### Navigable\n\nDefines several methods for navigation.\n\n\n#### Hash-based collections\n`HashMap`, `HashSet`, `Hashtable` ...\n\n- `HashSet` is a wrapper on top of `HashMap` which stores its values in the `key`s (so as to avoid duplicates) and stores some vague value for the `value` part. \n\n\n##### Internal Implementation\n\nImplementation of hash, the structure and rehashing is similar in all hash-based collections.\n\n```java\nHashMap <K,V> implements Map<K,V>\n{\nEntry <K,V> {} //Inner class\nEntry next; //reference to another entry to store entries like linked lists\n\nint hash; //Hashvalue of key to avoid calculating everytime its  needed\n}\n```\n\n- Initially, it is stored as an array of initial capacity (0-15 if initial cap is 16).\n- Once the array is filled more than 75% (load factor - 0.75), the table size doubles to 32. The hashtable is rehashed (Internal data structures are rebuit)\n- Java 8 improvement: When the number of nodes in a HashMap reaches the TREEIFY_THRESHOLD (constant), the nodes are converted to TreeNode. Basically, from linked list to a balanced tree. This improves the worst case performance from O(n) to O(log n). After the HashMap becomes small due to removal or resizing, TreeNodes are converted back to nodes. Since, HashSet also uses HashMap - it also benefits from this.\n- **HashMap Bucket Resizing Overhead: You should create HashMap with initial capacity close to your expected volume. If its too small, and the load is in millions, whenever the bucket will reach its load factor it will resize and rehash → which is a very costly operation. Also, make sure to use full capacity else a lot of memory of unused blocks will go wasted**.\n\n#### Linked list based\n\n- References not stored contiguously → no shift operations required while adding/removing elements\n\n\n#### Concurrent Collections\n\n- BlockingQueue\n\n#### Enum\n\n#### Fixed size collections\n\n`ArrayBlockingQueue` , `LinkedBlockingQueue`\n\n\n\n## Behavior\n\n💡 Collection classes only deviate from behaviors of their parent when it stops them from implementing their intended behavior.\n\n### Allowed elements\n\n- All collections **allow heterogeneous objects** (except `TreeSet` and `TreeMap`).\n    `TreeSet` and `TreeMap` store elements in a particular sorted order by comparing them. Comparing null values throws `NullPointerException` which is why they don't allow it.\n- Duplicate and null values\n    - Adding duplicates in collections which don't allow it doesn't generally throw any exception. Usually the `add()` or `addAll()` method will just return `false` in such cases.\n\n    |        | Duplicates         | null insertion    |  \n    |--------|--------------------|-------------------|\n    |`List`  | Allowed            | allowed           |\n    |`Set`   | NOT Allowed        | allowed           |\n    |`Queue` | Allowed            | allowed     |  \n    |`Map`   | Allowed for values | allowed           |\n \n\n- `List` is the most straighforward implementation. Similar to an array of a linked list, it allows duplicates and keeps the ordering as you insert it. No acrobatics. It also allows null values.\n- `Set` as the name suggests, is like mathematical sets. By definition, mathematical sets can't have duplicates. But there can be \"null\" or empty sets. So it allows null values.\n-  `Queue`s in general allow duplicates. It generally doesn't allow null elements either but if allowed - it should be avoided\n\n    From Javadoc:\n    > Queue implementations generally do not allow insertion of null elements, although some implementations, such as LinkedList, do not prohibit insertion of null. Even in the implementations that permit it, null should not be inserted into a Queue, as null is also used as a special return value by the poll method to indicate that the queue contains no elements.\n\n- null values are treated as any other values in collections which allow it. For example, `Set`s allow null values but they don't allow duplicates, so even if you add `null` twice, it will be treated as one. Similarly, `Map`s only allow one `null` value in key and multiple `null` value as values.\n\n### Capacity\n\n- **Default Initial Capacity**: The initial capacity assigned to a Collection class object by default, if not specified while initializing the object. \n- **Fill Ratio/Load Factor**: The percentage or ratio of capacity which when reached will result in increasing of the capacity. \n- **Resizing Strategy**: How much the capacity will be increased upon reaching threshold.\n\nFor example, if the initial default capacity is 10 and fill ratio is 0.7 - the capacity will increase once 7 places are filled.\n\n\n#### Common patterns\n\nAlthough there is no universal pattern for these properties, but some common patterns are observed due to the design decisions.\n\n|                            | Default Initial Capacity | Load factor | Resizing Strategy                                   |\n|----------------------------|--------------------------|-------------|-----------------------------------------------------|\n| Array-based collections    | 10                       | 1+          | Triggered when array is full  1.5x + 1 in ArrayList, 2x in Vector |\n| Hash-based collections     | 16                       | 0.75        | 2x                                                  |\n| Fixed-capacity collections | Explicit                 | NA          | NA                                                  |\n\n- Initial capacity for hash-based collections is and should be chosen as a reasonable balance between space efficiency and performance.\n- Array-based collections usually have slightly lower default capacities to avoid unessecary memory allocation. New array is created with the new capacity once array is full. Keepign initial capacity also prevents too many elements to be copied while resizing.\n- Some collections which are based on dynamic data structures, like `LinkedList` and **Tree-based collections**, and have default initial capacity as 0. Elements are added as they come.\n- `Vector` also allows to pass an incrementalCapacity by which the capacity will be increased if it is full (instead of doing 2x).\n\n### Ordering of elements \n\nIn general:\n\n- `List` collections maintain insertion order.\n- `Queue` FIFO\n- `Set`: Ordering usually doesn't matter in mathematical sets, so the interface leaves ordering upto its implementations.\n\nBut ordering of elements is based more on the behavior/data structure the collection class intends to implement:\n\n- **Linked collections** (Linked*): Maintain insertion order.\n- **Hash-based collections** (Hash*): Elements stored in order of hash codes.\n- **Sorted Collections** (Tree* and Sorted*): Elements sorted based on natural order or provided `Comparator`  \n- **Priority-based Collections**: Ordered according to priority\n- **Stack**: Even though it implements list, it orders elements in LIFO.\n\n### Constructors\n\n\n- Almost all Collection framework classes have the usual nullary constructor.\n    ```java\n        Collection<T> c = new CollectionImplementation<T>();\n    ```\n    Exceptions: Fixed size collections and some concurrent collections\n\n- Most mainstream `Collection` implementations provide an overloaded constructor that accepts object of any `Collection` implementation. \n    ```java\n        Collection<T> c = new CollectionImplementation<T>(someOtherCollection);\n    ```\n    Exceptions:\n    - Legacy collections\n    - Tree/Sorted collections: because how will it decide the sorting of ths usual collections.\n    - Concurrent collections: \n        - Initializing concurrent collection with non-concurrent collection might cause thread-safety issues\n        - Some concurrent collection might require more information for initializing\n    - Fixed-size collections: Taking in collection which exceed the fixed size might cause issue\n\n- All `Map` implementations provide an overloaded constructor which accepts object of `Map` (including legacy, sorted and concurrent ones).\n    ```java\n        Map<K,V> m = new MapImplementation<K,V>(someOtherMap);\n    ```\n\nSome other collections offer additional overloaded constructors:\n\n- **Array-based** collections and **Fixed size** collections:\n    ```java\n        ArrayList<T> al2 = new ArrayList<T>(int initialCapacity);\n    ```\n- **Hash-based collections**\n    ```java\n        Hash___ h = new Hash___(int initialCapacity);\n        Hash___ h = new Hash___(int initialCapacity, float loadFactor);\n    ```\n- **Tree/sorted** collections\n    ```java\n        Tree___(Comparator<? super K> comparator)\n        Tree___(Sorted___<? extends K, ? extends V> m)\n    ```\n- `Vector`\n    ```java\n    Vector v = new Vector(int initialCapacity, int incrementalCapacity);\n    ```\n## Utilities\n\n### Iterating over collections\n\nAlthough there are multiple iterators offered by the framework. The most common usage is as below:\n\n```java\n  Iterator i = c.iterator();\n  while(i.hasNext()){\n    i.next();\n  }\n```\n\nFor more details about different types of iterators. See [[lang.java.lib.collection.iterators]]\n\n\n\n### `Collections` Class\n\nUtility class (`java.util.package`) which defines several methods for collection objects.\nMost of these methods are static.\n\n#### Methods\n\n##### `static sort()` and `static sort(Comparator c)`\n\nSorts the collection objects (if [[lang.java.lib.collection.comparable]]) either based on their natural ordering, or based on the [[lang.java.lib.interfaces.func.comparator]] if passed.\n\n⚠️ If the class doens't implement `Comparable` and `sort` is called without a `Comparator`, it will throw a [[ClassCastException|dev.issues.exception.types.unchecked.class cast exception]].\n\n\n## Important Distinctions \n\n### Array vs ArrayList\n\nThe main difference lies in the dynamic and resizeable nature of `ArrayList`. You don't even have to specify an initial size in `ArrayList`\n\n### Common distinction between legacy collections and their modern counterparts\n\n**ArrayList vs Vectors / HashMap vs Hashtable**\n\nLegacy collections are thread-safe. Their modern counterparts aren't.\n\n`Vector`(and even `Stack`)/Hashtable is thread-safe (most methods are synchronised)\n`ArrayList`/`HashMap` is not.\n\n💡 If something is thread-safe, it will inevitably have a lower performance in comparison to a corresponding non-synchronised something.\n\n### `size()` vs `capacity()`\n\n- size = number of objects currently\n- capacity = number of objects which can be accommodated\n\n\n\n## References\n\n - [Collections Framework Overview - Java - Oracle Documentation](https://docs.oracle.com/javase/8/docs/technotes/guides/collections/overview.html#:~:text=Not%2C%20strictly%20speaking%2C%20a%20part%20of%20the%20collections,and%20relies%20on%20some%20of%20the%20same%20infrastructure.)\n - [Why some collections can't allow heterogenous objects?](https://andbin.dev/java/why-some-collections-cannot-be-heterogeneous)\n - [Understand Queue Insertion - Stack Overflow](https://stackoverflow.com/questions/28147076/understanding-queue-insertion)\n\n### Hashmaps\n- [How HashMap works in Java? With Animation!! whats new in java8 tutorial](https://www.youtube.com/watch?v=c3RVW3KGIIE)\n- [Java 8 HashMap Implementation and Performance - DZone Java](https://dzone.com/articles/java8-hashmap-implementation-and-performance)\n- [Java Hashed Collections](https://www.developer.com/design/java-hashed-collections/)\n- [What are the differences between hashtable and hashmap? (Not specific to Java)](https://stackoverflow.com/questions/36313817/what-are-the-differences-between-hashtable-and-hashmap-not-specific-to-java)","n":0.022}}},{"i":124,"$":{"0":{"v":"Iterators","n":1},"1":{"v":"\nCollection framework provides iterator interfaces like `Enumeration`, `Iterator` and `ListIterator` to iterate over the elements within a collection. \n\n`Enumeration` is a legacy interface. While `ListIterator` is a child of `Iterator` specifically for lists.\n\n## Use cases and Trade Offs\n\n- `Enumeration` can only be used for [[legacy collections|lang.java.lib.collection#legacy-collections]] like `Vector` and `Hashtable`. Also, it supports only **read operations**.\n- `Iterator` is the most commonly used since it can be used for any Collection. It can be used to remove but not for replacing or adding new object.\n- Both `Enumeration` and `Iterator` are only forward direction cursor\n- `ListIterator` is the most powerful cursor which is bidirectional and has methods to remove, replace and add new objects. But it can only be used for `List` collections.\n\n\n## Initialization\n\n```java\n Enumeration e = v.elements(); //v is a vector\n Iterator itr = c.iterator(); //c is any collection object\n ListIterator litr = l.listIterator(); //l is any List object\n``` \n\nBut all the iterators mentioned above are interfaces.\n\nHow can we create objects for interfaces then? ⇒ **We don't**.\n\nThese methods being used to initialize the iterators have a class within them which implements the corresponding interface. The object of this class is then returned. \n\n```java\nSystem.out.println(i.getClass().getName()); //i is an object of a iterator\n```\n\nOutput:\n```java\nvector$1              // if c is an Enumeration Object\nvector$Itr            // if c is an Iterator Object\nvector$ListItr        // if c is a List Iterator Object\n```\n\n`vector$` means inner class of vector ( or whichever Collection class we're getting the object for)\n\n1 means it is an anonymous inner class\n\n`Itr` and `ListItr` are names of [[lang.java.paradigms.oo.inner class]]es implementing Iterator and ListIterator respectively.\n\n\n\n## Methods\n\n### Enumeration\n- `public boolean hasMoreElements()`\n- `public Object nextElement()`\n\n\n### Iterator\n\n- `public boolean hasNext()`\n- `public Object next()`\n- `public void remove()`\n\n### List Iterator\n\nForward\n\n- `public boolean hasNext()`\n- `public Object next()`\n- `public int nextIndex()`\n\nExtra capabilities\n\n- `public void remove()`\n- `public void set(Object new)` → replace\n- `public void add(Object new)`\n\nBackward\n\n- `public boolean hasPrevious()`\n- `public Object previous()`\n- `public int previousIndex()`\n\nThe `set()` method of `ListIterator` interface is used to replace the last element which is returned by the `next()` or `previous()` along with the given element. The call can be added only if neither `remove()` nor `add(E)` method have been called.\n","n":0.054}}},{"i":125,"$":{"0":{"v":"Comparable","n":1},"1":{"v":"\nComparable is used to define natural ordering for user-defined types. \n\nTo do that, the class should implement the `Comparable` interface and define its `compareTo()` method.\n\n## Definition\n\n```java\npublic interface Comparable<T> {\n    int compareTo(T o);\n}\n```\n\n## Implementation\n\n`compareTo()` has context of two objects. One, which is being used to invoke it and the other, which it takes as an input. It then compares these two objects (the part which is to be implemented) and returns and integer indicating the order.\n\n- **Negative**: current object is less than the other object. \n- **Zero**: current object is equal to the other object. \n- **Positive**: current object is greater than the other object.\n\n\n```java\ncompareTo(T o){\n if(this < o) return -1;\n \n if(this == o) return 0;\n\n if(this > o) return 1;\n}\n```\n\n\n## Usage\n\nIf a class implements this, you can use the `compareTo()` method to compare its two objects.\n\n```java\nswitch(obj1.compareTo(obj2)){\n    case -1: // obj1 <  obj2\n    case 0:  // obj1 == obj2\n    case 1:  // obj1 >  obj2\n}\n```","n":0.08}}},{"i":126,"$":{"0":{"v":"Arrays","n":1},"1":{"v":"\n## Arrays in Java are Objects\n\n- This is why arrays are initialized using `new` keyword\n- For each array type, there exists a corresponding class.\n  - So there is a class for int[], for float[], double[] etc.\n  - These classes are the part of java language and not available to the programmer level\n  - To know the class of any array\n\n    ```java\n    // Here x is the name of the array.\n    Sys\n    ```\n\n### Corresponding class names for some array types\n```plain text\nArray typeCorresponding          Class Name\nint[]                            [I\nint[][]                          [[I\ndouble[]                         [D\ndouble[][]                       [[D\nshort[]                          [S\nbyte[]                           [B\nboolean[]                        [Z\n```\n\n>[ for single dimension\n[[ for two-dimensional\n\n- Every array type implements [[lang.java.lib.interfaces.marker.serializable]]  and [[lang.java.lib.interfaces.marker.cloneable]]. \n- Arrays can be assigned to variables of type Object — [[type theory.casting.object.upcasting]].\n- All methods of Object class can be invoked on an array\n\n## `Arrays` Methods \n\n- `Arrays.sort(arr)`\n- `Arrays.fill(arr,0)`: Fills all elements of an array with the passed value.\n\n## References\n\n- [Is an array a primitive type or an object in Java? - GeeksforGeeks](https://www.geeksforgeeks.org/array-primitive-type-object-java/)\n- [Chapter 10. Arrays - Oracle Docs](https://docs.oracle.com/javase/specs/jls/se7/html/jls-10.html)\n","n":0.079}}},{"i":127,"$":{"0":{"v":"Ds","n":1}}},{"i":128,"$":{"0":{"v":"Stack","n":1},"1":{"v":"\n`Stack` class from [[lang.java.lib.collection]] class can be used.\n\n## Creating\n\n```java\nStack<Integer> stack = new Stack<>();\n```\n\n## Pushing\n\n```java\nstack.push(i)\n```\n\n## Popping\n\n```java\nInteger i = stack.pop()\n```\n\n## Peeking\n\nReturns last element without removing.\n\n```java\nInteger i = stack.peek()\n```\n\n## Searching\n\nReturns position of the element. \n\nPosition starts from 1(not 0) and is counted from the topmost(last) element.\n\nReturns -1 if element is not found.\n\n```java\nInteger pos = stack.search(element);\n```\n","n":0.139}}},{"i":129,"$":{"0":{"v":"Design","n":1}}},{"i":130,"$":{"0":{"v":"No pointers","n":0.707},"1":{"v":"\n## Why Java doesn't have pointers?\n\n![[dev.lingo.variable.pointer.against]]\n\nConsidering the above points:\n- Java has a robust security model and disallows pointer arithmetic for this reason. It would be impossible for the JVM to ensure that code containing pointer arithmetic is safe without expensive runtime checks.\n- Java instead provides very good automatic garbage collection which takes care of memory management for you.\n\n    For many people who had previously been forced to deal with [[dev.memory management.manual]] in Pascal/C/C++ this was one of the biggest advantages of Java when it launched.\n\n- Complexity\n  \n  - **Array access via pointer offsets**\n      Java does this via indexed array access so you don't need pointers. A big advantage of Java's indexed array access is that it detects and disallows out of bounds array access, which can be a major source of bugs. This is generally worth paying the price of a tiny bit of runtime overhead.\n  - **References to objects**\n      Java has this, it just doesn't call them pointers. Any normal object reference works as one of these. When you do `String s=\"Hello\";` you get what is effectively a pointer to a string object.\n  - **Passing argument by reference**\n      i.e. passing a reference which allows you to change the value of a variable in the caller's scope - Java doesn't have this, but it's a pretty rare use case and can easily be done in other ways. This is in general equivalent to changing a field in an object scope that both the caller and callee can see.\n\nFrom the sun white paper [The Java Language Environment](http://java.sun.com/docs/white/langenv/Simple.doc2.html):\n  \n  > Most studies agree that pointers are one of the primary features that enable programmers to inject bugs into their code. Given that structures are gone, and arrays and strings are objects, the need for pointers to these constructs goes away. Thus, Java has no pointer data types. Any task that would require arrays, structures, and pointers in C can be more easily and reliably performed by declaring objects and arrays of objects. Instead of complex pointer manipulation on array pointers, you access arrays by their arithmetic indices. The Java run-time system checks all array indexing to ensure indices are within the bounds of the array.You no longer have dangling pointers and trashing of memory because of incorrect pointers, because there are no pointers in Java.\n\n## References\n\n- [Why Java doesn't support pointers? — Stack overflow](https://stackoverflow.com/questions/9595636/why-java-doesnt-support-pointers)\n- [The Java Language Environment - Sun White Paper](http://java.sun.com/docs/white/langenv/Simple.doc2.html)\n","n":0.05}}},{"i":131,"$":{"0":{"v":"Hate","n":1},"1":{"v":"\n- [Some(read, lot of) hate for Java](http://warp.povusers.org/grrr/java.html)\n","n":0.378}}},{"i":132,"$":{"0":{"v":"Concurrency","n":1}}},{"i":133,"$":{"0":{"v":"Multithreading","n":1},"1":{"v":"\nComponents involved in [[lang.java.lib.multithreading]] in Java:\n\n- Threads\n- Thread Scheduler\n- Thead Pool\n- Executor Service\n\n## Threads\n\n- One Java thread corresponds to one CPU thread.\n\n\n### Life Cycle\n\n```mermaid\nstateDiagram\n    state Thread{\n        Runnable \n        Running \n        Terminated\n    }\n    state BlockedCode{\n        NonRunnable \n    }\n\n    [*] --> Runnable\n    Runnable --> Running: start()\n    Running --> Terminated\n\n    Running --> NonRunnable: sleep, block on I/O, wait for lock, suspend, wait\n    NonRunnable --> Runnable: sleep done, I/O complete, lock available, resume, notify, notifyAll\n        \n```\n## Thread Scheduler\n\nTask executes for a predefined slice of time and then re-enters pool of ready tasks.\n\nNext task decided based on priority and other factors.\n\nUses [[execution.scheduling.pre-emptive]] and [[execution.scheduling.time slicing]]\n\n### Thread Pool\n\nIf you use [[lang.java.lib.multithreading.executor service]] to initialize a thread pool.\n\n![Thread Pool](assets/images/2024-09-26.png)\n\n- Threads initialized will pick up tasks from the queue of tasks given to the executor service\n- Since multiple threads are accessing this queue simultaneously, executor service uses a [[BlockingQueue|lang.java.lib.collection#concurrent-collections]].\n\n#### Ideal Pool Size\n\n- **CPU Intensive tasks**: Tasks which block the CPU cores. For example, intensive hashing or cryptographic algorithms. In such cases, if you have even thousands of tasks, the number of threads running at a time will be equal to the number of cores on your CPU. So if you have too many threads, CPU will simply keep rotating between all these tasks and won't be able to actually complete any of these quick. \n\n    In such cases, **Ideal Pool Size = CPU Core count**\n\n    Use [[lang.java.lib.classes.runtime]] to get the core count and initialize executor service with that.\n\n    Other consideration: How many other applications (or executors/threads are running on the same CPU)\n    \n- **I/O Intensive tasks**: Tasks which don't really need the CPU, like input/output from user, or calls to a remote service. In such cases, even if you create few threads, CPU will keep waiting for a response to come back, staying idle. \n\nIdeal pool size will be higher in such cases.\n\nExact number will depend on the rate of task submissions and average task wait time. Too many threads will increase memory consumption too.\n\n#### Types of Pools\n\n- FixedThreadPool\n- CachedThreadPool\n- ScheduledThreadPool\n- SingleThreadedExecutor\n\n\n## References\n\n- [Java Concurrency - Defog Tech - YouTube Playlist](https://www.youtube.com/playlist?list=PLhfHPmPYPPRk6yMrcbfafFGSbE2EPK_A6)","n":0.054}}},{"i":134,"$":{"0":{"v":"Thread Safety","n":0.707},"1":{"v":"\nHow to make a block of code thread safe?\n\nIn addition to the usual ways to ensure [[execution.concurrency.multithreading.thread safety]], Java provides some additional [[execution.concurrency.synchronization]] mechanisms:\n\n1. Thread local fields\n\n    Defining private fields in Thread classes\n\n    - Assigning ThreadLocal instances to a field\n\n        Like normal class fields but each thread accesses them via a setter-getter and gets independently initialized copy of the field so that each thread has its own state\n\n2. Synchronized Collections\n3. Concurrent Collections\n\n    Concurrent collections achieve thread safety by dividing their data into segments and acquiring locks on different segments.\n\n    Better performance\n\n4. Atomic objects\n5. Synchronized Methods\n6. Synchronized statements\n7. Other objects as lock\n8. Volatile fields\n9. Reentrant locks\n10. Read/write locks\n\n### Volatile and Atomic \n\n`volatile` is used when there are two threads store and perform operations on same variable. In such case, both threads store the variable in different caches. This results in inaccuracy and inconsistency. Thus, the `volatile` keyword lets [[lang.java.jre.jvm]] know that this is variable is going to be changed and it is then stored in the common cache.\n\n`AtomicInteger`, `AtomicLong` and other such classes are used in a similar situation to above, where the threads are accessing and performing some operation on a variable. If we don't define the variable as Atomic, it might happen that the second thread accesses the variable before the first thread is done performing operation on it. This causes inconsistency in the data. The `AtomicInteger` makes the integer thread safe by not letting any other thread access until one thread is done.\n","n":0.064}}},{"i":135,"$":{"0":{"v":"Deadlocks","n":1},"1":{"v":"\n## Detection\n\nDeadlocks are diffcult to detect as there are multiple locks and threads in Java which run even without us specifying.\n\n### Detection using thread dumps\n\nUse either of the following commands to ask the JVM to print info of all the threads running in the application.\n\nTake the process ID of your application and run the following -\n\n- `kill -3 12704` (where 12704 is the process ID)\n- `jstack 11475 > ./out.txt` (will put that log in the specified file)\n\nJVM will detect the deadlock itself and mention it.\n\n### Detection using Java MXBean\n\nMXBean is an API which you can run constantly in the background which can detect and tell you when the application goes into a deadlock state.\n\n```java\nprivate static void detectDeadlock(){\n    ThreadMXBean threadBean = ManagementFactory.getThreadMXBean();\n    long[] threadIds = threadBean.findDeadlockedThreads();\n    boolean deadLock = threadIds != null && threadIds.length > 0;\n    System.out.println(\"Deadlocks found: \" + deadLock);\n}\n```\n\n## Prevention\n\n- Include timeout for your locks.\n- Have a global order for locks\n- Avoiding unnecessary and nested locks altogether\n- Joining the threads","n":0.079}}},{"i":136,"$":{"0":{"v":"Syntax","n":1},"1":{"v":"\n\n## Hello World\n\n```java\npublic class HelloWorld{\n public static void main(String[] args){\n  System.out.println(\"Hello World\");\n }\n}\n```\n\n## Rules\n\n1. Outer Class - Always public or default\n2. There can be only one public class in a java file.\n3. File name = (public,if any) class name\n4. Every function has to be a member function of a class. Even main function.\n5. Main function’s prototype is fixed `public static void main(String[] args)`\n6. No semicolon after class definition.\n7. Semicolon after every statement.\n\n## Naming Conventions\n\n\n- PascalCase for class names.\n- camelCase for methods, objects and variable names.\n- UPPERCASE for constants\n\n## Comments\n\n```java\n/*Multiple Line*/\n//Single Line\n/** Documentation Style*/\n```\n\n\n## Variables \n\n### Declaration\n\n### Initialization\n\n### Both at once\n\n## Constants\n\nPrefixing `final` keyword to the  declaration+ initialization.\n\n### Blank final variable\n\nFinal variable not initialised during declaration\n\nAll final variables must be initialised, or else => Compile time error\n\n=> These have to be initialized later, in constructor or somewhere.\n\n> It might not sound correct to call it variable since by definition, `final` means constant, so by behaviour, it doesn't vary.\n> But these variables can vary once.\n\n#### Ways to initialise\n  \n- Can be initialised within an [[lang.java.paradigms.oo.instantiation.iib]]\n- Can be initialised within a constructor\n- If there are multiple constructors\n- Initialise in all of them, or else => Compile time error\n\n\n#### Blank static final member/_variable_\n\nBlank final _variable_ which is [[paradigm.oo.components.modifiers.static]].\n\n##### Initialisation\n\nOnly within static block.\n\n\n## Data types\n\n### Primitives\n\n- `byte`\n  - 8 bits and signed\n- `short`\n  - 16 bits and signed\n- `char`\n  - 16 bits and unsigned, so that it may represent Unicode characters\n- `int`\n  - 32 bits and signed\n- `long`\n  - 64 bits and signed\n- `float`\n  - 32 bits and signed\n- `double`\n  - 64 bits and signed\n- `boolean`\n  - it's not numeric, may only have true or false values\n\n#### Suffixing for Non-default Primitive Data Types\n\n- `int` and `long`\n\n    Default type for integer literals is `int`. That is, unless specified otherwise, 35 is an `int`. So if we assign an integer directly to a `long` variable, it will result in compilation error.\n\n    ```java\n    //Compilation error\n    long x = 232342;\n    ```\n\n    Thus, we have to specify explicitly that the value 232342 is a `long`.\n\n    This can be done by suffixing `l` or `L` to the value. For example. `232342L`.\n\n- `float` and `double`\n\n    Similarly, double is the default value for floating point literals. Unless explicitly stated, 9.5 is a `double` not a `float`.\n\n    ```java\n    float a = 3.7 // 3.7 is a double, ‘a’ is float => Error\n    float a = 3.7f // a is a float\n    ```\n\n#### Prefixing for Different Bases\n\n- **Decimal**: `127`\n- **Hexadecimal**: `0x7f` (Prefix - `0x`)\n- **Octal**: `0177` (Prefix - `0`)\n- **Binary**: `0b10011001` (Prefix - `0b`)\n\n### Compound\n \n#### Array\n\n##### Declaration\n```java\nint[] arr;\n```\n\n```java\nint a[];\n```\n\nArray can be defined in java in the above two ways. However, unlike C++ defining an array actually means that we are defining a pointer, which will point to an array.\n\n##### Initialization\n\n```java\nint arr[] = new int(3)\n```\n\n#### Strings\n\n##### Declaration\n\n```java\nString s;\n```\n\n##### Initialization\n\n```java\ns = new String();\n```\n\n```java\ns = new String(\"string\");\n```\n```java\ns = \"string\";\n```\n\n##### Both at once\n\n```java\nString s = new String();\n```\n```java\nString s = new String(\"string\");\n```\n```java\nString s = \"string\";\n```\n\n##### Length \n\n```java\ns.length();\n```\n\n##### Looping/character at index\n\n```java\ns.charAt(i);\n```\n#### Structures\n#### Interfaces\n\n#### Classes\n\n##### Creating objects\n\n```java\nBox smallBox;\n```\n\nUnlike C++, the above statement won’t create an object. It will just create a reference variable. The reference variable has to be given an object.\n\n```java\nBox smallBox= new Box();\n```\n\nNow `smallBox` contains address of an object of Box class. That is, it points to the object. However, the object itself has no name.\n\n##### Using objects\n\nThrough its reference.\n\n```java\nclass Example \n {\n public static void main(String[] args)\n  {\n   Box smallBox=new Box();\n   smallBox.setDimension(12,10,5);  \n   smallBox.showDimension; \n  /*From the perspective of C++, \n  it looks like smallBox is the name of an object. \n  Though its not.*/\n   \n   smallBox= new Box();\n  /*smallBox will now refer to a new object \n  and the older object will become ‘Garbage Block’, \n  which will get destroyed \n  when Garbage collector will run.*/\n\n  smallBox.showDimension();\n  /*Will print 0,0,0 since no value is assigned. \n  The default value is 0.*/\n  }\n}\n```\n\n## Operators\n\n## Flow\n\n### Conditionals\n\n### Loops\n\n## Functions/Methods\n\n### `public static void main(String[] args)`\n\n- **`public`**: So that JVM can call main function from outside of the class body.\n\n- **`static`**: Static member functions can be called without an object.\n\n- **`void`**: Always — no return type\n\n- **Argument**: `String[] args`. Array of strings\n\n\n\n\n","n":0.038}}},{"i":137,"$":{"0":{"v":"Spring","n":1},"1":{"v":"\nFramework for building enterprise-level applications in Java. \n\n\n\n## [[paradigm.attribute oriented]] / Spring Annotations\n\n### Stereotype Annotations\n\nDefine purpose of a class. \n\nAlthough, these are not just indicators. These annotations also trigger additional behavior and configurations. These additional behaviors and configurations are based on common aaplication patterns.\n\n#### `@Component`\n\nMarks the class as a general-purpose bean (Spring-managed component).\n\n- Main influence here is to make the class eligible for component scanning. This adds the class to application context.\n- Also allows using `@Autowired` for [[arch.design.oo.patterns.di]].\n\n\n#### `@Service`\n\nMarks the class as [[arch.modelling.roles.service]].\n\nTransaction management can automatically be applied to methods in service class.\n\n#### `@Repository`\n\nMarks a class as [[arch.modelling.roles.repository]].\n\n\nEnables [[arch.modelling.roles.dao]] and persistence related exceptions under Spring's `DataAccessException` hierarchy.\n\n\n![[lang.java.spring.web.mvc#controller]]\n\n![[lang.java.spring.web.mvc#restcontroller]]\n\n\n## Multi-value/array configuration\n\nYou can provide multiple values to annotation attributes in form of an array.\n\n```java\n@RequestMapping(value = \"/\", method = { RequestMethod.GET, RequestMethod.POST })\n```\n\n\n\n## References\n\n- [Spring Guides](https://spring.io/guides) ","n":0.087}}},{"i":138,"$":{"0":{"v":"Web","n":1}}},{"i":139,"$":{"0":{"v":"Spring MVC","n":0.707},"1":{"v":"\nSubmodule within Spring [[lang.java.spring.web]], which provides specific capabilities for implementing [[arch.pattern.mvc]] architecture.\n\nProvides out-of-the-box [[dist.comm.api.rest]] service capabilities.\n\n## Defining web service using annotations\n\n### Stereotypes\n\n#### `@Controller`\n\nMakes [[arch.modelling.roles.controller]]s capable of handling HTTP requests.\n\nWorks along with `@RequestMapping` annotation to map HTTP handler methods.\n\n#### `@RestController`\n\n`@Controller` + `@ResponseBody`\n\nSpecial type of [[arch.modelling.roles.controller]], which combines `@Controller` and `@RequestBody`.\n\n=> Return values of handler methods are automatically serialized into JSON or XML and returned as response.\n\n> NOTE: For the below annotations to work, it is important that the class is annotated with `@Controller` or `@RESTController`. Otherwise, it won't work, there won't be any errors, it simply wouldn't work. \n\n### Endpoints and [[std.web.http]] methods\n\n- `@RequestMapping` \n- `@GetMapping` \n- `@PostMapping`\n- `@PutMapping`\n- `@PatchMapping`\n- `@DeleteMapping`\n\n### Request, response and parameters\n\n#### Payload and response\n\nCan be specified by `@RequestBody` and `@ResponseBody` (not required if you're using REST Controller) annotation.\n\n\n#### URI (Path) Params and Query (Request) Params\n\n`/users/{userId}/orders/{status}?search=keyword&page=1`\n\n```java\n@GetMapping(\"/users/{userId}/orders/{status}\")\npublic String getItemUser(@PathVariable String userId, @PathVariable String status, @RequestParam(\"search\") String searchString, @RequestParam int page){\n...\n}\n```\n\n### Consuming Web Service\n\n\n\n## References\n\n- [Sprign @RequestParam vs @PathVariable](https://www.baeldung.com/spring-requestparam-vs-pathvariable)  #read-later","n":0.079}}},{"i":140,"$":{"0":{"v":"Dependency Injection","n":0.707},"1":{"v":"[[arch.design.oo.patterns.di]] \n\n\n### Spring Container\n\nCore component of Spring which is responsible for managing bean lifecycle.\n\n### Injection \n\n### Annotations \n\n#### `@Lazy`\n\nInstantiates bean only when required.\n\n```java\n ...\n @Autowired\n    public A(@Lazy B b) {\n        this.b = b;\n    }\n...\n```\n\n#### `@DependsOn`\n\nSpecified dependency explicitly to control order of instantiation.\n\n```java\n@Component\n@DependsOn(\"b\")\npublic class A {\n    private final B b;   \n}\n```\n\n\n\n### [[concepts.dependency.cyclic]]\n\n#### What does Spring do?\n\nWhen a cyclic dependency is detected, Spring automatically uses [[concepts.dependency.cyclic.early reference resolution]] to partially initialize beans by injecting a proxy, and injecting the actual dependency later.\n\n#### What can you do using Spring features?\n\nIn case of circular dependencies, the behavior depends on the kind of [[arch.design.oo.patterns.di]] mechanism you use.\n\n##### Use [[arch.design.oo.patterns.di.setter]]\n\nIn such cases, [[arch.design.oo.patterns.di.constructor]] will causes `BeanCurrentlyInCreation`[[lang.java.exceptions]] - should be avoided.\n\n[[arch.design.oo.patterns.di.setter]] or [[arch.design.oo.patterns.di.field]] allow Spring to break down the injection into a two-step process to resolve the dependencies:\n\n1. **Instatiation**: Spring instantiates the beans without the dependencies.\n2. **Injection**: Spring injected the (already initialized) dependencies.\n\n[[arch.design.oo.patterns.di.field]] is anyway discouraged, so use [[arch.design.oo.patterns.di.setter]] as a best practice.\n\n##### `@Lazy` annotation \n\nCan help manage dependencies by delaying the initialization until the bean is actually needed.\n\n##### `@DependsOn` annotation\n\nDoesn't necessarily resolve circular dependency but can help in specifying order of instatiation.\n\n#### Handling it yourself (recommended)\n\n","n":0.073}}},{"i":141,"$":{"0":{"v":"Bean","n":1},"1":{"v":"\nObjects which are instantiated, assembled and managed by Spring. These objects are added to application context and Spring is responsible for managing their lifecycle.\n\n## Defining\n\n### XML Configuration\n\n\n## References\n\n- ","n":0.189}}},{"i":142,"$":{"0":{"v":"JRE","n":1},"1":{"v":"\n\nEnvironment required to run Java applications.\n\nEven if you're not developing and just want to run a java application, you'd still need JRE.\n\n[[lang.java.jre.jvm]] + Library Classes","n":0.2}}},{"i":143,"$":{"0":{"v":"System Environment","n":0.707},"1":{"v":"\n\nThis environment is a system-dependent mapping from names to values which is passed from parent to child processes. Primarily the set of variables that define or control certain aspects of process execution.\n\n\n## System Properties\n\nJava maintains a set of system properties for its operations. Each java system property is a key-value (String-String) pair.\n\n### System Properties vs Environment Variables\n\nSystem properties and environment variables are both conceptually mappings between names and values. Both mechanisms can be used to pass user-defined information to a Java process. Environment variables have a more global effect, because they are visible to all descendants of the process which defines them, not just the immediate Java subprocess. They can have subtly different semantics, such as case insensitivity, on different operating systems. For these reasons, environment variables are more likely to have unintended side effects. It is best to use system properties where possible. Environment variables should be used when a global effect is desired, or when an external system interface requires an environment variable (such as PATH).\n\n\n## References\n\n- [What is System Environment - Stack Exchange](https://sqa.stackexchange.com/questions/5328/what-is-system-environment)\n- [Java Process: What is the Environment?](https://stackoverflow.com/questions/28244332/java-process-what-is-the-environment)\n- [getenv - Oracle Docs](https://docs.oracle.com/javase/8/docs/api/java/lang/System.html#getenv--:~:text=The%20environment%20is%20a%20system%2Ddependent%20mapping%20from%20names%20to%20values%20which%20is%20passed%20from%20parent%20to%20child%20processes.)\n- [System Environment - IBM](https://www.ibm.com/docs/en/aix/7.1?topic=administration-system-environment#:~:text=2022%2D02%2D07-,The%20system%20environment%20is%20primarily%20the%20set%20of%20variables%20that%20define%20or%20control%20certain%20aspects%20of%20process%20execution.,-They%20are%20set)\n\n\n- [When to use environment variables vs. system properties? - Stack Overflow](https://stackoverflow.com/questions/14026558/when-to-use-environment-variables-vs-system-properties)\n- [Java system properties and environment variables](https://stackoverflow.com/questions/7054972/java-system-properties-and-environment-variables)\n- [Java System.getProperty vs System.getenv](https://www.baeldung.com/java-system-get-property-vs-system-getenv)\n\n","n":0.069}}},{"i":144,"$":{"0":{"v":"Memory","n":1},"1":{"v":"\nJRE's memory is segregated into the below parts:\n\n## Class (Method) Area\n\nStores class level data of every class such as the runtime constant pool, field and method data, the code for methods.\n\n## Heap Space\n\nJava's [[os.memory.ram.user.heap]] implementation.\n\nUsed to allocate memory to objects at run time\n\n### Program Counter Register\n\n- Stores address of currently executing instruction.\n\n    Example: Points to the first line at the start of the program execution\n\n- Also stores address of threads reponsible for executing current instruction\n- Size very small\n- No effect of Java apps on PC register memory or its content\n\n## Stack\n\nJava's implementation of [[os.memory.ram.user.stack]].\n\n- Each thread has a private JVM stack created at same time as thread\n  - Used to store data and partial results which will be needed while returning value for method and performing dynamic linking\n- Stores [[os.memory.ram.user.stack.frame]]s\n- References to objects stored here\n\n### Stack Frame\n\n- A new frame is created each time at every invocation of the method.\n- Contains all the data for one function call - parameters, return address and its local address\n- Stack frame destroyed when method execution completes\n\n## Native Method Stack\n\n- Implemented using languages other than Java\n- New thread created → Memory allocated in this area\n- Size can be fixed or dynamic\n\n## References\n\n- [How references are stored in Java](https://stackoverflow.com/questions/61654407/how-references-are-stored-in-java)\n- More about layout of java objects — [Java Objects Inside Out](https://shipilev.net/jvm/objects-inside-out/)\n- [Compressed OOPs](https://wiki.openjdk.java.net/display/HotSpot/CompressedOops)","n":0.068}}},{"i":145,"$":{"0":{"v":"String","n":1},"1":{"v":"\n## String Constant Pool\n\nSpecial memory area in which string literals are stored\n\n\n## String Initialization using literals\n\nCreating a String literal → [[lang.java.jre.jvm]] checks the String Constant Pool.\n  \n- Exists => Points to the same 'literal'\n- Doesn't Exist => New instance created\n\n## String Initialization using new\n\n```java\nString str = new String(); //null\nString str = new String(\"Kya challa?\")\n```\n\nNew object created irrespective of whether the literal already exists or not\n","n":0.124}}},{"i":146,"$":{"0":{"v":"Static members","n":0.707},"1":{"v":"\nStatic variables are not garbage collected until class is loaded in the memory.\n\nStatic variables are referenced by Class objects (❗not class objects) which are referenced by ClassLoaders. So static variables can't be elected for garbage collection while the class is loaded. They can be collected when the respective class loader is itself collected.","n":0.137}}},{"i":147,"$":{"0":{"v":"Objects","n":1},"1":{"v":"\n## How is object stored in memory?\n\n- The actual data/structure that is stored on the heap starts with what's commonly called object header.\n- Header contains — a (compressed) class pointer\n- Class pointer —> an internal data structure\n- Internal data structure — defines layout of the class\n- Layout of class — stored in a separate memory area called Metaspace (or Compressed Class space if Compressed OOPs are used).\n- The pointer can be 4 or 8 bytes, depending on the architecture - even on 64-bit systems, it's usually 4 bytes due to the Compressed OOPs optimization.\n\n## Reachable Objects\n\nAn object is called reachable if it is reachable from a [[lang.java.jre.memory.objects.root]].\n\nObjects which are directly or indirectly reachable from some other objects.\n\nFor example,\n\n- P -> O\n- P -> Q -> O\n\nO is reachable from P in both cases.\n\n## Root Objects\n\nAn object is a root object if it is referenced by:\n\n- A parameter on a call [[stack frame|lang.java.jre.memory#stack-frame]]\n- A local variable on the call [[stack frame|lang.java.jre.memory#stack-frame]]\n- A [[paradigm.oo.components.modifiers.static.variable]] in class\n- Others like [[lang.java.jre.jvm.class loader]] or [[lang.java.lib.jni]] references.\n\n## Lifecycle\n\n```java\nBox smallBox;\n```\n\nUnlike C++, the above statement won’t create an object. It will just create a reference variable. The reference variable has to be given an object.\n\n```java\nBox smallBox= new Box();\n```\n\nNow `smallBox` contains address of an object of Box class. That is, it points to the object. However, the object itself has no name.\n\n- Memory is allocated on the [[heap|lang.java.jre.memory#heap-space]] and a reference for that object is returned which is stored in [[stack|lang.java.jre.memory#stack]].","n":0.064}}},{"i":148,"$":{"0":{"v":"Methods","n":1},"1":{"v":"\n- Private JVM Stack in [[stack|lang.java.jre.memory#stack]] memory is created\n- New frame is created and stored in the stack\n- [[lang.java.jre.memory.methods.arguments]]\n- Frame destroyed when method invocation completes\n\n    A new one will be created again when the method is invoked.\n\n## How are arguments passed in Java?\n\n- Why is Java always 'pass by value'?\n    \n    Whenever a method is invoked in Java, it is allotted its own stack space. Regardless of the original variable type, each time a method is invoked, a copy for each argument is created in the stack memory and the copy version is passed to the method. Thus, always **pass by value.**\n    \n- Passing Primitive Arguments\n    \n    Consider two variables, x and y , of primitive types and thus stored inside the stack memory. when calling a function, two copies are created inside the stack memory (let's say w and z) and are then passed to the method. hence, the original variables are not being sent to the method and any modification inside the method flow is affecting only the copies.\n    \n    ![Primitive args](/assets/images/2024-04-21-22-31-37.png)\n    \n- Passing [[lang.java.lib.classes.wrappers]]/[[lang.java.lib.string]] Arguments\n    \n    Wrappers are stored inside the heap memory with a corresponding reference inside the stack memory. When calling a function, copy for each reference is created inside the stack memory, and the copies are passed to the method. Any change to the reference inside the method is actually changing the reference of the copies and not the original references.\n    \n    If you change the value of wrapper objects inside the method like this: x += 2, the change is not reflected outside the method, since wrapper objects are immutable. they create a new instance each time their state is modified. String objects work similarly to wrappers, so the above rules apply also on strings.\n    \n    ![Wrapper/string args](/assets/images/2024-04-21-22-29-04.png)\n\n- Passing [[Collection|lang.java.lib.collection]]/[[lang.java.lib.classes.object]] Arguments\n    \n    When defining any collection or object in java, a reference is created inside the stack that points to multiple objects inside the heap memory. when calling a function, a copy of the reference is created and passed to the method. the actual object data is referenced by two references, and any change done by one reference is reflected in the other.\n    \n    ![Collection/object args](/assets/images/2024-04-21-22-29-43.png)","n":0.052}}},{"i":149,"$":{"0":{"v":"Class","n":1},"1":{"v":"\n  - The [[lang.java.jre.jvm.class loader]] loads the class -> [[execution.lifecycle.build]] process.\n  - The constants, static components, method code etc. is loaded in the [[lang.java.jre.memory.stack.class area]].","n":0.2}}},{"i":150,"$":{"0":{"v":"Array","n":1},"1":{"v":"\n- Single-dimensional arrays\n\n    A contiguous space is allocated in heap and a reference is returned (similar to new object).\n    ![array object in java](/assets/images/2024-04-21-22-34-45.png)\n\n- Two-dimensional arrays\n  - They don't really exist.\n  - 2D arrays are just array of arrays.\n  - Multi-dimensional arrays go by the same rule.","n":0.147}}},{"i":151,"$":{"0":{"v":"JVM","n":1},"1":{"v":"\n\n# Java Virtual Machine\n\nJVM (Interpreter) is responsible to execute the program within JRE.\n","n":0.277}}},{"i":152,"$":{"0":{"v":"Garbage collector","n":0.707},"1":{"v":"\n[[lang.java.jre.jvm]] component responsible for [[dev.memory management.implicit.gc]] of objects.\n","n":0.354}}},{"i":153,"$":{"0":{"v":"Throughput Collector","n":0.707},"1":{"v":"\n- Similar to [[lang.java.jre.jvm.gc.serial]] but uses multiple threads for garbage collection.\n- Also freezes application threads during collection.\n- Default in [[lang.java.v.8]].","n":0.224}}},{"i":154,"$":{"0":{"v":"Serial Garbage Collector","n":0.577},"1":{"v":"\n- Operation\n\n    Stops the application and runs a single thread for garbage collection.\n\n- Used when\n\n    Suitable for small applications.","n":0.229}}},{"i":155,"$":{"0":{"v":"Generational","n":1},"1":{"v":"\nGarbage collection is performed on objects on basis of their age in the program.\n\n### Heap Memory Division\n\nGenerational garbage collector divides the heap memory into different generations based on the lifespan of objects.\n\nHeap is divided into:\n\n- Young Generation (Eden Space)\n- Old Generation\n- Survivor space \n    - 1\n    - 2\n\n#### Garbage collection life cycle\n\n- Objects are stored in Eden space, when they are created at first.\n- 1st cycle - When Eden Space gets full\n    - Minor GC runs\n    - Objects moved to survivor space 1\n- Susequent cycles - Eden space gets full again\n    - Objects moved to survivor space 2\n      from both Eden space and survivor 1\n\n💡 Objects keep moving between both survivor spaces in cycles\n\nObjects older than Max tenure threshold (a certain threshold for number of cycles) are moved to old generation space.\n\n- When old generation space is about to be full\n- major GC runs → *time consuming and might pause the application*","n":0.081}}},{"i":156,"$":{"0":{"v":"G1","n":1},"1":{"v":"\n# Garbage First \n\nIntroduced in [[lang.java.v.9]] to [[lang.java.jre.jvm.gc.cms]]\n\n- Operation\n    - No concept of young and old generations\n    - Divides Heap into several memory spaces\n    - Collects from region which has most garbage → Garbage first (G1)\n- Advantages\n    - GC pauses can be tuned\n    - Small pauses\n    - Parallelism and concurrency together\n    - Better heap utilisation","n":0.135}}},{"i":157,"$":{"0":{"v":"CMS","n":1},"1":{"v":"\n# Concurrent Mark and Sweep\n\n\n- Operation\nRuns a GC thread alongside the application.\n\n- Used when:\n    - More memory available\n    - High number of CPUs or cores present\n    - App demands short pauses\n\n    (Used in most fintech apps)\n\n(CMS - Concurrent Mark Sweep)","n":0.158}}},{"i":158,"$":{"0":{"v":"Class Loader","n":0.707},"1":{"v":"\n- Not a type of memory\n- Subsystem of [[lang.java.jre.jvm]]\n- Used to load class files\n- Responsible for three activities\n  - Loading\n  - Linking\n  - Initialization\n","n":0.204}}},{"i":159,"$":{"0":{"v":"Exception","n":1},"1":{"v":"\n## [[dev.issues.exception.types.checked]]\n\nClasses which directly inherit Throwable except RuntimeExceptions and Errors.\n\n## [[dev.issues.exception.types.unchecked]]\n\nClasses which inherit RuntimeExceptions\n\n\n## Handling\n\n### Catching\n\n- `try`\n    - Used to specify a block of code which can throw an exception.\n    - Must be followed by a catch or finally.\n    - Can't be used alone\n\n- `catch`\n    - Block used to handle the error.\n    - Must be preceded by try\n    - Can't be used alone\n\n### Always execute\n\n- `finally`\n\nContains the code which must be executed irrespective of whether an exception is handled or not\n\n### Throwing\n\n- `throw`\n\nUsed to throw an exception\n\n- `throws`\n    - Used to declare exceptions\n    - Doesn't throw error\n    - Specifies that an exception may occur in a method\n    - Used with method signature\n\n## Creating Custom Exceptions\n\n- How to create?\n\n    Create a class WhateverException which extends Exception\n\n- How to return your custom message while throwing exception?\n\n    Pass the message you want to show as a String to the Exception (or super).\n\n- Are custom exceptions checked or unchecked?\n\n    If you want it to be checked, extend Exception. If you want it to be unchecked, extend RuntimeException.\n\n## Propagation\n\n### Exceptions in main() method\n\n- What happens when main() throws an error?\n\n    Java Runtime terminates the program and print the exception message and stack trace in system console.\n\n- Can *throws* keyword be used with main()?\n\n    Yes, it can be used. Although, there's no reason for a `main` method to `throw` anything. Since, any error will handled by JVM in the same way.\n\n## Exceptions raised in common scenarios\n\n\nScenario | Exception | \n----------------|-----------|\n Divide by zero | `ArithmeticException` |\n Operation on Null Pointer   | `NullPointerException` |\n Operating on incorrect/non-existant index    | `ArrayIndexOutOfBoundsException` | \n| Wrong formatting of any value. For example, converting a String variable with characters into digit. |`NumberFormatException`|\n","n":0.06}}},{"i":160,"$":{"0":{"v":"Ai","n":1}}},{"i":161,"$":{"0":{"v":"Ml","n":1}}},{"i":162,"$":{"0":{"v":"Machine Learning Algorithms","n":0.577},"1":{"v":"\n\nAlgorithms which can learn from data and respond accordingly.\n\nHow it works?\n\n- Huge datasets\n- Find pattern in data\n- Generalized pattern found\n- Algorithm makes intelligent decisions based on the patterns it has recognized.\n","n":0.18}}},{"i":163,"$":{"0":{"v":"Gen","n":1}}},{"i":164,"$":{"0":{"v":"Prompting","n":1},"1":{"v":"\n\n## Training the model within prompt \n\n### Zero-shot prompting\n\n- When you provide a prompt which is not part of the training data.\n- Basically, you are not giving any example to help it out.\n- Even if the model has not seen the prompt before, it can generate a good-enough output close to the desirable outcome you expected.\n\n    Which is why LLMs are so useful for performing tasks without needing retraining.\n\n### One-shot Prompting\n\n- When you provide **one example** within the prompt to guide the model\n- You are basically training the model shortly and nudging it towards the expected behavior\n\n### Few-shot prompting\n\n- When you provide **multiple examples** in your prompt\n- This better demonstrates the expected outcome in certain scenarios\n- The model can generalize from the examples, and give more precise output.\n\n\nFor example, \n![[ai.gen.prompting.intent classification#prompt]]\n\n\n## Nudges\n\nYou can nudge the LLM towards certain behavior by injecting some sentences into the prompt. \n\nIts not entirely understood yet, as to why these sentences influence LLM behavior, but these nudges possibly direct LLMs towards certain kinds of training data.\n\nFor example, if you use a nudge for accuracy, it might guide LLM towards dataset which prioritizes thoroughness and precision.\n\n### Accuracy\n\nNudge the LLM to be more accurate by including the following phrases in the prompt:\n\n\n* ```prompt\n    Correcness is a life or death situation.\n    ```\n\n\n* ```prompt\n    Take a deep breath and {{action}}\n    ```\n\n    For example,\n\n    ```prompt\n    Take a deep breath and classify the following utterance. \n    ```\n\nThi\n\n## References\n\n[LLM Intent Classification Feature Launch - Understanding Prompt Wrapper](https://youtu.be/47HgM-TmFBc?si=KY-iAgdsfRZ3tWZo&t=146)\n- [Google’s NEW Prompting Guide is Incredible! - YouTube - Jeff Su](https://youtu.be/o64Mv-ArFDI?si=FNLomn_oZtD2mMV1)\n- [Gemini for Google Workspace - Prompting Guide 101 - A quick start handbook for effective prompts](https://inthecloud.withgoogle.com/gemini-for-google-workspace-prompt-guide/dl-cd.html)","n":0.061}}},{"i":165,"$":{"0":{"v":"Intent Classification","n":0.707},"1":{"v":"\nLLM can be used as a reasoning engine, to identify intent of a query by a user.\n\n## Prompt\n\n```prompt\nYou are an intent classification system. Correctness is a life or death situation.\n\nWe provide you with the actions and their descriptions:\nd. When the user asks for a warm drink. a: WARM_DRINK\nd. When the user asks for something else. a: NONE\nd: When the user asks for a cold drink. a: COLD_DRINK\n\nYou are given an utterance and you have to classify it into an action. Only respond with the action class.\nNow take a deep breath and classify the following utterances.\nu: I want a warm hot chocolate. a: WARM_DRINK\n\nWe provide you with the actions and their descriptions.\nd:{{descriptions}} a: {{actions}}\n\nYou are given an utterance and you have to classify it into an action. Only respond with the action class.\nNow take a deep breath and classify the following utterances.\n{{utterances}}\n```\n\n## References\n\n[LLM Intent Classification Feature Launch - Voiceflow](https://youtu.be/47HgM-TmFBc?si=1LS-h79EPdH6ZTPY)\n","n":0.082}}},{"i":166,"$":{"0":{"v":"Type Theory","n":0.707}}},{"i":167,"$":{"0":{"v":"Data Types","n":0.707}}},{"i":168,"$":{"0":{"v":"Union Types","n":0.707},"1":{"v":"\nCombines several types into one.\n\nRepresents value that can be of any of the consituents types.\n\nExample:\n\n```ts\nlet id: number | string\n```\n\n`id` can be either `number` or `string`.","n":0.2}}},{"i":169,"$":{"0":{"v":"Literal Type","n":0.707},"1":{"v":"\nA literal type is a value, enforced as a type.\n\nThat means, a variable of literal type can only have value of the [[dev.lingo.literal]] and nothing else.\n\nYou can say it is a subtype of a primitive data type. While primitive data types allow a range of values, literal narrows it down to specific predifined value (values in some cases).\n\nFor example:\n\n```ts\nlet iamlit: \"Hello\"; //\"Hello\" is literal type\n\niamlit = \"Hello\"; //OK\niamlit = \"Bounjor\" //Error\n```\nHere `iamlit` can only have value of the literal.","n":0.113}}},{"i":170,"$":{"0":{"v":"Intersection","n":1},"1":{"v":"\nCombines several types into one.\n\nRepresents value that can be both of the contituents types.\n\n","n":0.267}}},{"i":171,"$":{"0":{"v":"Enum (Enumerated Types)","n":0.577},"1":{"v":"\n\nData type consisting of a set of named values called elements, members, enumeral, or enumerators of the type. The enumerator names are usually identifiers that behave as constants in the language.\n\n## Usage\n\nWhere fixed set of constants or ranges are required\n\n## Examples\n\n- the four suits in a deck of playing   cards may be four enumerators named *Club, Diamond, Heart, and Spade*, belonging to an enumerated type named *suit*. If a variable V is declared having suit as its data type, one can assign any of those four values to it.\n- range of phones/laptops, colors, seasons, days of week.\n\n## Isn't it [[type theory.data types.literal]]?\n\nWhile enums, like literal limit the set of values possible for a variable, they are not literal.\n\nEnums group together [[type theory.data types.literal]]s and give them semantic meaning.\n","n":0.088}}},{"i":172,"$":{"0":{"v":"Variance","n":1},"1":{"v":"\n\nVariance defines how the type relations of complex types will vary or hold in their components( entities and components in programming languages like enumerables (enums), functions, arrays, lists etc).\n\nWe know how [[type theory.substitutability]] works in case of objects. This kind of replacement can also be done with the components of these types. This is called variance.\n\n- When objects are replaced — substitutability\n- When components are replaced — variance\n\nFor example, a type Cat and Animal, where Animal is parent (or whatever) of Cat. Variance defines how the subtypes of Cat and subtypes of Animal will either hold or deviate from this relation.\n\nThe relation is:\n\n- **variant** if the relation is somehow carried on to the components or children, either holding the relation or reversing the relation.\n    - **covariant** if it preserves the ordering of types.\n    - **contravariant** if it reverses this order. \n    - **bivariant** if both of the above apply\n- **invariant** or **nonvariant** if the relation is not carried on to the components or children.\n\n## Thoughts on deciding variance\n\nWhile designing any type system, variance is considered by the designer. \n- Contravariance is usually considered unintuitive by programmers. This can lead to complex typing rules.\n- If the type system is variant, the type system is considered to be well-typed.\n- Sometimes the designer will choose to keep it invariant to keep the type system simple. But this could voilate type-safety.\n ","n":0.066}}},{"i":173,"$":{"0":{"v":"Subtyping","n":1},"1":{"v":"\n\n\nA set of classes confirming to a certain interface signature which can override certain parts of the signature with their own implementations.\n\n## References\n\n- [Difference between subtypes and subclasses - Princeton](https://www.cs.princeton.edu/courses/archive/fall98/cs441/mainus/node12.html)\n- [Prefer composition over inheritance - StackOverflow](https://stackoverflow.com/a/32557773)\n","n":0.167}}},{"i":174,"$":{"0":{"v":"Substitutability","n":1},"1":{"v":"\n\n\nWe can replace an object of Animal type with object of Cat type.\n\nMore formally — [[arch.design.oo.principles.solid.liskov]].\n","n":0.25}}},{"i":175,"$":{"0":{"v":"Subclassing","n":1},"1":{"v":"\n\nParent's code can be shared by subclasses. ","n":0.378}}},{"i":176,"$":{"0":{"v":"Casting","n":1},"1":{"v":"\n\nCasting is the conversion of variable/object from one data type to another.\n\nDepending upon the entity it is being performed on or the way it is being performed it can be classified as follows:\n\n","n":0.174}}},{"i":177,"$":{"0":{"v":"Primitive","n":1},"1":{"v":"\n\nWhen conversion is performed on primitive data types.\n","n":0.354}}},{"i":178,"$":{"0":{"v":"Widening Conversion","n":0.707},"1":{"v":"\n\n\nWhen we convert from a smaller/simpler data type to a larger one.\n\nGenerally, [[type theory.casting.implicit]].","n":0.267}}},{"i":179,"$":{"0":{"v":"Narrowing Conversion","n":0.707},"1":{"v":"\n\nConversion from larger data type to smaller.\n\nGenerally, [[type theory.casting.explicit]].\n","n":0.333}}},{"i":180,"$":{"0":{"v":"Object Type Casting","n":0.577},"1":{"v":"\n\n\n- Similarity with primitive conversion\n\n    Converting from one type to another\n\n- Difference\n\n    Primitive type variables store values. So when we convert from a larger to type to smaller type, we might end up loosing information.\n\n    Reference variables on the other hand do not contain the object itself, but its reference. So when we convert types of objects, we're not changing the object, but we're just changing the label on the object, expanding or narrowing the opportunities to work with.\n\n    Upcasting narrows the list of methods and properties available to this object and down casting can extend it.","n":0.102}}},{"i":181,"$":{"0":{"v":"Upcasting","n":1},"1":{"v":"\nCasting from subclass to superclass\n\n## Syntax\n\n- Generally, [[type theory.casting.implicit]]. Why?\n  \n  => Compiler knows that *Cat* is an *Animal.* [[arch.design.oo.principles.solid.liskov]]\n\n## What upcasting gives us?\n\n- [[paradigm.oo.principles.polymorphism]]\n\n    Instead of using different methods for a common functionality in each of the sub classes, we can have a common method in the superclass for that functionality and all subclass objects will be casted implicitly.\n\n    Example - a feed(Animal animal) function to which we can pass objects of Cat and Dog classes → feed(cat); feed(dog);\n\n- [[paradigm.oo.principles.polymorphism.overriding]]\n\n    When an object is upcasted, it still can call overridden methods from its original class.\n\n    For example, if Animal class has an eat() method and subclasses Cat and Dog override it.\n\n    eat(animal) will call the methods from either the class Cat or Dog, whichever it was before upcasting.\n\n    [[paradigm.oo.principles.polymorphism.runtime]] is a result of Upcasting.\n","n":0.086}}},{"i":182,"$":{"0":{"v":"Class Cast Exception","n":0.577},"1":{"v":"\n\nAn exception occurs when a class which is not the superclass or which was not originally the superclass is casted.\n\nFor example, if Dog is casted to Cat. Or if Dog is upcasted to Animal and we try casting that Animal object to Cat.\n\nIt is advised to determine if the class you're downcasting is an instance of the class you're downcasting to.\n","n":0.128}}},{"i":183,"$":{"0":{"v":"Downcasting","n":1},"1":{"v":"\n\nCasting from superclass to subclass\n\n## Syntax\n\nGenerally, [[type theory.casting.explicit]] and same as [[type theory.casting.primitive.narrowing]] of primitive types.\n\nBeware of [[type theory.casting.object.exception]].\n\n\n","n":0.229}}},{"i":184,"$":{"0":{"v":"Implicit Casting","n":0.707},"1":{"v":"\n\n\nWhen you don't need to specify that you need some variable/object to be converted. The language takes care of it automatically.\n\n[[type theory.casting.primitive.widening]] and [[type theory.casting.object.upcasting]].","n":0.2}}},{"i":185,"$":{"0":{"v":"Explicit Casting","n":0.707},"1":{"v":"\n\nWhen you have to specify that you're converting the variable/object intentionally and you don't have any problem with loosing information in your variable or making your object more specific.\n\n[[type theory.casting.primitive.narrowing]] and [[type theory.casting.object.downcasting]].\n","n":0.174}}},{"i":186,"$":{"0":{"v":"Tools","n":1}}},{"i":187,"$":{"0":{"v":"Editors","n":1}}},{"i":188,"$":{"0":{"v":"Vim","n":1},"1":{"v":"\n\n- [Vim Motions for absolute beginners](https://youtu.be/lWTzqPfy1gE?si=DlXPz1bUQpinyeQE)","n":0.408}}},{"i":189,"$":{"0":{"v":"Version Control","n":0.707},"1":{"v":"\n\n- Software designed to record changes made to a file over time\n- Gives the ability to revert back to a previous file version or project version\n- You can see why and who made what changes to a file\n- Any file — not just source code files\n","n":0.147}}},{"i":190,"$":{"0":{"v":"Tags","n":1}}},{"i":191,"$":{"0":{"v":"Optimization","n":1}}},{"i":192,"$":{"0":{"v":"Performance Optimization","n":0.707}}},{"i":193,"$":{"0":{"v":"surprises","n":1},"1":{"v":"\nWhen a piece of tech yields unexpected results.\n\nMaybe it operates on something, it isn't supposed to or has an unexpected dependency.\n\nUsually occurs due to #magic.","n":0.2}}},{"i":194,"$":{"0":{"v":"Read Later","n":0.707}}},{"i":195,"$":{"0":{"v":"not allowed by default","n":0.5}}},{"i":196,"$":{"0":{"v":"Magic","n":1},"1":{"v":"\nResult of too much [[paradigm.oo.principles.abstraction]]. If you don't have a high-level understanding of a black box, its output may seem like magic. \n\n> Avoid leaky abstractions as a designer.\n\n> Avoid black boxes as a consumer.\n\nWhich means you should at least have some high-level knowhow of what's going on inside any system in order to use it => Grey boxes.\n\nOn the other hand, while designing a system, design it in such a way that there are no #surprisess. If that is the case, users wouldn't need to know your implementation details and you wouldn't have [[paradigm.oo.principles.abstraction.leaky]]\n\nIf you have to completely know the system in order to use it, then it doesn't make sense.","n":0.094}}},{"i":197,"$":{"0":{"v":"Interview Question","n":0.707}}},{"i":198,"$":{"0":{"v":"Instance Of","n":0.707},"1":{"v":"\n\nBeing an instance of something means to be the [[execution.lifecycle.runtime]] version of a [[execution.lifecycle.build]]/ [[execution.lifecycle.design]] template.\n\nThe instance is therefore built keeping the build time version as a template and it is what will actually get executed or be used in direct application.\n","n":0.154}}},{"i":199,"$":{"0":{"v":"Course","n":1}}},{"i":200,"$":{"0":{"v":"Cheatsheet","n":1}}},{"i":201,"$":{"0":{"v":"Std","n":1}}},{"i":202,"$":{"0":{"v":"Web","n":1}}},{"i":203,"$":{"0":{"v":"JSON","n":1},"1":{"v":"\n\nJSON is most favoured message format because:\n\n- Can be read by any programming language (despite the name)\n- Human and machine readable\n- Lightweight\n\n\n## References\n\n\n[RFC 8259 - The JavaScript Object Notation (JSON) Data Interchange Format](https://datatracker.ietf.org/doc/html/rfc8259)","n":0.174}}},{"i":204,"$":{"0":{"v":"JSON Schema","n":0.707},"1":{"v":"\nSchema language for defining JSON structure and constraints.\n\n## Alternatives\n\n- JSON Type Def\n- [Similar technologies - JSON Schema Org](https://json-schema.org/overview/similar-technologies)\n\n## \n\n[How to define enum with description for each constant](https://stackoverflow.com/questions/64233370/in-json-schema-how-to-define-an-enum-with-description-of-each-elements-in-the-e)\n\n## References\n\n- [What is JSON Schema? - Postman Blog](https://blog.postman.com/what-is-json-schema/)\n- [JSON Schema](https://json-schema.org/)\n- [JSON Type Def - Docs](https://jsontypedef.com/docs/)\n- [RFC-8927 JSON Type Definition](https://datatracker.ietf.org/doc/rfc8927/)\n- [Choosing Schema Language](https://ajv.js.org/guide/schema-language.html)","n":0.143}}},{"i":205,"$":{"0":{"v":"HTTP","n":1},"1":{"v":"\n## Methods\n\n- `GET` (Read): Used to retrieve data.\n- `POST` (Create): To send data for some processing\n- `PATCH` (Update/modify): To modify a record with only the updated part. \n- `PUT` (Update/replace): To create or update.\n- `DELETE`\n- `HEAD`: Like GET but just to get response header (for metadata)\n- `CONNECT`: Starts two-way communications with the requested resource. It can be used to open a TCP/IP tunnel.\n- `OPTIONS`: To check what HTTP methods are supported by the target system\n- `TRACE`: The TRACE method requests that the target resource transfers the received request in the response body. That way a client can see what (if any) changes or additions have been made by intermediaries.\n\n\n### Mandatory Methods\n\nAll general-purpose web servers are required to implement at least the `GET` and `HEAD` methods, and all other methods are considered optional by the specification.\n\n\n## Response Codes\n\n1. Informational responses (`100`–`199`)\n2. Successful responses (`200`–`299`)\n3. Redirects (`300`–`399`)\n4. Client errors (`400`–`499`)\n5. Server errors (`500`–`599`)\n\n### Common Response codes\n\n- 200 OK\n- 400 Bad Request\n- 401 Unauthorized\n- 403 Forbidden\n- 404 Not found\n- 405 Method Not allowed\n- 408 Request Timeout\n- 500 Internal Server error\n- 502 Bad gateway\n\n\n## References\n\n[When should one use CONNECT and GET HTTP methods at HTTP Proxy Server? - StackOverflow](https://stackoverflow.com/questions/11697943/when-should-one-use-connect-and-get-http-methods-at-http-proxy-server)\n","n":0.072}}},{"i":206,"$":{"0":{"v":"CLDF","n":1},"1":{"v":"\n## Cross-linguistic data formats\n\nCLDF is a specification describing how to store cross-linguistic data (i.e. data about (many) languages) in a way that maximizes reusability. \n- pycldf implements this specification, providing tools to manipulate and validate CLDF datasets, based on csvw which implements the underlying CSVW spec.\n\n## References\n\n- [Cross-Linguistic Data Formats](https://cldf.clld.org/publications.html)\n- [CLDF Github Org](https://github.com/cldf)\n- [CLDD - Cross Linked Linguistic Data](https://clld.org/)","n":0.13}}},{"i":207,"$":{"0":{"v":"Regex","n":1},"1":{"v":"\nUsed for pattern matching in string. Common use cases include text validation and text search.\n\nRegexes are enclosed within `/ /` (this document doesn't use these enclosings in most regexes to keep it clean).\n\n## Some common ones \n\n- `[abc]` - a, b or c\n- `[^abc]` -  any character except a, b, c\n- `[a-z]` - a to z\n- `[A-Z]` - A to Z\n- `[a-zA-Z]` - a to z, A to Z\n- `[0-9]` - 0 to 9\n\n## Flags\n\n- `g`\n\n    `/a/` will only match the first occurence of a.\n    `/a/g` will match all occurences of a throughout the string.\n\n## Quantifiers\n\n- `[ ]?` - occurs 0 or 1 times\n- `[ ]+` - occurs 1 or more times\n- `[ ]*` - occurs 0 or more times\n- `[ ]{n}` - occurs n times\n- `[ ]{n,}` - occurs n or more times\n- `[ ]{y,z}` - occurs at least y times but less than z times\n\n## Metacharacters\n\n- `\\d` - all digits ≍ `[0-9]`\n- `\\w` - all \"word\" (alphanumeric) characters ≍  `[a-zA-Z0-9]`\n- `\\D` - everything except digits ≍ `[^0-9]`\n- `\\W` - everything except alphanumeric characters ≍ `[^a-z]`\n- `.` - any character except a newline\n\n## Escaping\n\nUse `\\` to replace any special character.\n\n\n## Logical Operators\n\n- `^` - Negation\n- `|` - Logical OR\n- `()` - to group your logic\n\n\n## Standards\n\nRegular expressions (regex) are not defined by a single, universally accepted standard like an RFC. However, there are efforts to establish some level of consistency across different regex implementations. \n\nSome regex standards are:\n\n- POSIX Basic Regular Expressions (BRE)\n- Extended Regular Expressions (ERE)\n- PCRE (Perl Compatible Regular Expressions)\n- I-Regexp (RFC 9485) \n\n\n## References\n\n- [Regular expression syntax cheat sheet](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Cheatsheet)\n\n- Good concise videos\n    - [REGEX (REGULAR EXPRESSIONS) WITH EXAMPLES IN DETAIL | Regex Tutorial](https://www.youtube.com/watch?v=9RksQ5YT7FM&ab_channel=CrackConcepts)\n    - [Regular Expressions (RegEx) in 100 Seconds - Fireship - YouTube](https://www.youtube.com/watch?v=sXQxhojSdZM&ab_channel=Fireship)","n":0.059}}},{"i":208,"$":{"0":{"v":"Identifiers","n":1},"1":{"v":"\n\n## References\n\n- [RFC 9562 - Universally Unique IDentifiers (UUIDs)](https://www.rfc-editor.org/rfc/rfc9562)\n- [Cuid2](https://github.com/paralleldrive/cuid2)\n- [The Problem with Using a UUID Primary Key in MySQL - Planetscale Engineering Blog](https://planetscale.com/blog/the-problem-with-using-a-uuid-primary-key-in-mysql)","n":0.204}}},{"i":209,"$":{"0":{"v":"Philosophy","n":1}}},{"i":210,"$":{"0":{"v":"Bad Code Can Lead to Good Code","n":0.378},"1":{"v":"\n\nBad code can sometime be used in certain scenarios. You can avoid principles just because [[philosophy.a principle in principle]].\n\nIt stays in your code as a marker for you to remind you to change it later. Will it be changed ever? Only time can tell. So bad code also might live a good life - as long as it works.\n\nIts a [[dev.code smell]] and that's good because it keeps you looking for abstraction that you have missed. But meanwhile, you can still provide value to your stakeholder.\n\n>I imagine rules like this one defining a landscape, where maintainable code lives in the valleys. As you add new behaviour, it's like rain landing on your code. Initially you put it wherever it lands.. then you refactor to allow the forces of good design to push the behaviour around until it all ends up in the valleys.\n\n## References\n\n[Nigel Thorne's answer to How to Unit Test Abstract Classes?](https://stackoverflow.com/a/2947823/14318926)\n\n","n":0.081}}},{"i":211,"$":{"0":{"v":"a principle is just in principle","n":0.408},"1":{"v":"\n\nA principle is just that - a principle. It can nudge you towards the correct direction. But it may or may not apply to your situation. Only you have the actual and close understanding of your situation and what's going on.\n","n":0.156}}},{"i":212,"$":{"0":{"v":"Dev","n":1}}},{"i":213,"$":{"0":{"v":"Tools","n":1}}},{"i":214,"$":{"0":{"v":"Build","n":1}}},{"i":215,"$":{"0":{"v":"Transformation","n":1}}},{"i":216,"$":{"0":{"v":"Transpiler","n":1},"1":{"v":"\nConverts a high-level language to another high-level language (usually a dialect of the source language).","n":0.258}}},{"i":217,"$":{"0":{"v":"Compiler","n":1},"1":{"v":"\nConverts High-level languages to a lower-level language.","n":0.378}}},{"i":218,"$":{"0":{"v":"Bundler","n":1},"1":{"v":"\nAggregate various files and modules into single or fewer files optimizing load times and resource management, especially for web applications.","n":0.224}}},{"i":219,"$":{"0":{"v":"Clean Code","n":0.707}}},{"i":220,"$":{"0":{"v":"Naming","n":1}}},{"i":221,"$":{"0":{"v":"Class Names","n":0.707},"1":{"v":"\n\n#Cheatsheet\n\n> Don't get naming paralysis. Yes, names are very important but they're not important enough to waste huge amounts of time on. If you can't think up a good name in 10 minutes, move on.\n\n- Coordinator\n- Builder\n- Writer\n- Reader\n- Handler\n- Container\n- Protocol\n- Target\n- Converter\n- Controller\n- View\n- Factory\n- Entity\n- Bucket\n- Client\n\n## References\n\n- [Naming Classes - How to avoid calling everything a \"WhatEver Manager\"? - StackOverflow](https://stackoverflow.com/questions/1866794/naming-classes-how-to-avoid-calling-everything-a-whatevermanager)\n- [Naming Classes — Why It Matters, and How to Do It Well - PS PDF KIT blog](https://pspdfkit.com/blog/2018/naming-classes-why-it-matters-how-to-do-it-well/)\n- [Naming Conventions - Oracle](https://www.oracle.com/java/technologies/javase/codeconventions-namingconventions.html#:~:text=Class%20names%20should%20be%20nouns,such%20as%20URL%20or%20HTML).)\n","n":0.108}}},{"i":222,"$":{"0":{"v":"Issues","n":1}}},{"i":223,"$":{"0":{"v":"Failure","n":1},"1":{"v":"\n\nIssue in the end product (likely discovered by end-customer).\n","n":0.333}}},{"i":224,"$":{"0":{"v":"Exceptions","n":1},"1":{"v":"\n- *lit.* An abnormal condition.\n- An event that disrupts the normal flow of the program.\n- An object which is thrown.\n\n## Types\n\n- [[dev.issues.exception.types.checked]]\n- [[dev.issues.exception.types.unchecked]]\n","n":0.209}}},{"i":225,"$":{"0":{"v":"Types","n":1}}},{"i":226,"$":{"0":{"v":"Unchecked Exceptions","n":0.707},"1":{"v":"\nNot checked at compile time - occur at run time.\n\nNo warning if you don't handle or specify the exception\nRuntime error if not handled anywhere.\n","n":0.204}}},{"i":227,"$":{"0":{"v":"Stack Overflow","n":0.707},"1":{"v":"\nOccurs when [[os.memory.ram.spaces.stack]] overflows. ","n":0.5}}},{"i":228,"$":{"0":{"v":"Null Pointer Exception","n":0.577},"1":{"v":"\nOccurs when you try to access an object of a empty or null reference.","n":0.267}}},{"i":229,"$":{"0":{"v":"Class Cast Exception","n":0.577},"1":{"v":"\nAn exception occurs when a class which is not the superclass or which was not originally the superclass is casted.\n\nFor example, if Dog is casted to Cat. Or if Dog is upcasted to Animal and we try casting that Animal object to Cat.\n\nIt is advised to determine if the class you're downcasting is an instance of the class you're downcasting to.","n":0.128}}},{"i":230,"$":{"0":{"v":"Custom Exceptions","n":0.707},"1":{"v":"\nUser Defined Exception.\n\n- Why create custom exceptions?\n\n    To have your own exception and message - relevant to the application\n","n":0.229}}},{"i":231,"$":{"0":{"v":"Checked Exceptions","n":0.707},"1":{"v":"\nChecked at compile time — the ones you get warning for, to declare.\n","n":0.277}}},{"i":232,"$":{"0":{"v":"Exception Propagation","n":0.707},"1":{"v":"\n\nAn exception is first thrown from the top of the stack and if it is not caught, it drops down the call stack to the previous method,If not caught there, the exception again drops down to the previous method, and so on until they are caught or until they reach the very bottom of the call stack.This is called exception propagation.\n\n💡 Rule: By default [[dev.issues.exception.types.unchecked]]s are forwarded in calling chain (propagated).\n\n```java\nclass TestExceptionPropagation{  \n \n  void m(){  \n    int data=50/0;  \n  }  \n  \n void n(){  \n    m();  \n  }  \n  \n void p(){  \n   try{  \n    n();  \n   }catch(Exception e){System.out.println(\"exception handled\");}  \n  }  \n  \n public static void main(String args[]){  \n   TestExceptionPropagation1 obj=new TestExceptionPropagation1();  \n   obj.p();  \n   System.out.println(\"normal flow...\");  \n  }  \n}\n```\n\n```console\nOutput:exception handled\n       normal flow...\n```\n\n💡 Rule: By default, [[dev.issues.exception.types.checked]]s are not forwarded in calling chain (propagated).\n","n":0.086}}},{"i":233,"$":{"0":{"v":"Exception Handling","n":0.707},"1":{"v":"\nMechanism of handling [[dev.issues.exception]]s so that the normal flow of the application can be maintained.\n","n":0.258}}},{"i":234,"$":{"0":{"v":"Exception Declaration","n":0.707},"1":{"v":"\nException declaration is a way of letting the compiler and the programmer know, that a method _can_ throw an exception in certain scenarios. It helps set clear expectations of the code behaviour and also warn the developer in case an possible exception is not caught. \n\nNot all languages support this though. Some languages like Python and JavaScript are more lenient with the exceptions you throw. While some other languages will warn you (like ABAP) or even show an error (like Java) if you raise an exception which you have not declared.","n":0.105}}},{"i":235,"$":{"0":{"v":"Error","n":1},"1":{"v":"\n- Errors are severe issues that typically occur due to serious problems outside the control of the program. They often lead to abnormal program behavior. \n- Errors are irrecoverable.\n\n## Handling\n\n- **Catching**: Generally not appropriate to catch errors. Can't be caught anyway.\n- Then what? - Logging the error and exiting the program is recommended approach.","n":0.136}}},{"i":236,"$":{"0":{"v":"Stack Overflow","n":0.707},"1":{"v":"\nOccurs when [[os.memory.ram.user.stack]] overflows. \n\n## Common Causes\n\n### Infinite Recursion\n\nIf a function calls itself without a proper termination condition, it can lead to an endless loop of function calls, eventually causing a stack overflow.\n\n### Deep Call Stack\n\nA function calling many other functions, or a series of functions calling each other in a long chain, can also exhaust the stack space.\n\n### Large Local Variables\n\nAllocating large data structures as local variables in functions can consume significant stack space.\n\n### Excessive Function Arguments\n\nFunctions with a large number of arguments can increase the stack usage for each call.\n\n\n## Prevention\n\n### Proper Termination Conditions\n\nEnsure recursive functions have conditions that will eventually stop the recursion.\n\n### Limit Recursion Depth\n\nIf recursion is necessary, limit the depth to avoid excessive stack use.\n\n### Optimize Local Variables\n\nUse variables judiciously within functions and consider storing large data structures on the heap instead.\n\n### Review Function Calls\n\nAnalyze the call graph of your program to identify potential deep call stacks or unintended recursion.","n":0.08}}},{"i":237,"$":{"0":{"v":"Out of Memory","n":0.577},"1":{"v":"\n## Common Causes \n\n### Insufficient RAM\n\nWhen your machine doesn’t have enough RAM (Random Access Memory) available, it struggles to process applications, execute programs, or access files. As a result, you encounter the dreaded “out of memory” error.\n\n### Startup Programs\n\nCertain tasks or applications automatically run in the background when you start your system. These are known as startup programs. If these programs consume a significant portion of your system resources (including RAM), you may encounter the “out of memory” error.\n\n### Outdated Hardware\n\nOlder computers with limited resources (such as low RAM or slow processors) can’t handle today’s data or processing demands. Consequently, they may trigger errors like the “out of memory” issue.\n\n### Heavy Tasks\n\nResource-intensive activities like playing demanding PC games, creating 3D models, or editing high-quality videos can exhaust your system’s memory capacity, leading to the error.\n\n### Malware\n\nMalicious software running in the background can consume system memory, leaving little room for intended applications to function. This can result in the “out of memory” error.\n\n### Memory Leaks\n\nWhen [[dev.memory management.leaks]] in [[os.memory.ram.user.heap]] go out of hand.","n":0.076}}},{"i":238,"$":{"0":{"v":"Bug","n":1},"1":{"v":"\n\nBug or defect is a the diversion from the expected behaviour of a program or application. It is caused by mistakes while coding the logic.\n","n":0.2}}},{"i":239,"$":{"0":{"v":"Regression","n":1},"1":{"v":"\n\nA software bug in which a feature that has worked before stops working.\n","n":0.277}}},{"i":240,"$":{"0":{"v":"Bug Lifecycle","n":0.707},"1":{"v":"\n\n## Bug Workflow\n\n```mermaid\nflowchart TD\n    1[1. Execute tests] --> 2[2. Record and submit a bug] \n    2 --> 3[3. Review and assign the bug]\n    3 --> 4[4. Investigate and reproduce the bug]\n    4 --> reproduced([Bug reproduced?])\n    \n    reproduced --Yes--> 5[5. Fix the bug]\n    reproduced --No--> 6[6. Elaborate the bug]\n    6 --> 4    \n\n    5 --> 7[7. Verify the fix]\n    7 --> fixed([Bug fixed])\n\n    fixed --Yes--> 8[8. Close the bug]\n    fixed --No--> 5\n```\n## Bug Life Cycle Stages\n\n1. New/Open\n2. Deferred/Postponed\n3. Assigned\n4. In Progress\n5. Fixed\n6. Pending Retest\n7. Verified/Closed\n8. Reopened\n\nThese stages can vary according to the organization and team.\n\n## References\n\n[What is Bug Life Cycle In Software Testing? Best Tools For Bug Management](https://katalon.com/resources-center/blog/bug-defect-life-cycle)\n","n":0.097}}},{"i":241,"$":{"0":{"v":"Tests","n":1},"1":{"v":"\nTests ensure quality in delivery and consistency in results of your code/application.\n\nCan be performed manually or be automated.\n\nThis also makes it easier to refactor code, to avoid [[dev.issues.bug.regression]], and to implement according to the TDD model. \n\n\n## Types\n\n### Black Box Testing\n\nInternal implementation is not known to the tester.\n\n\n### [[dev.issues.bug.regression]] Testing\n\nDone when some changes are made to the code. Some already existing test scripts are run again to see if the new changes have adversely affected the code.\n\n\n## Test Driven Development (TDD)\n\nMethodology in which you Write tests before you write your productive code.\n\n","n":0.104}}},{"i":242,"$":{"0":{"v":"Unit Test","n":0.707},"1":{"v":"\n\nUnit testing is a process in which a developer ensures that the smallest testable units of their code - such as methods - are verifiable.\n\nUnit testing is an integral part of the development phase.\n","n":0.171}}},{"i":243,"$":{"0":{"v":"Seam","n":1},"1":{"v":"\n> /siːm/ <br>\n    _noun_ <br>\n    A line where two pieces of fabric are sewn together in a garment or other article.\n\nCode locations, where the code interacts with the entities outside of the code unit ([[concepts.dependency]]).\n","n":0.169}}},{"i":244,"$":{"0":{"v":"Test Double","n":0.707},"1":{"v":"\n\n- Like stunt double, but for testing.\n- For testing purposes, test double does the job of the code on which your code under test depends.\n\n## Types of Test doubles\n  \n### Stub\n\nProvides “indirect input”\n\n1. Test places desired return value in stub\n2. Stub returns the desired value to the code under test\n\n```abap\nCLASS ltd_stub DEFINITION FOR TESTING.\n  PUBLIC SECTION.\n    INTERFACES if_cash_provider PARTIALLY IMPLEMENTED.\n    DATA m_notes TYPE if_cash_provider=>tt_change.\nENDCLASS.\n        \nCLASS ltd_stub IMPLEMENTATION.\n  METHOD if_cash_provider~get_notes.\n    r_notes = m_notes.\n  ENDMETHOD.\nENDCLASS.\n```\n\n### Spy \n\nLogs the “indirect output”\n\n1. Spy logs the value passed by the code under test\n2. Test verifies the recorded value\n\n```abap\nCLASS ltd_spy DEFINITION FOR TESTING.\n    PUBLIC SECTION.\n    INTERFACES if_cash_provider PARTIALLY IMPLEMENTED.\n    DATA m_currency TYPE string.\nENDCLASS.\n\nCLASS ltd_spy IMPLEMENTATION.\n    METHOD if_cash_provider~get_notes.\n    m_currency = i_currency.\n    ENDMETHOD.\nENDCLASS\n```\n\n### Fake\n\nSimple implementation of depended-on component\n\n### Mock \n\nExtension of stub, spy, and fake; verifies the “indirect input” and/or “indirect output” according to given expectations\n\n1. Test places desired value in mock\n2. Spy logs the value passed by the code\nunder test\n3. Stub returns the desired value to the code\nunder test\n4. Test verifies the recorded value\n\n```abap\nCLASS ltd_mock DEFINITION FOR TESTING.\n    PUBLIC SECTION.\n    INTERFACES if_cash_provider PARTIALLY IMPLEMENTED.\n    DATA m_currency TYPE string.\n    DATA m_currency_exp TYPE string.\n    DATA m_notes TYPE if_cash_provider=>tt_change.\nENDCLASS.\n\nCLASS ltd_mock IMPLEMENTATION.\n    METHOD if_cash_provider~get_notes.\n    m_currency = i_currency.\n    r_notes = m_notes.\n    ENDMETHOD.\n    METHOD assert_expectations.\n    cl_abap_unit_assert=>assert_equals(\n    act = m_currency\n    exp = m_currency_exp ).\n    ENDMETHOD.\nENDCLASS.\n```\n\n### Dummy\n\nSatisfies syntax requirements; does nothing\n\n## References\n\nTerminology from the book _xUnit Test Patterns, Gerard Meszaros_\n","n":0.067}}},{"i":245,"$":{"0":{"v":"Test Isolation","n":0.707},"1":{"v":"\n\n> Test should only fail because of the system under test.\n\nConsider two cases. In the first case, you are testing your code under test which is independent. Now, if an error occurs in your test, you'd know it was because there is something wrong with your code.\n\nSecond case - your code depends on some other class or code. Now, if you get error in your unit test, you wouldn't know where the error is coming from. This makes the whole exercise of creating a unit test pointless. You'll still have to investigate which part is causing the error in your machinery despite the test.\n\n## How to ensure test isolation\n\n### Find a [[dev.tests.unit.seam]]\n\nSeams depend on the use case\n- [[dev.tests.unit]]s want no dependencies\n- Integration/system tests might only isolate a few dependencies\n- If you have a small component where three classes that interact very closely, you might not need isolation there because they belong to the same logical problem.\n- Anything that depends on time or duration\n- You can't wait till February 29th to execute your test\n\nProvide Testability\n  Always create classes with interface. That way, if your class is a dependency for another code, the developer can create a test double by simply implementing that interface.\n\n    > Create interfaces for all your classes. Always.\n        Interfaces are the heart of testability.\n        The users of your code will be grateful.\n\n### Provide an [[arch.design.oo.patterns.di]] mechanism\n\nImplement the interface of the depended-on component\n- Interface provided → you are all set\n- No interface provided\n    - → Convince your colleague to provide an interface\n    - → Implement your own interface\n      - Only implement the interface methods you need for the test using the keyword `PARTIALLY IMPLEMENTED`\n\nInherit from the depended-on component\n- Redefine the methods where you need to have a test double for\n- Drawbacks\n      - Not always possible due to [[programming.oo.components.types.final]] definition of the class\n      - The risk to execute unwanted code in tests is higher e.g. when methods are added later in the code under test and are forgotten to be REDEFINEd in the subclass\n- Implement the test double\n\n### Dependency lookup using [[arch.design.oo.patterns.gof.creational.factory]]\n\n- During tests, the object factory shall return test doubles to the code under test\n\n#### Secure injection\n\nAs a test developer, you need a secure technique to inject test doubles into the object factory class\n\n##### Solution - Injector class\n\n- Must only be available for tests. It is therefore declared as test class\n- Must be global friend of the factory class to modify object factory class internal\n\n#### Example\n\n```abap\nCLASS cl_managed DEFINITION\n    PUBLIC\n    FINAL\n    CREATE PRIVATE\n    GLOBAL FRIENDS cl_factory.\n    \n    PUBLIC SECTION.\n    INTERFACES if_managed.\n…\n```\n\n```abap\nCLASS cl_factory DEFINITION\n    PUBLIC\n    FINAL\n    CREATE PRIVATE\n    GLOBAL FRIENDS cl_injector.\n\n    PUBLIC SECTION.\n    CLASS-METHODS get_managed\n    RETURNING VALUE(r_instance)\n    TYPE REF TO if_managed.\n    PRIVATE SECTION.\n    CLASS-DATA g_managed\n    TYPE REF TO if_managed.\n…\n\nCLASS cl_factory IMPLEMENTATION.\n    METHOD get_managed.\n    IF g_managed IS NOT BOUND.\n    g_managed = NEW cl_managed( ).\n    ENDIF.\n    r_instance = g_managed.\n    ENDMETHOD.\n...\n```\n\n```abap\nCLASS cl_injector DEFINITION\n    PUBLIC\n    FOR TESTING\n    FINAL\n    CREATE PRIVATE.\n\n    PUBLIC SECTION.\n    CLASS-METHODS inject_managed\n    IMPORTING i_test_double\n    TYPE REF TO if_managed.\n…\n\nCLASS cl_injector IMPLEMENTATION.\n    METHOD inject_managed.\n    cl_factory=>g_managed = i_test_double.\n    ENDMETHOD.\n…\n```\n\n> Consider a [[arch.design.oo.patterns.gof.creational.factory]] for integration tests that manages your application / component indirections and collects all factory methods.\n","n":0.044}}},{"i":246,"$":{"0":{"v":"Programming Principles","n":0.707},"1":{"v":"\n\n- **DRY**: Don't Repeat Yourself\n- **KISS**: Keep it simple stupid","n":0.316}}},{"i":247,"$":{"0":{"v":"Memory Management","n":0.707}}},{"i":248,"$":{"0":{"v":"Manual Memory Management","n":0.577},"1":{"v":"\nYou can use [[dev.lingo.variable.pointer]]s to manually control and allocate blocks of memory.\n","n":0.289}}},{"i":249,"$":{"0":{"v":"Memory Leaks","n":0.707},"1":{"v":"\nA memory leak happens when an application allocates memory but fails to free it when it’s no longer required. This can occur due to incorrect memory management by the program.","n":0.183}}},{"i":250,"$":{"0":{"v":"Implicit Memory Management","n":0.577},"1":{"v":"\nWhen the system (programming language, os, distributed systems etc) does the memory management for you.\n","n":0.258}}},{"i":251,"$":{"0":{"v":"Garbage collection","n":0.707},"1":{"v":"\n- Garbage collection (GC) is a process that reclaims unused memory during program execution.\n- When a program allocates memory for objects (such as variables, data structures, or objects created dynamically), some of that memory may become unreachable (i.e., no longer referenced by any part of the program).\n- The garbage collector identifies and frees up this unreferenced memory, making it available for future allocations.\n\n\n## Does [[dev.memory management.implicit]] really prevent [[dev.memory management.leaks]] from happening?\n\n\"No memory leaks\" is a common argument given in support of automatic memory management. Although, with languages supporting garbage collection, you are leaking memory constantly. Since, you are allocating memory (you have some control there at least), but the language forces you to forget about the allocated memory. There always some garbage in the system inherently.\n\n**Why it is bad?**\n\nAlthough it doesn't necessarily cause much issues in the application itself. The application consumes more memory than necessary, leaving the memory, which could've been utilized by other processes, hogged. \n\nGarbage collection is a selfish algorithm. As in, it cares only about the application. Unless it works closely with the OS and the OS can ask it to free up some memory, other processes may suffer from shortage of free memory.\n\n## References\n\n- [Why I hate Java - No memory leaks](http://warp.povusers.org/grrr/java.html#:~:text=presented%20defending%20it.-,No%20memory%20leaks%3F,-The%20most%20usual)","n":0.069}}},{"i":252,"$":{"0":{"v":"Memory Allocation","n":0.707}}},{"i":253,"$":{"0":{"v":"Static Memory Allocation","n":0.577},"1":{"v":"\nMemory alloted during [[execution.lifecycle.build]].\n\n","n":0.5}}},{"i":254,"$":{"0":{"v":"Dynamic Memory Allocation","n":0.577},"1":{"v":"\nMemory allocated during [[execution.lifecycle.runtime]].","n":0.5}}},{"i":255,"$":{"0":{"v":"Lingo","n":1},"1":{"v":"\n## References\n\n\n- [Lexical Analysis - Python](https://docs.python.org/3/reference/lexical_analysis.html#)","n":0.408}}},{"i":256,"$":{"0":{"v":"Variable","n":1}}},{"i":257,"$":{"0":{"v":"Reference Variables","n":0.707},"1":{"v":"\n\n- References are strongly typed\n\n    Type of a reference is much more strictly controlled in Java than the type of a [[dev.lingo.variable.pointer]] is in C. In C you can have an `int*` and cast it to a `char*` and just re-interpret the memory at that location. That re-interpretation doesn’t work in Java: you can only interpret the object at the other end of the reference as something that it already is (i.e. you can cast a Object reference to String reference only if the object pointed to is actually a String).\n\n- References are not memory addresses per se. They are more like object handles.\n  - The object's memory address will change when it's moved. But the object handle will stay the same.\n  - For example, JVM is allowed to use moving garbage collectors, which means objects can be relocated by the GC. (In fact, generational GCs frequently relocate objects, when migrating them between generations.)\n  - [[dev.lingo.variable.pointer.arithmetic]] nlot allowed.\n\n## References\n\n- [C/C++ Pointers vs Java References](https://www.geeksforgeeks.org/is-there-any-concept-of-pointers-in-java/) — Geeks for geeks\n- [If Java uses references and references are just memory addresses, can I perform arithmetic operations on the addresses they point to? — Quora](https://www.quora.com/If-Java-uses-references-and-references-are-just-memory-addresses-can-I-perform-arithmetic-operations-on-the-addresses-they-point-to)\n","n":0.072}}},{"i":258,"$":{"0":{"v":"Pointer","n":1}}},{"i":259,"$":{"0":{"v":"Disadvantages of Pointers","n":0.577},"1":{"v":"\n\n- Memory access via [[dev.lingo.variable.pointer.arithmetic]] — fundamentally unsafe\n- [[dev.memory management.manual]] — not worth the effort for general purpose OOP programming\n\n## References\n\n[Why Java doesn't support pointers? — Stack overflow](https://stackoverflow.com/questions/9595636/why-java-doesnt-support-pointers)\n","n":0.189}}},{"i":260,"$":{"0":{"v":"Pointer Arithmetic","n":0.707},"1":{"v":"\n\nSince pointers are numeric values, you can technically perform arithmetic operations on them.\n\n## References\n\n[Pointer Arithmetic in C with examples - GFG](https://www.geeksforgeeks.org/pointer-arithmetics-in-c-with-examples/)\n\n","n":0.218}}},{"i":261,"$":{"0":{"v":"Case against Pointers","n":0.577},"1":{"v":"\n\n- Memory access via [[dev.lingo.variable.pointer.arithmetic]] — fundamentally unsafe\n- [[dev.memory management.manual]] — not worth the effort for general purpose OOP programming\n\n## References\n\n[Why Java doesn't support pointers? — Stack overflow](https://stackoverflow.com/questions/9595636/why-java-doesnt-support-pointers)\n","n":0.189}}},{"i":262,"$":{"0":{"v":"Advantages of Pointers","n":0.577},"1":{"v":"\n- Helpful for writing extremely low level code\n- [[dev.memory management.manual]]\n  - Useful for some applications (games, device drivers)\n\n## References\n\n[Why Java doesn't support pointers? — Stack overflow](https://stackoverflow.com/questions/9595636/why-java-doesnt-support-pointers)\n","n":0.196}}},{"i":263,"$":{"0":{"v":"Function","n":1}}},{"i":264,"$":{"0":{"v":"Anonymous Functions","n":0.707},"1":{"v":"\nFunctions without a name. \n\nThere are different ways of creating anonymous functions:\n\n```js\n// An anonymous function assigned to a variable\nconst add = function(x, y) {\n    return x + y;\n};\nconsole.log(add(2, 3));  // Output: 5\n\n// An anonymous function used as a callback\nsetTimeout(function() {\n    console.log(\"Hello, World!\");\n}, 1000);\n\n```\n\nCan be created using [[paradigm.func.components.lambda]] expressions. Such functions are called lambda functions.\n\n```python\n# Anonymous (lambda) function passed to map\nsquared = list(map(lambda x: x ** 2, [1, 2, 3, 4]))\nprint(squared)  # Output: [1, 4, 9, 16]\n\n```\n\n\n","n":0.115}}},{"i":265,"$":{"0":{"v":"Statements","n":1},"1":{"v":"\nStatements are just instructions for the computer to do something.\n\nA program is just a sequence of statements.\n\n\n## References\n\n- [Statements vs Expressions - Josh W Comeau](https://www.joshwcomeau.com/javascript/statements-vs-expressions/)","n":0.2}}},{"i":266,"$":{"0":{"v":"Literal","n":1},"1":{"v":"\nLiterals are specific values that appear directly in code. \n\nFor example, `2.5`, `\"Hello\"` etc.","n":0.267}}},{"i":267,"$":{"0":{"v":"Identifiers","n":1},"1":{"v":"\nIdentifiers are lexical tokens to identify entities in a program, query or request.\n\nIt could be a combination of characters (string) which uniquely identifies a resource or entity in a given domain/scope.","n":0.18}}},{"i":268,"$":{"0":{"v":"Unqualified Identifier","n":0.707},"1":{"v":"\nIn cases where there is no ambiguity in the entity being referred to, we can simply use [[dev.lingo.identifiers]]s. Such identifiers are called unqualified since there is no need for a [[dev.lingo.identifiers.qualifier]].","n":0.18}}},{"i":269,"$":{"0":{"v":"Qualifier","n":1},"1":{"v":"\nIn cases where there could be an ambiguity in identifying an entity, qualifiers serve as the distinguishing factor to uniquely and unambiguously identify an entity.\n\nQualifiers are also identifers, which help remove ambiguity. But not all identifiers are qualifiers.\n\nIn addition to being used, where its not possible to interpret identifiers unambiguiosly, qualifiers can be used to --\n\n1. **Override a default context**: \n    If the default context is the current class or default database, qualifier can be used to override that.\n2. **Provide missing context**:\n    We can explicitly state the default context too to clearly indicate the intended context.\n\n## References\n\n- [Joop Eggen's comment on 'What does \"qualified this\" construct mean in java?' - StackOverflow](https://stackoverflow.com/questions/11276994/what-does-qualified-this-construct-mean-in-java#comment14829768_11276994)\n- [Spring @Qualifier annotation - Baeldung](https://www.baeldung.com/spring-qualifier-annotation)\n- [Database Object Names and Qualifiers - Oracle Database](https://docs.oracle.com/en/database/oracle/oracle-database/23/sqlrf/Database-Object-Names-and-Qualifiers.html#GUID-75337742-67FD-4EC0-985F-741C93D918DA)","n":0.09}}},{"i":270,"$":{"0":{"v":"Qualified Identifier","n":0.707},"1":{"v":"\nQualified Identifiers are used in case where there an ambiguity as to which entity an identifier can refer to. In such cases, the identifier is paired with a [[dev.lingo.identifiers.qualifier]].\n\nAn identifier can be \"fully qualified\" by combining all possible qualifiers. For example, a complete file path. \n\n## References\n\n- [11.2.2. Identifier Qualifiers - MySQL 8.0 Reference Manual Including MySQL NDB Cluster 8.0 - Oracle Docs](https://docs.oracle.com/cd/E17952_01/mysql-8.0-en/identifier-qualifiers.html)\n- [Identifier Qualifiers - MariaDB Knowledge Base](https://mariadb.com/kb/en/identifier-qualifiers/)\n- [Identifier Qualifiers - MySQL 8.0 Reference Manual](https://dev.mysql.com/doc/refman/8.0/en/identifier-qualifiers.html)","n":0.115}}},{"i":271,"$":{"0":{"v":"Expression","n":1},"1":{"v":"\nA bit of code that produces a value.\n\n\n## References\n\n- [Statements vs Expressions - Josh W Comeau](https://www.joshwcomeau.com/javascript/statements-vs-expressions/)","n":0.25}}},{"i":272,"$":{"0":{"v":"Code Smell","n":0.707},"1":{"v":"\n\nIndicators of deeper underlying problems in the code.\n","n":0.354}}},{"i":273,"$":{"0":{"v":"Algorithms","n":1},"1":{"v":"\n\n- Generate pre-defined outputs on basis of previously programmed rules which are hard-coded in the system.\n- Rule-based Algorithms have fixed result and the result doesn't change or evolve based on the data.\n- Typically in the form of if-then expressions.\n\n## Rule-based system\n\n- Set of facts: Domain-specific knowledge - Database\n- Set of rules: Rules engine which makes up the knowledge base\n- Inference engine; Capable of deriving conclusions.\n\n\n## References\n\n\n- [LeetCode's Interview Crash Course - Data Structures and Algorithms](https://leetcode.com/explore/featured/card/leetcodes-interview-crash-course-data-structures-and-algorithms/) #course\n","n":0.115}}},{"i":274,"$":{"0":{"v":"Search","n":1}}},{"i":275,"$":{"0":{"v":"Binary Search","n":0.707},"1":{"v":"\nLets say we want to find a value `target` in a data structure.\n\n```pseudocode\n\nBinarySearch(data_structure, target):\n    left ← starting point of the data_structure\n    right ← end point of the data_structure\n\n    while left ≤ right:\n        mid ← middle element of the data_structure between left and right\n\n        if data_structure[mid] == target:\n            return mid  // target found\n\n        else if data_structure[mid] < target:\n            left ← mid + 1  // search in the right half\n\n        else:\n            right ← mid - 1  // search in the left half\n\n    return -1  // target not found\n\n```","n":0.108}}},{"i":276,"$":{"0":{"v":"Paradigms","n":1}}},{"i":277,"$":{"0":{"v":"Greedy Algorithms","n":0.707},"1":{"v":"\nhttps://medium.com/techie-delight/top-7-greedy-algorithm-problems-3885feaf9430\nhttps://www.geeksforgeeks.org/greedy-algorithms/","n":1}}},{"i":278,"$":{"0":{"v":"Dynamic Programming","n":0.707},"1":{"v":"\nhttps://stackoverflow.blog/2022/01/31/the-complete-beginners-guide-to-dynamic-programming/","n":1}}},{"i":279,"$":{"0":{"v":"Patterns","n":1}}},{"i":280,"$":{"0":{"v":"Two Pointer","n":0.707},"1":{"v":"\nAny algorithm involving use of two pointers/index variables to traverse over a data structure.\n\nYou take two pointers and move them untill you find the expected result.\n\nThere are many variants of this approach since the approach is only about taking two pointers. It only gets more concrete when we dig deeper.\n\nCategorizing on basis of how the pointers move:\n\n1. Running from both ends of an array\n2. Slow & Fast Pointers\n3. Running from beginning of 2 arrays / Merging 2 arrays\n4. Split & Merge of an array / Divide & Conquer\n\n## Slow and fast pointers\n\nSpecific pattern of two pointer algorithms where one pointer moves faster than the other. \n\nThe movement of fast could be n times that of the slow pointer, where n is any positive integer. Or the slow pointer could be started late from the first node. \n\n### Use cases\n\n1. **To detect cycle in a linked list**: If there is a circular track and one car is moving faster than the other, the two cars are bound to cross at some point.\n2. **To find middle element of a list**: When the fast pointer going at 2x of slow pointer reaches the end - slow pointer will be at the middle element of the list.\n3. **To find $$n^{th}$$ element from the end in a list**: Start the slow pointer once the fast pointer reaches the $$n^{th}$$ element and then move both at the same speed. By the time, the fast pointer reaches the end, slow pointer will be at nth element from the end.\n\n## References\n\n- [Solved all two pointers problems in 100 days - Leetcode discuss](https://leetcode.com/discuss/study-guide/1688903/Solved-all-two-pointers-problems-in-100-days)","n":0.062}}},{"i":281,"$":{"0":{"v":"Sliding Window","n":0.707},"1":{"v":"\nFor finding subarrays/substrings with a specific criteria.\n\n1. Use **Two pointers**: `start` and `end` to represent a window\n2. Move `end` to find a valid window\n3. When a valid window is found, move `start` to find a smaller(better) window.\n\n\n","n":0.164}}},{"i":282,"$":{"0":{"v":"Prefix Sum","n":0.707},"1":{"v":"\nA precomputation strategy, where you preprocess and store the sum upto each element before hand, so that, when required in the actual computation, these sums can be quickly queried.\n\n\nFor example:\n\n- Array: `[1,2,3,4,5,6,7]`\n- Prefix Sum Array: `[1,3,6,10,15,21,28]`","n":0.167}}},{"i":283,"$":{"0":{"v":"Mapping","n":1},"1":{"v":"\nMany times in algorithmic problems, we want to store state against a `key` value. An obvious way which comes to mind is using a hashmap. But there can be multiple ways of doing it. \n\n## Ways to map key-value\n\n### 1. Hashmap/dictionary (key-value data structures)\n\nValues(state) which you want to maintain can simply be stored against a `key` in such data structures.\n\n💡In addition to identifying if an element _exists_ in a dataset, hashmaps can also be used to identify if the dataset contains any duplicate simply by comparing the size of hashmap with the original dataset.\n\n```js\nvar containsDuplicate = (nums) =>new Set(nums).size != nums.length;\n```\n\n### 2. Array\n\nWhile not the first thing which comes to mind when thinking of a key-value pairs, arrays can be used in cases where the number of keys are going to be limited. \n\nFor example, in cases where the `key`s are ASCII characters, you can simply create an array of size 256 and store the state against the index corresponding to ASCII value of the character in the array. \n\nIf keys are alphabets, the array size would be 129.\n\n### 3. BITs","n":0.074}}},{"i":284,"$":{"0":{"v":"Data","n":1}}},{"i":285,"$":{"0":{"v":"Base","n":1}}},{"i":286,"$":{"0":{"v":"Table","n":1}}},{"i":287,"$":{"0":{"v":"Key","n":1},"1":{"v":"\n\n## Unique Key\n\n## Primary Key\n\n## Composite Key\n\n## \n","n":0.354}}},{"i":288,"$":{"0":{"v":"Design","n":1}}},{"i":289,"$":{"0":{"v":"Normalization","n":1},"1":{"v":"\n\nNormalization is a process of organizing database in a table which is used to minimise redundancy in a table.\n\n## 1NF\n\n- **First normal form**\n- If the table holds atomic value.\n- One attribute → One attribute.\n- Break rows if there are two values in any row.\n\n## 2NF\n\n- **Second Normal Form**\n- Should be in First Normal Form.\n- All non-key attributes are fully functional dependent on primary key.\n- That basically means, seperate out tables to make a primary key.\n\n## 3NF\n\n- Third Normal Form\n- Should be in Second Normal Form\n- No Transitive Partial Dependency\n- Break the table to remove this\n\n\n## References\n\n- [Basic Concept of Normalization - Knowledge Gate (Sanchit Jain) - Youtube](https://www.youtube.com/watch?v=oylHRgBDfNc&t=37s)\n- [Normalization in DBMS - Knowledge Gate](https://www.youtube.com/watch?v=px7HV91fx2I&t=5s)\n- [DBMS - Normalization - Sanchit Jain - Youtube playlist](https://www.youtube.com/watch?v=px7HV91fx2I&t=5s)\n","n":0.091}}},{"i":290,"$":{"0":{"v":"Dependency","n":1},"1":{"v":"\n## Functional Dependency\n\nWhen one attribute can be used to uniquely determine (or fetch) another.\n\nFor example, `Employee ID` can be used to determine `Employee Name`.\n\n- Determining attribute = **Determinant** \n- Attribute being determined = **Dependent**\n\nRepresented as: \n\n$$\n A \\rightarrow B\n$$\n\nFor example:\n\n$$\nEmployeeID \\rightarrow EmployeeName\n$$\n\n\n### Trivial Dependency\n\nWhen\n\n$$ \n    B \\subset A\n$$\n\nAnd \n\n$$\n A \\rightarrow B\n$$\n\nFor example,\n\n$$\nDateOfBirth \\rightarrow YearOfBirth\n$$\n$$\nFullAddress \\rightarrow City\n$$\n\nThe dependent attribute (B) should really be a subset of the determinant (A) for it to be a trivial dependency. Being able to calculate an attribute on basis of another doesn't make the calculable attribute a subset. For example, `Age` can be determined from `Date of birth` but `Age` is NOT a subset of `Date of birth`.\n\n### Partial\n\nWhen an attribute is dependent on only a part of a composite primary key\n\n### Transitive\n\n\n## Multivalued\n","n":0.088}}},{"i":291,"$":{"0":{"v":"Relational Database","n":0.707},"1":{"v":"\nDatabase in which data is modelled in the form of [Entities + Relationships].\n","n":0.277}}},{"i":292,"$":{"0":{"v":"SQL","n":1},"1":{"v":"\nSQL contains sub-languages within it for different purposes.\n\n## Data Definition Language (DDL)\n\n- `CREATE`: Creates a new table or database.\n- `ALTER`: Modifies an existing table or database.\n- `DROP`: Deletes an existing table or database.\n- `TRUNCATE`: Removes all records from a table, including all spaces allocated for the records.\n\n## Data Manipulation Language (DML)\n\n- `INSERT`: Inserts new data into a database.\n- `UPDATE`: Modifies existing data in a database.\n- `DELETE`: Removes data from a database.\n\n## Data Control Language (DCL)\n\n- `GRANT`: Gives a privilege to user.\n- `REVOKE`: Takes back privileges granted from user.\n\n## Transaction Control Language (TCL)\n\n- `COMMIT`: Saves all the transactions to the database.\n- `ROLLBACK`: Restores the database to the last committed state.\n- `SAVEPOINT`: Sets a savepoint within a transaction.\n- `SET TRANSACTION`: Places a name on a transaction.\n\n## Data Query Language (DQL)\n\n### `SELECT`\n\n- Retrieves data from a database.\n- Root clause of DQL\n\n#### Clauses\n\n- `WHERE`: Filters results based on a condition.\n- `GROUP BY`: Groups rows that have the same values in specified columns into summary rows.\n- `HAVING`: Filters groups based on a condition.\n- `ORDER BY`: Sorts the result set in ascending or descending order.\n\n##### `LIMIT`\n\nRestricts the number of rows returned. Often used in pagination.\n\n```sql\nSELECT * FROM table_name LIMIT number;\n```\n\n##### `OFFSET`\n\nSkips the specified number of rows before starting to return rows from a query\n\n```sql\nSELECT * FROM table_name LIMIT number OFFSET start;\n```\n\nUsually used with `LIMIT`.\n\nFor example: Query to select 3rd largest salary. #interview-question\n```sql\nSELECT DISTINCT salary\nFROM employees\nORDER BY salary DESC\nLIMIT 1 OFFSET 2;\n```\n\n#### Aggregate Functions\n\n- `COUNT`: Returns the number of rows.\n- `SUM`: Returns the sum of a numeric column.\n- `AVG`: Returns the average value of a numeric column.\n- `MIN`: Returns the smallest value of the selected column.\n- `MAX`: Returns the largest value of the selected column.\n- \n\n#### Scalar Functions\n\n- `UCASE()` (or `UPPER()`): Converts a field to uppercase.\n- `LCASE()` (or `LOWER()`): Converts a field to lowercase.\n- `MID()` (or `SUBSTRING()`): Extracts characters from a text field.\n- `LEN()` (or `LENGTH()`): Returns the length of a text field.\n- `ROUND()`: Rounds a numeric field to the number of decimals specified.\n- `NOW()`: Returns the current system date and time.\n- `FORMAT()`: Formats how a field is to be displayed.\n\n#### Join Commands\n\n- `INNER JOIN`: Returns records that have matching values in both tables.\n- `LEFT JOIN` (or `LEFT OUTER JOIN`): Returns all records from the left table, and the matched records from the right table.\n- `RIGHT JOIN` (or `RIGHT OUTER JOIN`): Returns all records from the right table, and the matched records from the left table.\n- `FULL JOIN` (or `FULL OUTER JOIN`): Returns all records when there is a match in either left or right table.\n- `CROSS JOIN`: Returns all records where each row from the first table is combined with each row from the second table.\nSELF JOIN: A regular join, but the table is joined with itself.\n\n\n","n":0.047}}},{"i":293,"$":{"0":{"v":"Data Structures","n":0.707},"1":{"v":"\nApplication of mathematical structures to represent data.","n":0.378}}},{"i":294,"$":{"0":{"v":"Secondary","n":1}}},{"i":295,"$":{"0":{"v":"Hash","n":1}}},{"i":296,"$":{"0":{"v":"Hashtable","n":1}}},{"i":297,"$":{"0":{"v":"Stack","n":1}}},{"i":298,"$":{"0":{"v":"Linked List","n":0.707}}},{"i":299,"$":{"0":{"v":"Graphs","n":1},"1":{"v":"\n\nNetwork that help define and visualise relationships between various components.\n\nMore formally -\n\nA graph $G = (V, E)$ is a set of vertices $V$ and edges $E$.\n    where each edge $(u,v)$ is a connection between vertices. $u, v \\in V$.\n\n- Edge is usually represented as a pair of vertices.\n- Vertices are also referred to as nodes.\n- Mathematically, graphs are represented using Set notation.\n\n```mermaid\ngraph LR\n    0((0)) --- 1((1))    \n    0((0)) --- 2((2))\n    1((1)) --- 3((3))            \n    0((0)) --- 3((3))\n    2((2)) --- 3((3))\n    3((3)) --- 4((4))                      \n```\n$E = \\{(0,1), (0,2), (0,3), (1,3), (2,3), (3,4)\\}$\n\n## Some Graph Terminology\n\n- **Neighbours**: Directly connected nodes.\n- **Degree** of a node: Number of neighbours of the node.\n- **Path**: Sequence of vertices connected by edges.\n- **Path Length**: Number of edges in the path.\n- **Cycle**: Path that ends at the same vertex.\n- **Connectivity**\n  - Two vertices are connected if a path exists between them\n  - Graph is connected if all vertices are connected.\n  - Connected component is a subset of vertices that are connected in an otherwise disconnected graph.\n\n\n## Types of Graphs\n\n### Undirected Graphs\n\n\nGraph where relation goes both ways i.e. **bidirectional edges**.\n\nEdge $(u,v)$ implies $(v,u)$.\n\n### Directed Graphs\n\nEdges are unidirectional.\n\nDirected graphs have their own subclasses on the basis of presence of a cycle in the graph.\n\n\n### Weighted Graphs\n\nWhen edges in the graph are assigned some weightage. The weight can be used to model quantities such as traffic on a route, distance, etc.","n":0.066}}},{"i":300,"$":{"0":{"v":"Traversal","n":1}}},{"i":301,"$":{"0":{"v":"Depth-first Search","n":0.707},"1":{"v":"\n\n- Start at root node.\n- Explore each branch as far as possible (till its depth).\n- No more vertex left in that branch?\n- Come back to where you can find vertices and start again.\n\nStart - explore - backtrack - repeat.\n\n![DFS](<../attachments/Depth-first Search (DFS)-image.png>)\n\n## Preorder and Postorder DFS\n\n- **Preorder**: When the node is \"visited\" while traversing to the depth.\n- **Postorder**: When the node is \"visited\" once we have encountered the leaf node.\n\n## Applications of DFS\n\n- Cycle Detection\n- Finding connected components\n- Topological Sort\n- Maze generation\n\n## References\n\n- [Depth First Search (DFS) Explained: Algorithm, Examples, and Code](https://youtu.be/PMMc4VsIacU?si=m7jEJLf80zjFGKAd)\n","n":0.105}}},{"i":302,"$":{"0":{"v":"Recursive Implementation of DFS","n":0.5},"1":{"v":"\n\n\n```python\ndef dfs(G,v):\n    visit(v)\n    for w in G.neighbours(v):\n        dfs(G,w)\n```\n\nThe only issue in the above algorithm is that we'll end up visiting nodes we have already visited. Thus, we need to mark the already visited nodes.\n\n```python\nmarked = [False] * G.size()\ndef dfs(G,v):\n    visit(v)\n    marked[v] = True\n    for w in G.neighbours(v):\n        if not marked[w]:\n            dfs(G,w)\n```\n\nTime complexity: $O(V+E)$;\n$V$ = no. of vertices\n$E$ = no. of edges\n\nCleaner and more readable than [[data.structure.secondary.graph.traversal.dfs.iterative]].\n\n## Implementation for Postorder DFS\n\nJust move the visit() call to the end.\n\n```python\nmarked = [False] * G.size()\ndef dfs(G,v):\n    marked[v] = True\n    for w in G.neighbours(v):\n        if not marked[w]:\n            dfs(G,w)\n    visit(v)\n```","n":0.103}}},{"i":303,"$":{"0":{"v":"Iterative Implementation of DFS","n":0.5},"1":{"v":"\n\n```python\nmarked = [False] * G.size()\ndef dfs(G,v):\n    stack = [v]\n    while len(stack) > 0:\n        v = stack.pop()\n        if not marked[v]:\n            visit(v)\n            marked[v] = True\n            for w in G.neighbours(v):\n                if not marked[w]:\n                    stack.append(w)\n```\n\nTime complexity: $O(V+E)$;\n$V$ = no. of vertices\n$E$ = no. of edges\n\n- More generalizable and extensible than [[data.structure.secondary.graph.traversal.dfs.recursive]]. As in, it can be tweaked to incorporate other algorithms.\n- Using Iterative Implementation, you can explicitly specify the stack size. While recursive approach uses the OS' default stack size, which is still typically small - and thus can cause stack overflow.\n","n":0.107}}},{"i":304,"$":{"0":{"v":"Sorting","n":1}}},{"i":305,"$":{"0":{"v":"Topological Sort","n":0.707},"1":{"v":"\n\nIt is a way of sorting a Directed Acyclic Graph in an order where for any edge $u \\to v$, u always comes before v in the sort.\n\nFor a Topological Sort, the nodes should be executed in order of their direction.\n\n- The nodes with no prerequisites (no arrows pointing towards them) are the leaf nodes.\n- The leaf nodes come first in a postorder search and we trace back our steps from their.\n- For a Topological Sort, the nodes with no prerequisites should be executed last.\n- Since, the last node of topological sort is the first node of the postorder DFS traversal, and this order is maintained throughout the traversal => reversing postorder DFS automatically gives a topological sort for a Graph.\n\n## References\n\n[Depth First Search (DFS) Explained: Algorithm, Examples, and Code](https://youtu.be/PMMc4VsIacU?si=07x2kNfOdPjKJqoN)\n","n":0.088}}},{"i":306,"$":{"0":{"v":"Representing Graphs","n":0.707},"1":{"v":"\n\nGraphs can be represented in the following forms in memory. \n\n```mermaid\ngraph LR\n    0((0)) --- 1((1))    \n    0((0)) --- 2((2))\n    1((1)) --- 3((3))            \n    0((0)) --- 3((3))\n    2((2)) --- 3((3))\n    3((3)) --- 4((4))                      \n```\n\n## Adjacency Matrix\n\n$$\nA_{ij} =     1  \\;\\;\\; if \\ edge(i,j) \\\\\n\\;\\;\\;\\;\\;\\; 0  \\;\\;\\; otherwise \n$$\n\n\n|      | 0 | 1 | 2 | 3 | 4 |\n|------|---|---|---|---|---|\n **0** | 0 | 1 | 1 | 1 | 0 |\n **1** | 1 | 0 | 0 | 1 | 0 |\n **2** | 1 | 0 | 0 | 1 | 0 |\n **3** | 0 | 1 | 1 | 0 | 1 |\n **4** | 0 | 0 | 0 | 0 | 1 |\n\n\n## Edge Set\n\n$$\nE = \\{(0,1), (0,2), (0,3), (1,3), (2,3), (3,4)\\}\n$$\n\n\nHarder to extract information about vertices of the graph => Not that common.\n\n\n## Adjacency List\n\n```mermaid\ngraph LR\n    Node0[0] --> List0[1 , 2]\n    Node1[1] --> List1[0 , 3]\n    Node2[2] --> List2[0 , 3]\n    Node3[3] --> List3[0, 1, 2, 4]\n    Node4[4] --> List4[3]    \n```\n\n- Easy access to neighbours of a node -- useful in graph algorithms.\n- Most real world graphs are sparse. That is, large number of nodes with fewer number of edges. For example, in a social network, there could be billions of people (nodes), but each person (node) will only have thousands of edges at most.\n","n":0.067}}},{"i":307,"$":{"0":{"v":"Primary","n":1}}},{"i":308,"$":{"0":{"v":"Node","n":1}}},{"i":309,"$":{"0":{"v":"Degree of node","n":0.577},"1":{"v":"\n\nNumber of edges or other nodes connected to a particular node.","n":0.302}}},{"i":310,"$":{"0":{"v":"Array","n":1}}},{"i":311,"$":{"0":{"v":"Insertion","n":1}}},{"i":312,"$":{"0":{"v":"At End","n":0.707},"1":{"v":"\n\n\n## In the same array (fixed size)\n\n1. Check if array has capacity\n2. If yes, add the element to the array's length + 1\n```js\nfunction insertSorted(arr, n, key, capacity)\n        if (n >= capacity)\n            return n;\n      \n        arr[n] = key;\n        return (n + 1);\n    }\n```\n\n# Copy to a new array (dynamically sized)\n\n```js\narr.push(new_element)\n```\n\n```python\ndef insertAtEnd():\n    arr.append(new_element)\n```","n":0.14}}},{"i":313,"$":{"0":{"v":"Searching","n":1},"1":{"v":"\n## Binary Search\n\nHere's the code using [[dev.algo.search.binary]] algorithm for searching an array:\n\n```java\n    public static int binarySearch(int[] arr, int target) {\n        int left = 0;\n        int right = arr.length - 1;\n\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n\n            if (arr[mid] == target) {\n                return mid;\n            }\n\n            if (arr[mid] < target) {\n                left = mid + 1;\n            }\n            else {\n                right = mid - 1;\n            }\n        }\n\n        return -1;\n    }\n ```","n":0.114}}},{"i":314,"$":{"0":{"v":"Ops","n":1}}},{"i":315,"$":{"0":{"v":"Traversal","n":1},"1":{"v":"\n\nTo visit every element/node of the data structure.","n":0.354}}},{"i":316,"$":{"0":{"v":"Concepts","n":1}}},{"i":317,"$":{"0":{"v":"Pattern","n":1},"1":{"v":"\nRecurring Solution to a recurring problem.\n","n":0.408}}},{"i":318,"$":{"0":{"v":"Dependency","n":1},"1":{"v":"\nDependency is a broad software engineering term used to refer when a piece of software relies on another one. Simply put, if Program A requires Program B to be able to run, Program A is dependent on Program B. This makes Program B a dependency of Program A.\n\nIt doesn’t really matter what it is, if your program needs it to run correctly, it’s a dependency.\n\n- Examples\n  - Create an object or call a method\n  - Interact with a database\n  - Call a function\n  - Call a report\n  - Get or call a BAdI\n  - Write or read global variables\n  - Get the ‘current time’\n  - Programming libraries\n  - Online services\n  - Programming scripts etc.\n\n## References\n\n[CodersLegacy - What are dependencies in programming](https://coderslegacy.com/what-are-dependencies-in-programming/)\n","n":0.091}}},{"i":319,"$":{"0":{"v":"Cyclic Dependency","n":0.707},"1":{"v":"\nCyclic or circular dependencies occur when two software components are directly or indirectly dependent on each other.\n","n":0.243}}},{"i":320,"$":{"0":{"v":"Early Reference Resolution","n":0.577},"1":{"v":"\nTechnique to break [[concepts.dependency.cyclic]].\n\nWhenever such a dependency is detected, a proxy or \"early reference\" is created for one of the entities is created before the full initialization and then load the dependency later lazily, resolving the dependencies.\n\n","n":0.164}}},{"i":321,"$":{"0":{"v":"Paradigms","n":1},"1":{"v":"\n\nParadigm is a style or approach of [[execution]].\n\nWhile mostly used in context of programming, the concepts can be used and the styles can influence other architectures.\n","n":0.196}}},{"i":322,"$":{"0":{"v":"Resource Oriented","n":0.707},"1":{"v":"\nEntities can be represented as resources which can be identified and manipulated.","n":0.289}}},{"i":323,"$":{"0":{"v":"OOP","n":1},"1":{"v":"\n\n> \"Objects encapsulate state and behavior.\"\n\n- [[paradigm.imperative]] paradigm\n- Object are first-class citizens.","n":0.289}}},{"i":324,"$":{"0":{"v":"Tags","n":1}}},{"i":325,"$":{"0":{"v":"same-same-but-different classes","n":0.707},"1":{"v":"\n\nGroup of classes which are closely related to each other but some behavior differs.\n\n## References\n\n[The Interview](https://www.youtube.com/watch?v=7tTfL-DtpXk&ab_channel=BradGroux)\n","n":0.25}}},{"i":326,"$":{"0":{"v":"Everything Is an Object","n":0.5},"1":{"v":"\n\nObject Oriented ⇒ Everything is an object\n","n":0.378}}},{"i":327,"$":{"0":{"v":"Features","n":1}}},{"i":328,"$":{"0":{"v":"Binding","n":1}}},{"i":329,"$":{"0":{"v":"Static Binding","n":0.707},"1":{"v":"\n\nWhen the type of object is determined at compile time\n\nExample:\n\n```java\nStudent s = new Student();\n```\n","n":0.267}}},{"i":330,"$":{"0":{"v":"Dynamic Binding","n":0.707},"1":{"v":"\n\n\nWhen the type of object is determined at runtime.\n\nHappens when object of child is assigned to reference of parent.\n\nExample:\n\n```java\nHuman h = new Student()\n//Student IS-A Human\n```\n\n```java\nfoo(Human h) //method definition\n\n//method call\nfoo(Student s)\n```\n\nReference of Human type ————>       Object of Student type.\n\n(Reference Variable) ---------------->                                           (Object)\n\n\n# Argument -- `Human h = new Student()` is not dynamic binding\n\n#interview-question\n\nSomeone could very easily make an argument that `Human h = new Student()` is not Dynamic Binding\n\n```java\nclass Human{\n    foo(){}\n}\n\nclass Student extends Human{\n    foo(){}\n    xyz(){}\n}\n\nmain(){\n    Human h = new Student();\n    \n    h.xyz(); //This line will give error. \n    h.foo(); \n}\n```\n\n## Why it looks like its not runtime polymorphism\n\nThe line `h.xyz()` will immediately show an error.\n\n- `h.xyz()`  shows error\n- ⇒ Program doesn't know h is an object of class Student\n- ⇒ h is an object of Human type\n- ⇒ Its not runtime polymorphism\n\n## What actually happens\n\nCompiler doesn't know at compile time that 'h' is an object of Student type.\n\n- Object type determined at runtime\n- ⇒ Compiler still thinks 'h' is an object of Human type\n- ⇒ COMPILE TIME Error.\n\n\nEven though we can't call Student-exclusive  methods from this reference without casting, the type of object or the version of method to be called is still determined at runtime. Which still makes it a case of dynamic binding and [[paradigm.oo.principles.polymorphism.runtime]]. \n","n":0.069}}},{"i":331,"$":{"0":{"v":"Shadowing/Hiding","n":1},"1":{"v":"\n\n- **Overriding** => In case of non-static methods\n\n    ```java\n    class A{\n        public void show(){\n        System.out.println(\"in A\");\n        }\n    }\n\n    class B extends A{\n        public void show(){\n        System.out.println(\"in B\");\n        }\n    }\n    ```\n\n- **Hiding** => In case of all other members (instance members, static members, static methods)\n\n    ```java\n    class A{\n    int a;\n    static int b;\n    static meth();\n    }\n\n    class B extends A{\n    int a;\n    static int b;\n    static meth();\n    }\n\n    //class B now has both properties.\n    //'a' from its own class\n    ```\n\n## Major Difference between Method [[paradigm.oo.principles.polymorphism.overriding]] and Hiding\n\nThis\n\n```java\nclass Foo {\n    public void method() {\n        System.out.println(\"in Foo\");\n    }\n}\n \nclass Bar extends Foo {\n    public void method() {\n        System.out.println(\"in Bar\");\n    }\n}\n```\n\nis not the same as this\n\n```java\nclass Foo {\n    public static void method() {\n        System.out.println(\"in Foo\");\n    }\n}\n \nclass Bar extends Foo {\n    public static void method() {\n        System.out.println(\"in Bar\");\n    }\n}\n```\n\nBoth the codes compile and run fine.\n\nBut the second one isn't an example of one static method *z* another static method. Its an example of a static method **hiding** another static method.\n\nWhat's the difference?\n\n### [[paradigm.oo.principles.polymorphism.runtime]] - When you override, you get it. When you hide, you don't.\n\n```java\nclass Foo {\n    public static void classMethod() {\n        System.out.println(\"classMethod() in Foo\");\n    }\n \n    public void instanceMethod() {\n        System.out.println(\"instanceMethod() in Foo\");\n    }\n}\n \nclass Bar extends Foo {\n    public static void classMethod() {\n        System.out.println(\"classMethod() in Bar\");\n    }\n \n    public void instanceMethod() {\n        System.out.println(\"instanceMethod() in Bar\");\n    }\n}\n  \npublic class Test {\n    public static void main(String[] args) {\n        Foo f = new Bar();\n        f.instanceMethod();\n        f.classMethod(); //*Accessing static method using object\n    }\n}\n```\n\nOutput -\n\n```java\ninstanceMethod() in Bar\nclassMethod() in Foo\n```\n\nWe are using the same instance to access both the methods. But since one is overriding and the other is hiding, we see different behaviours.\n\n- In case of instance method-\n\n    At runtime, JVM uses the instance 'f' to determine which method to run.\n\n    JVM sees at runtime, that 'f' is actually an instance of Bar, so it calls the method in Bar rather than the one in Foo.\n\n- In case of class (static) method-\n\n    Since, its a static method, JVM doesn't expect or need any instance to invoke that method. Even if you provide it with an instance like we did here, it will simply ignore it. It will just see the declaration of that instance, determine the declared type of it to determine which method to call. All of this, at compile-time.\n\n    It doesn't matter when at runtime, its decided that f is actually an instance of Bar. That's what we mean when we say a static method does not have run-time polymorphism.\n\n    Because of this difference in behaviour in static and instance methods, we use different terms - \"overriding\" for instance methods and \"hiding\" for class methods.\n\n    And when we say, you can't override a static method, it means you can write the code that looks like a static method being overridden, but it won't behave like an overridden method.\n\n*Notice that [[paradigm.oo.components.modifiers.static.access using objects]] is possible*\n\n[[paradigm.oo.components.modifiers.static.overriding.fail]]\n\n\n[//begin]: # \"Autogenerated link references for markdown compatibility\"\n[Method Overriding]: <Method Overriding> \"Method Overriding\"\n[Runtime Polymorphism -- When you override - you get it -- when you hide - you don't]: <Runtime Polymorphism -- When you override - you get it -- when you hide - you don't> \"Runtime Polymorphism or Dynamic Method Dispatch -- When you override - you get it -- when you hide - you don't\"\n[//end]: # \"Autogenerated link references\"","n":0.043}}},{"i":332,"$":{"0":{"v":"Open Recursion","n":0.707},"1":{"v":"\n\nWhen a method within an object invokes another method of the same object via [[paradigm.oo.context.object.self-reference]], it is considered open recursion.\n\nThe key feature here is that the method to be called is determined by [[paradigm.oo.principles.polymorphism.runtime]].","n":0.171}}},{"i":333,"$":{"0":{"v":"Context","n":1}}},{"i":334,"$":{"0":{"v":"Object Context","n":0.707},"1":{"v":"\n\nObject related - can't be used in static areas.\n\nSome keywords which are meant specifically for objects can't be used in static areas, for example, the main method.\n\n![[paradigm.oo.context.object.qualifiers#a-note-on-object-context-qualifiers]]","n":0.192}}},{"i":335,"$":{"0":{"v":"Super","n":1},"1":{"v":"\n\n`super` - used to access members of parent class.\n\n[[paradigm.oo.context.object]]","n":0.333}}},{"i":336,"$":{"0":{"v":"Self Reference","n":0.707},"1":{"v":"\n\nUsed to access members of current class.\n\n[[paradigm.oo.context.object]]\n\n\n## References\n\n[When should I use \"this\" in a class? - StackOverflow](https://stackoverflow.com/questions/2411270/when-should-i-use-this-in-a-class)","n":0.243}}},{"i":337,"$":{"0":{"v":"Object Context Qualifiers","n":0.577},"1":{"v":"\n# A note on Object Context Qualifiers\n\nYou'll find this term being used at some places in these notes. The term \"Object Context Qualifiers\" is not used anywhere generally and is not a \"real\" Computer Science term, AFAIK. Its a term I use for my understanding to refer to keywords which are used to discern or \"qualify\" the context of a member in an object, that is, to identify if a member being referred to is a member of the current class of the object, or its superclass.\n\n## Reasons why it makes sense\n\n1. [[dev.lingo.identifiers.qualifier]]s do refer to lexical tokens which are used to remove ambiguity while identifying entities. So that's where this comes from.\n2. Another reason is Java's [[lang.java.paradigms.oo.inner class.member.qualified this]].\n3. These keywords are used in object contexts, not static ones.","n":0.088}}},{"i":338,"$":{"0":{"v":"Components","n":1}}},{"i":339,"$":{"0":{"v":"Modifiers","n":1}}},{"i":340,"$":{"0":{"v":"Static","n":1},"1":{"v":"\n\n## Ownership\n\nStatic members and methods are owned by the class itself, not any object.\n\n## Accessing\n\n- You don't need to create an instance or object to access static members.\n\n    You can access them through class.\n\n- [[paradigm.oo.components.modifiers.static.access using objects]]\n\n\n## Initialization in program memory\n\nStatic members are loaded into program memory along with the class. Even before initializing any objects.\n\n## Static stuff\n\n- [[paradigm.oo.components.modifiers.static.variable]]\n- [[paradigm.oo.components.modifiers.static.method]]\n","n":0.129}}},{"i":341,"$":{"0":{"v":"Static Variable","n":0.707},"1":{"v":"\n\n## Use case\n\n- Rarely used other than being declared as constants (final)\n- most static variables are declared public since they must be available for users of the class.\n\n## Declaration\n\nClass variables/static variables declared in a class but outside any method, constructor or block.\n\n## Serialization\n\n[[paradigm.oo.components.modifiers.static.variable.serialization]]\n","n":0.152}}},{"i":342,"$":{"0":{"v":"Static Variable can't be serialized","n":0.447},"1":{"v":"\n\nIf there is a static data member in the class, it will not be serialized as static members belong to the class and not the object.","n":0.196}}},{"i":343,"$":{"0":{"v":"Static Method Can't be overridden","n":0.447},"1":{"v":"\n\nYou can't override a [[paradigm.oo.components.modifiers.static.method]].\n\n```java\n//Can't do this -> Compile time error\nclass Foo {\n    public static void method() {\n        System.out.println(\"in Foo\");\n    }\n}\n \nclass Bar extends Foo {\n    public void method() {\n        System.out.println(\"in Bar\");\n    }\n}\n```\n\nThen [[paradigm.oo.components.modifiers.static.overriding.fail]]","n":0.171}}},{"i":344,"$":{"0":{"v":"Why compiler sometimes talks about overriding static methods?","n":0.354},"1":{"v":"\n\nIt means hiding.\n\nFrom [Overriding v/s Hiding - sanaulla.info](https://sanaulla.info/2008/02/29/overriding-vs-hiding/)\n> Sometimes you will see error messages from the compiler that talk about overriding static methods. Apparently, whoever writes these particular messages has not read the Java Language Specification and does not know the difference between overriding and hiding. So they use incorrect and misleading terlminology. Just ignore it. The Java Language Specification is very clear about the difference between overriding and hiding, even if the compiler messages are not. Just pretend that the compiler said \"hide\" rather than \"override\".","n":0.107}}},{"i":345,"$":{"0":{"v":"Static Method","n":0.707},"1":{"v":"\n\nA [[paradigm.oo.components.modifiers.static]] method\n\n- belongs to the class rather than the object of a class.\n- can be invoked without the need for creating an instance of a class.\n- can access static data member and can change the value of it.\n- cannot be abstract because they can't be overridden.\n- [[paradigm.oo.components.modifiers.static.overriding]]\n- [[paradigm.oo.components.modifiers.static.method.accessing instance variables]]\n","n":0.14}}},{"i":346,"$":{"0":{"v":"Static Methods can't access instance(non-static) variables","n":0.408},"1":{"v":"\n\n```java\nclass A{\n    int x;\n    public static void func(){\n        x++; //Error\n    }\n}\n```\n\nWhen you right this, the method doesn't know which 'x' to call. In case of a non-static method, it is understood that its this.x - it is implicit. But in static context, there is no 'this'.\n\nHowever, if you tell it the object, it can work. But again, this object will be static.\n\n```java\nclass A{\n    int x;\n    static A a = new A(); //static object\n    public static void func(){\n    a.x++; //Works fine\n    }\n}\n```\n","n":0.111}}},{"i":347,"$":{"0":{"v":"Accessing Static Members using Objects","n":0.447},"1":{"v":"\n\nIts possible to write f.classMethod(). It is legal but a bad idea, since it causes confusion. The instance is not important in case of class methods. Only the declared type of 'f' matters.\n\nIts better to write Foo.classMethod() or Bar.classMethod(). This not only makes it clear which class method you would like to call. But also, that it is indeed a class method which you're calling.\n\nOf course, all this could be avoided by simply trying to not overide your static methods. You know, because [[paradigm.oo.components.modifiers.static.overriding]].","n":0.109}}},{"i":348,"$":{"0":{"v":"Final","n":1},"1":{"v":"\n\n\n## Final method\n\nCan't be overridden\n\n## Final class\n\n- Can't be inherited\n- Are all methods final in a final class?\n\n    Class can't be inherited — how will you override?\n\n- If class is final and abstract — it should have static components only\n\n    Doesn't make sense to have instance components if it can't be instantiated or inherited.\n","n":0.136}}},{"i":349,"$":{"0":{"v":"Default","n":1},"1":{"v":"\nDefault modifer, used for **methods**, helps define default implementations to certain methods within the interface itself.\n\nThe primary purpose for this feature is to allow adding certain default behaviour to future versions of an interface without breaking the existing functionality and supporting backward compatibility.\n\nThis is not present in all OO languages though.\n\n\n```java\n\npublic interface MyInterface {\n    void existingMethod(); // Abstract method\n\n    // Default method with implementation\n    default void newDefaultMethod() {\n        System.out.println(\"This is a default method.\");\n    }\n}\n```","n":0.116}}},{"i":350,"$":{"0":{"v":"Access Specifiers","n":0.707},"1":{"v":"\n\n## Public\n\n- Any program/ function outside the class can access.\n- Generally given to methods\n\n## Protected\n\n- Visible within class and its subclasses\n\n## Private\n\n- Only methods inside class can access.\n- Generally given to attributes\n","n":0.177}}},{"i":351,"$":{"0":{"v":"Abstract","n":1},"1":{"v":"\n\n\n- Not implemented\n- No functionality/behaviour","n":0.447}}},{"i":352,"$":{"0":{"v":"Abstract Class","n":0.707},"1":{"v":"\n\n- [[paradigm.oo.components.modifiers.abstract]] [[paradigm.oo.components.class]]es define blueprints for its child classes. \n- May or may not include [[paradigm.oo.components.modifiers.abstract]] methods\n- It can't be initialised. ","n":0.218}}},{"i":353,"$":{"0":{"v":"Object","n":1},"1":{"v":"\n\nAn object is an #instance-of a [[paradigm.oo.components.class]].\n","n":0.378}}},{"i":354,"$":{"0":{"v":"Serialization of Objects","n":0.577},"1":{"v":"\n\n- Mechanism of writing the state of an object into a byte stream.\n- Converting state of an object into a form that can be persisted or transported.\n- [[paradigm.oo.components.modifiers.static.variable.serialization]]\n- Serialization with [[paradigm.oo.principles.inheritance]]\n\n    If parent is serializable, so is child.\n\n- Serialization with [[paradigm.oo.principles.association.aggregation]]\n\n    If a serializable class has reference to another class, all references must be serializable\n","n":0.135}}},{"i":355,"$":{"0":{"v":"Deserialization","n":1},"1":{"v":"\n\nReverse operation of [[paradigm.oo.components.object.serialization]] where byte stream is converted into object.\n","n":0.302}}},{"i":356,"$":{"0":{"v":"Object Cloning","n":0.707},"1":{"v":"\n\n## Shallow Cloning\n\n```java\nA obj = new A();\nobj.i = 5;\nobj.j = 6;\n\nA obj1 = obj; //Shallow cloning\n```\n\nThe object is only one. We have just created two references to the same object.\n\n## Deep Cloning\n\n```java\nA obj1 = new A();\nobj1.i = obj.i;  //Deep\nobj1.j = obj.j;  //Cloning\n```\n\n- We create a new object and manually copy all members one by one.\n- Not very efficient if there are too many data members.\n","n":0.124}}},{"i":357,"$":{"0":{"v":"Members of a class","n":0.5},"1":{"v":"\n\nMembers of class are entities which are part of the class. These can be categorised on basis of ownership and on basis of their type.\n\n## Categorisation 1: Based on ownership\n\n- **instance**: instance members belong to the object\n- **static**: static members belong to the class\n\n## Categorisation 2: Based on type\n\n- **data**: data members are -\n  - variables\n  - constants\n  in a class\n- **method**: member methods are methods specified in a class\n\nYou can pair any of the categories in categorisation 1 with any of the categories in categorisation 2 to refer to a member of a class more specifically. For example, instance data member, static method, instance member variable etc.  \n\n```java\nclass Box\n {\n   private int length, breadth, height;\n  public void setDimension(int l, int b, int h)\n   { length=l; breadth=b; height=h;}\n  public void showDimension()\n  {\n  System.out.println(“L = ”+length);\n  System.out.println(“B = ”+breadth);\n  System.out.println(“H = ”+height);\n  }\n}\n```\n\nLength, breadth, height will be called instance member variables as they will be created only when an instance(object) of a class is created. Similarly, setDimension() and showDimension() are called instance member functions.\n","n":0.076}}},{"i":358,"$":{"0":{"v":"Interface","n":1},"1":{"v":"\n\nCompletely abstracted blueprint of an object with no behavior details whatsoever.","n":0.302}}},{"i":359,"$":{"0":{"v":"Covariant Return Type","n":0.577},"1":{"v":"\n\nWhen [[type theory.variance]] of return types if covariant.\n\n\nTwo examples where this can work -\n\n- Suppose there are two classes A and B. A has a function with return type A and B has the function with the same name and arguments but with return type B. The function in B can override the one in A in this situation.\n- Suppose there are four classes A, B, C and D. A is inherited by C and B is inherited by D. Now C has a function with return type A and D has a method with same name and arguments with return type B. Method overriding works here.\n\nBasically, the parent return type is being replaced by child return type in the overriding method.\n","n":0.091}}},{"i":360,"$":{"0":{"v":"Class","n":1},"1":{"v":"\n\n\n- A class is a set of objects that have the same structure and exhibit the same behavior.\n- A class provides a blueprint for all objects based on this class.\n- A class is made up of components, such as attributes, methods, events, constants, types, and implemented interfaces.\n","n":0.147}}},{"i":361,"$":{"0":{"v":"Inner Class","n":0.707},"1":{"v":"\n\nClass inside a class.\n\n## Accessibility\n\nBoth inner and outer classes can access each other's members, regardless of the [[paradigm.oo.components.modifiers.access]].","n":0.236}}},{"i":362,"$":{"0":{"v":"Friend Class","n":0.707},"1":{"v":"\n\n- Can access private and protected member of a class.\n- Class specifies its friends, not the other way round.\n- Friendships are not inherited — Friends of parents are not friends of children.\n","n":0.177}}},{"i":363,"$":{"0":{"v":"Principles","n":1},"1":{"v":"\n## 4 Pillars and 1 secret basement of OOPS\n\n1. [[lang.java.paradigms.oo.encapsulation]]\n2. [[lang.java.paradigms.oo.inheritance]]\n3. [[lang.java.paradigms.oo.polymorphism]]\n4. [[paradigm.oo.principles.abstraction]]\n\n\n[Basement] - [[paradigm.oo.principles.association]]\n\n","n":0.258}}},{"i":364,"$":{"0":{"v":"Polymorphism","n":1},"1":{"v":"\n\n## What is it?\n\n- Many forms\n- Methods with same name can be used for different purposes\n\n## Implemented By\n\n- [[paradigm.oo.principles.polymorphism.overloading]]\n- [[paradigm.oo.principles.polymorphism.overriding]]\n\n## Why Polymorphism?\n","n":0.213}}},{"i":365,"$":{"0":{"v":"Runtime Polymorphism","n":0.707},"1":{"v":"\n\nMethod [[paradigm.oo.principles.polymorphism.overriding]] + [[paradigm.oo.features.binding.dynamic]] = **Runtime Polymorphism**\n\naka **Dynamic Method Dispatch**.\n\n- Method Overriding - Which Method to call depends on object type\n- ++\n- Dynamic Binding - Object type determined at runtime\n- => Which method to call - decided at runtime\n- -> Runtime Polymorphism\n\n\n## Object being referred to determines the version of method to be called\n\nThe object being referred to (not the reference variable) determines the version of method to be called.\n\nSo in this example, if Student has a method overriding a method in Human. Student's method will be called because even though h is an object of Human, it is referring to an object of Student.\n\n```java\nHuman h = new Student();\nh.overriddenMethod();\n```\n\n## References\n\n[GFG - Dynamic Method Dispatch or Runtime Polymmorphism in Java](https://www.geeksforgeeks.org/dynamic-method-dispatch-runtime-polymorphism-java/)\n","n":0.092}}},{"i":366,"$":{"0":{"v":"Overriding","n":1},"1":{"v":"\n\nWhen a child class has same method as that of a parent class, that method is said to override the parent's method.\n\n## How can it be achieved?\n\n- Method must have same name as parent\n- Same parameter as parent\n- Return type must be same or have an IS-A relationship with parent method's return type [[paradigm.oo.components.covariant return type]].\n- Overridden method should not be more restrictive than parent method.\n","n":0.123}}},{"i":367,"$":{"0":{"v":"Exception declaration with Method overriding","n":0.447},"1":{"v":"\nIf a language supports [[dev.issues.exception.declaration]], this is how it likely works with method overriding.\n\n## Case 1: Super class doesn't declare an exception\n\nSub class overridden method:\n\n- cannot declare a [[dev.issues.exception.types.checked]] but\n- can declare an [[dev.issues.exception.types.unchecked]].\n\n## Case 2: Super class declares an exception\n\nSub class overridden method\n\n- can declare\n  - same exception\n  - subclass exception ([[type theory.variance]] = covariant)\n  - or no exception\n  but\n- cannot declare parent exception\n","n":0.124}}},{"i":368,"$":{"0":{"v":"Overloading","n":1},"1":{"v":"\n\nWhen a token can be used for multiple purposes. Typically used in context of  methods i.e. **method overloading**.\n\n## Method overloading \n\nWhen multiple methods have same signature and are called according to the arguments passed.\n\n### How can it be achieved?\n\n- Using different data types of parameters\n- Using variable count of parameters\n","n":0.141}}},{"i":369,"$":{"0":{"v":"Inheritance","n":1},"1":{"v":"\nMechanism through which an object acquires all the properties and methods of its parent\n\n## What kind of relationship?\n\nIS - A\n\n## What is inherited?\n\n>💡 By inherited, it is meant that these fields and methods are part of of the subclass, as if the subclass had declared them itself.\n\nWhen a subclass inherits a superclass, all protected and public fields and methods of the superclass are inherited by the subclass.  Protected and public fields can be called and referenced just like the methods declared directly in the subclass.\n\nPrivate fields and methods of the superclass can never be referenced directly by subclasses. They can, however, be referenced indirectly via methods reachable from the subclass (e.g default (package), protected and public methods).\n\n## Types of Inheritance\n\n- [[paradigm.oo.principles.inheritance.types.single]]\n- [[paradigm.oo.principles.inheritance.types.multilevel]]\n- [[paradigm.oo.principles.inheritance.types.multiple]]\n- [[paradigm.oo.principles.inheritance.types.hierarchical]]\n- [[paradigm.oo.principles.inheritance.types.hybrid]]\n\n","n":0.089}}},{"i":370,"$":{"0":{"v":"Types","n":1}}},{"i":371,"$":{"0":{"v":"Single Inheritance","n":0.707},"1":{"v":"\n\n```mermaid\nclassDiagram\n    A <|-- B\n```","n":0.5}}},{"i":372,"$":{"0":{"v":"Multiple Inheritance","n":0.707},"1":{"v":"\n\n```mermaid\nclassDiagram\n    A <|-- C\n    B <|-- C\n```","n":0.378}}},{"i":373,"$":{"0":{"v":"Multiple Inheritance not allowed","n":0.5},"1":{"v":"\n\n- [[paradigm.oo.principles.inheritance.types.multiple]] is not allowed in some languages\n- However, multiple interfaces can be implemented\n\n## Why is Multiple inheritance not allowed?\n\n- To reduce complexity and simplify the language\n- **Diamond problem**: Results in ambiguity\n    ```mermaid\n    classDiagram\n        A <|-- B\n        A <|-- C\n        B <|-- D\n        C <|-- D\n        class A{ foo() }\n        class B{ foo() }\n        class C{ foo() }\n        class D{ which foo() } \n    ```\n- Creates problem during various operations like casting, constructor chaining\n- Very few scenarios in which multiple inheritance is required\n\n## Why is multiple inheritance allowed in interfaces?\n\nNo ambiguity - implementation is not given by interfaces\n\n## References\n\n[Diamond Problem - StackOverflow](https://stackoverflow.com/questions/2064880/diamond-problem)","n":0.099}}},{"i":374,"$":{"0":{"v":"Multilevel Inheritance","n":0.707},"1":{"v":"\n\n```mermaid\nclassDiagram\n    A <|-- B \n    B <|-- C\n```","n":0.354}}},{"i":375,"$":{"0":{"v":"Hybrid Inheritance","n":0.707},"1":{"v":"\n\n\n```mermaid\nclassDiagram\n    A <|-- B\n    A <|-- C\n    B <|-- D\n```","n":0.316}}},{"i":376,"$":{"0":{"v":"Hierarchical Inheritance","n":0.707}}},{"i":377,"$":{"0":{"v":"Purpose of Inheritance","n":0.577},"1":{"v":"\n\n\n- [[type theory.subtyping]]: Also see [[arch.design.oo.principles.solid.liskov]]\n  - Straightforward [[paradigm.oo.features.open recursion]]\n- [[type theory.subclassing]]: Straightforward Code reuse\n","n":0.258}}},{"i":378,"$":{"0":{"v":"Disadvantages of Inheritance","n":0.577},"1":{"v":"\n\n1. You can't change the implementation provided by superclass at runtime. Inheritance is defined at compile time.\n2. Inheritance is said to \"break encapsulation\" by exposing a subclass to protected members of parent class\n3. Leads to child class being tightly coupled with parent class. Changes in parent class will lead to changes in subclass.\n4. Excessive deep inheritance trees can make inheritance stack very deep and confusing.\n\n## References\n\n[Prefer composition over inheritance? - Stack Overflow](https://stackoverflow.com/questions/49002/prefer-composition-over-inheritance)\n","n":0.118}}},{"i":379,"$":{"0":{"v":"Encapsulation","n":1},"1":{"v":"\n\nWrapping up the data in a single unit.\n\n## Implemented by \n\n[[paradigm.oo.components.class]]es and [[paradigm.oo.components.modifiers.access]].\n","n":0.277}}},{"i":380,"$":{"0":{"v":"Association","n":1},"1":{"v":"\n\nRelation between two classes established through their objects.\n","n":0.354}}},{"i":381,"$":{"0":{"v":"Aggregation","n":1},"1":{"v":"\n\n- Special case of [[paradigm.oo.principles.association]]\n- When a class has another class' object as a data member.\n- Unidirectional association\n- Both entities can survive individually\n- What kind of relationship?\n  - HAS - A\n  - Whole-part relationship\n","n":0.171}}},{"i":382,"$":{"0":{"v":"Composition","n":1},"1":{"v":"\n\n- Special Case of [[paradigm.oo.principles.association.aggregation]].\n- When one class is highly dependent on the other. For example, Library and books.\n- Strong Existence Relation — Composition means that the contained object cannot exist without the aggregation (for example, a car reservation cannot exist without the car rental agency).\n- Lifetime of individual parts = Lifetime of aggregate\n- What kind of relationship?\n  - PART - OF\n  - Existence-dependent whole-part relationship\n","n":0.123}}},{"i":383,"$":{"0":{"v":"Disadvantages of Composition","n":0.577},"1":{"v":"\n\n1. You can't change the implementation provided by superclass at runtime. Inheritance is defined at compile time.\n2. Inheritance is said to \"break encapsulation\" by exposing a subclass to protected members of parent class\n3. Leads to child class being tightly coupled with parent class. Changes in parent class will lead to changes in subclass.\n4. Excessive deep inheritance trees can make inheritance stack very deep and confusing.\n\n## References\n\n[Prefer composition over inheritance? - Stack Overflow](https://stackoverflow.com/questions/49002/prefer-composition-over-inheritance)\n","n":0.118}}},{"i":384,"$":{"0":{"v":"Benefits of Composition","n":0.577},"1":{"v":"\n- [[arch.design.oo.principles.ioc]]: It can benefit from [[arch.design.oo.patterns.di]]. For example, in [[Decorator Pattern]] and [[Proxy Pattern]].\n- [[Combinator]]-oriented programming: Similar to [[Composite pattern]]\n- Readily follows [[Programming to an interface]]\n- Easy [[paradigm.oo.principles.inheritance.types.multiple]]","n":0.186}}},{"i":385,"$":{"0":{"v":"Abstraction","n":1},"1":{"v":"\n\nProcess of hiding implementation details and showing only functionality to user.\n\n## Implemented by\n\n[[paradigm.oo.components.modifiers.abstract]] components like\n[[paradigm.oo.components.interface]]s and [[paradigm.oo.components.modifiers.abstract.class]]es.\n\n### How do interface and Abstract class achieve abstraction?\n\nIf you're returning an object through an API, you simply pass them an object of the interface, not the class.\n\nThe class(implementation) is useless information, the interface is all the consumer will need.\n\n## References\n\n- [Stack Overflow - How abstract class and interface achieve abstraction in java?](https://stackoverflow.com/questions/62646660/how-abstract-class-and-interface-achieve-abstraction-in-java)\n  > Typically, the approach is that you only show the user the interface of the object you're passing back to them, instead of the precise class that implements that interface. The interface is the essential implementation, the exact class is unnecessary information.\n\n","n":0.095}}},{"i":386,"$":{"0":{"v":"Leaky Abstractions","n":0.707},"1":{"v":"\nWhen consumers have to know the internals in order to consume a system properly.","n":0.267}}},{"i":387,"$":{"0":{"v":"Language Classification based on Paradigm","n":0.447},"1":{"v":"\n\nSome languages make it easy to write in one some paradigms compared to others. Which is why, paradigms are often seen as classification for programming languages. However, many programming languages can't be strictly classified into one paradigm.\n","n":0.164}}},{"i":388,"$":{"0":{"v":"Imperative","n":1},"1":{"v":"\n\n| Imperative                         | [[paradigm.declarative]]                  |\n|------------------------------------|------------------------------|\n| You say *how* to get what you want | You just say *what* you want |\n\n## Imperative\n\n```csharp\nList<int> results = new List<int>();\nforeach(var num in collection)\n{\n    if (num % 2 != 0)\n          results.Add(num);\n}\n```\n\nHere, we're saying:\n\n1. Create a result collection\n2. Step through each number in collection\n3. Check the number. If its odd, add it to the results\n","n":0.13}}},{"i":389,"$":{"0":{"v":"Functional Programming","n":0.707},"1":{"v":"\n> Computations are evaluation of mathematical functions.\n\n- Based on the above foundational statement.\n    \n> 💡Although, (mathematical) computations by nature are mathematical functions, so the above statement may sound self-referential. But, computations here mean execution of steps by a computer. These do involve evaluation of mathematical functions generically, but this aspect is more emphasized in functional programming.\n>  \n> Operating within these paradigm means enforcing practices which prioritize this aspect.\n\n- [[paradigm.declarative]] paradigm.\n- [[dev.function]]s are first-class citizens. They can be assigned to variables and passed as an argument.\n\nFunctional programming implements concepts from Mathematical [[dendron://math/analysis.func]]tions in a way which avoid #surprises and promotes concise and readable code.\n\n## Foundational Principles\n\n1. [[paradigm.func.principles.immutability]]\n2. [[paradigm.func.principles.composition]]\n3. [[paradigm.func.principles.recursion]]\n4. [[paradigm.func.principles.lazy]]\n\nThe declarative nature might seem like a simple syntatical sugar, functional programming shines by combining this declarative approach with other principles and features. \n\nAdditionally, passing functions as arguments ensures lazy evaluation. That is, the functions are not evaluated until their results are absolutely needed.\n\n\n## References\n\n- [Why Functional Programming Matters • John Hughes • YOW! 2017](https://youtu.be/JQDRCTa32jY?si=73tfB25rqgdqUhbw)","n":0.078}}},{"i":390,"$":{"0":{"v":"Principles","n":1}}},{"i":391,"$":{"0":{"v":"Recursion","n":1},"1":{"v":"\n- Functional programming favors recursion over loops. \n- Recursion is a natural fit for many functional programming tasks and can lead to more elegant and concise code. Why?   \n\n    => Recursion allows functions to express repetitive behavior without relying on mutable state.\n","n":0.154}}},{"i":392,"$":{"0":{"v":"Lazy Evaluation","n":0.707},"1":{"v":"\n- When expressions are not evaluated until their results are actually needed. \n- More efficient use of resources, especially when dealing with potentially infinite data structures. \n- Promotes modularity and composability.\n\nHowever, this is not supported by all programming languages.","n":0.16}}},{"i":393,"$":{"0":{"v":"Immutability","n":1},"1":{"v":"\nFunctional programming emphasizes immutable data structures, where once a value is assigned, it cannot be changed. Instead of modifying existing data structures, functional programming favors creating new ones. Immutability reduces the risk of unexpected side effects and makes programs easier to reason about.\n\nThe functions themselves do not operate on the existing data structures, but you could work around it and mutate the data structure by doing something like:\n\n```python\nnumbers = filter(lambda x: x % 2 == 0, numbers)\n```\n\nThis mutates the original data structure. But in the paradigm which is functional programming, this is generally avoided. Instead we create new data structures, promoting clarity, predictability and reasoning about the code.\n","n":0.096}}},{"i":394,"$":{"0":{"v":"Function Composition","n":0.707},"1":{"v":"\nFunction composition is when output of one function is input to another. \n\nFunctional programming encourages composing functions together to create new functions. This involves chaining functions together, where the output of one function becomes the input of another. Function composition allows for the creation of complex behaviors from simpler building blocks and promotes code reuse and modularity.","n":0.132}}},{"i":395,"$":{"0":{"v":"Components","n":1}}},{"i":396,"$":{"0":{"v":"Pure Functions","n":0.707},"1":{"v":"\n[[dev.function]]s which are [[dendron://math/analysis.func.char.idempotent]] and [[dendron://math/analysis.func.char.deterministic]].\n\nThey do not rely on or modify external state, making them easier to test and reason about.","n":0.213}}},{"i":397,"$":{"0":{"v":"Lambda","n":1},"1":{"v":"\nLambdas are [[dev.lingo.expressions]]s used to write concise [[dev.lingo.function.anonym]].","n":0.354}}},{"i":398,"$":{"0":{"v":"Higher Order Function","n":0.577},"1":{"v":"\nFunctions that take other functions as arguments or return them as results.","n":0.289}}},{"i":399,"$":{"0":{"v":"Event Driven","n":0.707},"1":{"v":"\n\n\n- Programming paradigm in which the flow of the program is determined by events such as user actions (mouse clicks, key presses), sensor outputs, or message passing from other programs or threads.\n- Event-driven programming is the dominant paradigm used in graphical user interfaces and other applications (e.g., JavaScript web applications) that are centered on performing certain actions in response to user input. This is also true of programming for device drivers (e.g., P in USB device driver stacks).\n","n":0.113}}},{"i":400,"$":{"0":{"v":"Main Loop","n":0.707},"1":{"v":"\n\n\nIn an [[paradigm.event driven]], the applications generally have a main loop that listens for events and then triggers a callback function when one of those events is detected. In embedded systems, the same may be achieved using hardware interrupts instead of a constantly running main loop. Event-driven programs can be written in any programming language, although the task is easier in languages that provide high-level abstractions, such as await and closures.\n\n## References\n","n":0.118}}},{"i":401,"$":{"0":{"v":"Declarative","n":1},"1":{"v":"\n\n| [[paradigm.imperative]]                         | Declarative                  |\n|------------------------------------|------------------------------|\n| You say *how* to get what you want | You just say *what* you want |\n\n\n## Declarative\n\n```csharp\nvar results = collection.Where( num => num % 2 != 0);\n```\n\nHere we're saying:\n\n=> Give everything where its odd.\n\n\nDeclarative and [[paradigm.func]] usually go hand-in-hand. For specifying _what_ you want, you usually need to paas a function as an argument, which requires [[paradigm.func.components.higher-order]]s. Some higher order functions are usually provided by languages which adhere to these paradigms, to express some common computation and iteration patterns.\n\nInternally, these functions might iterate over the objects, where it is specified \"how to do\" something, but the key distinction lies in the usage in productive code, where you are declaring your demands.\n\nThese features and abstractions enable concise, expressive and maintainable code.","n":0.089}}},{"i":402,"$":{"0":{"v":"Attribute Oriented Programming (@OP)","n":0.5},"1":{"v":"\n`@OP` or Attribute Oriented Programming allows a programmer to embed metadata(attributes) in the code using annotations, directives etc.\n\n## References\n\n[Applying Code Generation Techniques to the J2EE Development](https://www.informit.com/articles/article.aspx?p=389718&seqNum=4)\n[Are Annotations generally realized with AOP and can they \"do\" Depedency Injection? - StackOverflow](https://stackoverflow.com/questions/6110266/are-annotations-generally-realized-with-aop-and-can-they-do-depedency-injectio)\n","n":0.16}}},{"i":403,"$":{"0":{"v":"Executions","n":1},"1":{"v":"\nA set of instructions/tasks being carried out. Could be a program, process, pipeline or anything.\n\nThe principles applied to designing and running all these sets of instructions could be same though,","n":0.183}}},{"i":404,"$":{"0":{"v":"Messaging","n":1}}},{"i":405,"$":{"0":{"v":"Params Passing","n":0.707}}},{"i":406,"$":{"0":{"v":"By Value","n":0.707},"1":{"v":"\n\nCalling/passing by value -- A copy of the original variable is sent to the method and not the original one, so any changes applied inside the method are actually affecting the copy version, not the original.\n","n":0.167}}},{"i":407,"$":{"0":{"v":"By Reference","n":0.707},"1":{"v":"\n\nCalling/passing by reference - A reference or a pointer to the original variable is passed to the method and not the original variable data. Any change made to variable inside method is reflected in the original variable.\n","n":0.164}}},{"i":408,"$":{"0":{"v":"Scheduling","n":1}}},{"i":409,"$":{"0":{"v":"Time Slicing","n":0.707},"1":{"v":"\n\nTask executes for a predefined slice of time and then re-enters pool of ready tasks.\n\nNext task decided based on priority and other factors.","n":0.209}}},{"i":410,"$":{"0":{"v":"Pre Emptive Scheduling","n":0.577},"1":{"v":"\n\nHighest priority task executed until -\n\n-   It goes into wait/dead state\n-   Higher priority task comes","n":0.258}}},{"i":411,"$":{"0":{"v":"Synchronicity","n":1}}},{"i":412,"$":{"0":{"v":"Synchronous","n":1},"1":{"v":"\nCaller sends a request and waits for it to get completed. Meanwhile, caller is blocked and resumes only when the receiver responds.\n\nCaller and receiver are in \"sync\".\n\n## Example\n\n- Program asks OS to read from disk\n    - Program main thread is taken off of the CPU\n    - Read completes, program can resume execution\n- Phone call/meetings","n":0.136}}},{"i":413,"$":{"0":{"v":"Asynchronous","n":1},"1":{"v":"\nCaller sends a request and does other work while the receiver responds.\n\n## How to know when request is ready?\n\n- Polling\n- Pushing\n- A separate [[execution.synchronicity.sync]] thread that is blocked.\n\n\n## Example\n\n- File read\n    - A secondary thread is spun-up to read this file\n    - Main thread still in CPU, unblocked.\n- Email","n":0.143}}},{"i":414,"$":{"0":{"v":"Process","n":1},"1":{"v":"\n\nProcess is a set of instructions.\n\n- May or may not fail, but we don't rollback the entire process.\n- Each process is allocated a seperate memory area      \n- Process is heavyweight\n- Cost of communication b/w processes is high\n- Switching from one process to another takes some time\n- Process is meaningful even if some of it is completed. \n\nHence, process is never rolled back completely, but transaction is rolled back completely if it fails.\n","n":0.118}}},{"i":415,"$":{"0":{"v":"Transaction","n":1},"1":{"v":"\nSet of instruction which performs some logical work grouped into a single execution unit. If any task fails, the whole transaction fails. Therefore, a transaction is either successful or failure. There is no in between.\n\nBoth transaction and process are sets of instructions but a process is meaningful even if some of it is completed. Meanwhile, a transaction is a [[execution.process]] which has no meaning if half of it is completed. It is either completed or failed.\n\nHence, process is never rolled back completely, but transaction is rolled back completely if it fails.\n\n## Transactions are performed on buffer\n\nAll operations in a transaction are performed on a buffer which is a copy of the database or record. So even if a transaction fails any stage, the buffer is removed and the database remains unaffected. If it is successful the data will be copied.\n\n\n## Transaction States\n\n- **Active**: Transaction is going on\n- **Partially committed**: After R/W operations\n- **Failure**: Can go to this state from Active or from partially committed.\n- **Aborted**: The step after failure\n- **Committed**: The step after partially committed if storing permanently is successful - no rollback from here.\n- **Terminated**: Transaction ended.\n\n\n## Result of Concurrent Transactions\n\n- Waiting time 👇🏽\n- Response time 👆🏽\n- Resource Utilization 👆🏽\n- Efficiency 👆🏽\n\n## Dirty Read\n\nWhen a transaction is allowed to read a row which is modified by another transaction but not yet commited, dirty read occurs.\n\nDirty read can result in wrong values in database if the first transaction's commit fails.\n","n":0.065}}},{"i":416,"$":{"0":{"v":"ACID","n":1},"1":{"v":"\n\nA transaction should have the following properties:\n\n- **Atomicity**: Either executed fully or none.\n- **Consistency**: If database was consistent before transaction, it should remain consistent afterwards.\n- **Isolation**: Logical isolation - two transactions shouldn't affect each other\n- **Durability**: If a transaction is executed it should persist in the system irrespective of hardware/software failures.\n\n$$$\n    AID => C\n$$$\n","n":0.136}}},{"i":417,"$":{"0":{"v":"Thread","n":1},"1":{"v":"\n\nA lightweight, sub process - the smallest unit of processing - a separate path of execution.\n\n- Threads share the same address space\n- Lightweight\n- Cost of communication b/w threads is low","n":0.183}}},{"i":418,"$":{"0":{"v":"Life Cycle","n":0.707},"1":{"v":"\n\nStages in life of a program/execution.\n\n- [[execution.lifecycle.design]]\n- [[execution.lifecycle.build]]\n- Link time\n- Distribution time\n- Installation time\n- Load time\n- [[execution.lifecycle.runtime]]\n\n## References\n\n[Wikipedia](https://en.wikipedia.org/wiki/Program_lifecycle_phase#:~:text=Program%20lifecycle%20phases%20are%20the,load%20time%2C%20and%20run%20time.)\n","n":0.236}}},{"i":419,"$":{"0":{"v":"Runtime","n":1},"1":{"v":"\n\nCan be used for phase or environment when or where a program is running.\n","n":0.267}}},{"i":420,"$":{"0":{"v":"Design (Edit) time","n":0.577}}},{"i":421,"$":{"0":{"v":"Build time","n":0.707},"1":{"v":"\nIncludes compilation and other additional steps to prepare the 'execution'.\n\n- Compiling the source code (which includes compile time)\n- Linking compiled code with libraries or other necessary files\n- Running tests\n- Packaging the final executable program along with any additional resources it needs","n":0.156}}},{"i":422,"$":{"0":{"v":"Concurrent","n":1},"1":{"v":"\n\nConcurrency is when multiple computations are *in progress* at a time. Although only one computation is being executed at an instant. \n\n## References\n- [Concurrent Computing - Wikipedia](https://en.wikipedia.org/wiki/Concurrent_computing)\n- [Concurrency vs. Parallelism — A brief view](https://medium.com/@itIsMadhavan/concurrency-vs-parallelism-a-brief-review-b337c8dac350)","n":0.171}}},{"i":423,"$":{"0":{"v":"Synchronization","n":1},"1":{"v":"\nIts mechanism of coordinating events to occur at the same time.\n\nIt usually involves mechanisms like locks etc, which slows down the execution a little.\n","n":0.204}}},{"i":424,"$":{"0":{"v":"Parallel","n":1},"1":{"v":"\n\nParallelism is when multiple computations are *executed* at a time. Therefore at any instant, multiple executions are ongoing simultaneously. \n\nParellel computing doesn't need multiple tasks. Even one task can be split up into multiple sub-tasks and be assigned to different cores of the processor.\n\n\n[**The Art of Concurrency**](http://shop.oreilly.com/product/9780596521547.do) defines the difference as follows:\n\n> _A system is said to be_ concurrent _if it can support two or more actions_ in progress _at the same time. A system is said to be_ parallel _if it can support two or more actions executing simultaneously._\n\n## References\n\n- [Parallel Computing - Wikipedia](https://en.wikipedia.org/wiki/Parallel_computing)\n- [Concurrency vs. Parallelism — A brief view](https://medium.com/@itIsMadhavan/concurrency-vs-parallelism-a-brief-review-b337c8dac350)","n":0.103}}},{"i":425,"$":{"0":{"v":"Multithreading","n":1},"1":{"v":"\n\n- [[execution.process.thread]]-based multitasking - Process of executing multiple Threads simultaneously.\n- Only one thread can run at an instant in a process i.e. multithreading is [[execution.concurrency]].\n\n## Advantages\n\n- Doesn't block the user\n- Saves time by performing many operations together\n- Threads are independent. Failure of one doesn't affect another.\n\n","n":0.147}}},{"i":426,"$":{"0":{"v":"Thread Safety","n":0.707},"1":{"v":"\n1. Stateless Implementation\n    - Source of error in most cases (multithreaded apps)\n        - Incorrectly sharing state between several threads\n        - Don't make your methods rely on external state, nor maintain any state at all\n2. Immutable Implementation\n    - Need to share states between threads → make them immutable\n    - [[arch.design.oo.patterns.immutable class]] = Thread safe\n3. [[execution.concurrency.synchronization]]\n","n":0.136}}},{"i":427,"$":{"0":{"v":"Deadlock","n":1},"1":{"v":"\n\nDeadlock can occur in [[execution.concurrency]] executions when two tasks are waiting for locks acquired by each other.\n","n":0.243}}},{"i":428,"$":{"0":{"v":"Distributed Systems","n":0.707},"1":{"v":"\n## What?\n\n> \"A system in which the failure of a computer you didn't even know existed can render your own computer unusable\" - Leslie Lamport \n\n- Multiple computers/machines typically communicating over a network\n- Can involve all elements of usual [[execution]], but since a network and different environments are getting involved - things get tricky.\n\n## Why?\n\nSome applications are inherently distributed. Example, sending message from your phone to your friend's phone - no two ways about it.\n\nBut other reasons why you may choose to have distributed systems could be:\n\n- Better reliability: Even if one node fails, system as a whole keeps functioning\n- Better performance: Get data from nearby node, rather than one halfway around the world\n- To solve bigger problems: Huge amounts of data - can't fit on one machine\n- Different applications/services talking to each other: Your app might need to talk to other applications or services over network. \n\n## Why NOT?\n\n- Communications can fail -- and we might not even know it.\n- Malicious players\n- Processes themselves may crash - other systems might not be aware of it.\n- All these failures may happen nondeterministically.\n\n## Why study?\n\nThe main challenge of having distributed systems is to keep them **fault tolerant** -- whole system should work despite failures of some parts.\n\n**TIP** If it can be done on one computer -> keep it that way \n\n## References\n\n- [Distributed Systems Lecture Series - Dr. Martin Kleppmann](https://www.youtube.com/watch?v=UEAMfLPZZhE&list=PLeKd45zvjcDFUEv_ohr_HdUFe97RItdiB)","n":0.066}}},{"i":429,"$":{"0":{"v":"Communication","n":1},"1":{"v":"\nCommunication between nodes can be either [[execution.synchronicity.sync]] or [[execution.synchronicity.async]].\n\nThe method to be used is mainly dependent on what kind of [[execution.synchronicity]], [[systems.char.performance.i.latency]] and [[systems.char.performance.i.throughput]] is required in the system. \n","n":0.183}}},{"i":430,"$":{"0":{"v":"API","n":1},"1":{"v":"\nAPIs define the interface or contract of how different nodes in [[dist]] are supposed to interact with each other.","n":0.229}}},{"i":431,"$":{"0":{"v":"RPC","n":1},"1":{"v":"\nRPC is a protocol to implement [[dist.comm.api]]s. It allows a program to execute a [[dev.lingo.function]] on another computer - **as if it were a local function call**. \n\nEmphasis on the last part because that's what RPC emphasizes - abstraction of network call from the developers.\n\n\n## References \n\n- [Distributed Systems 1.3: RPC (Remote Procedure Call) - Dr. Martin Kleppmann](https://www.youtube.com/watch?v=S2osKiqQG9s&t=144s)","n":0.131}}},{"i":432,"$":{"0":{"v":"SOAP","n":1},"1":{"v":"\n- Was first designed so that different languages on different platforms can communicate.\n- Standard protocol\n  - Built-in rules => increases complexity and overhead => longer page load times.\n  - Built-in compliances => ensure security and [[execution.process.transaction.acid]]ity => preferable for enterprise scenarios.\n","n":0.156}}},{"i":433,"$":{"0":{"v":"REST","n":1},"1":{"v":"\n**aka REpresentational State Transfer.**\n\n- Set of **architecture principles** => implementation is up to developers\n- built for web services and mobile applications => lightweight\n- Request for data is usually sent over [[std.web.http]].\n- Return message can be in a variety of formats:\n  - HTML\n  - XML\n  - Plain Text\n  - [[std.web.json]]\n\nApplication is said to be RESTful if it follows these 6 architecture guidelines:\n\n1. [[Client-Server]] architecture composed of clients, servers and resources.\n2. [[Stateless]] client-server communication\n   - No client content is stored in server between requests i.e. requests don't share any client information on server side.\n   - Information about the session's state is held with client\n3. Cacheable data to eliminate the need for some client-server interactions.\n4. Uniform interface between components => information is transferred in a standardized way instead of being application-specific.  \n   > Central feature that distinguishes the REST architectural style from other network-based styles. - Roy Fielding (originator of REST)\n5. A layered system constraint => client-server interactions can be mediated by hierarchical layers.\n6. [[Code on demand]]: Allowing servers to extend the functionality of a client by transferring executable Code.\n    => Also reduces visibility => **Optional**.\n\n","n":0.074}}},{"i":434,"$":{"0":{"v":"Architecture","n":1},"1":{"v":"\n\n- Abstract view of whole system.\n- Architecture represents scaffolding, the frameworks that everything else sits upon.\n- Difficult to change at a later stage — should be scalable.\n\n## References\n\n[Contrasting architecture patterns with design patterns](https://www.oreilly.com/radar/contrasting-architecture-patterns-with-design-patterns/#:~:text=Scaffolding%20versus%20design&text=Architecture%20represents%20scaffolding%2C%20the%20frameworks,at%20different%20levels%20of%20abstraction.)","n":0.174}}},{"i":435,"$":{"0":{"v":"Modelling","n":1}}},{"i":436,"$":{"0":{"v":"Roles","n":1}}},{"i":437,"$":{"0":{"v":"Service","n":1},"1":{"v":"\nEncapsulates business logic of the application.\n","n":0.408}}},{"i":438,"$":{"0":{"v":"Repository","n":1},"1":{"v":"\nSimilar to [[arch.modelling.roles.dao]] in that, it provides abstracts database access. But it is more focused on domain-specific operations instead of simple CRUD or DB operations. Thus, it will usually have more business-centric methods.","n":0.174}}},{"i":439,"$":{"0":{"v":"Entity","n":1},"1":{"v":"\nBusiness Object within the application, usually mapped to a database table.","n":0.302}}},{"i":440,"$":{"0":{"v":"DTO","n":1},"1":{"v":"\n# Data Transfer Object\n\nObject that carries data between components.","n":0.333}}},{"i":441,"$":{"0":{"v":"DAO","n":1},"1":{"v":"\n# Data Access Object\n\nProvides abstract interface to operate and perform CRUD operations on persisted entities.","n":0.258}}},{"i":442,"$":{"0":{"v":"Controller","n":1},"1":{"v":"\nHandles and routes incoming HTTP requests, processes and returns a response.\n\nMaps web requests to the appropriate [[arch.modelling.roles.service]] methods, processes input, and prepares output (e.g., JSON, HTML).","n":0.196}}},{"i":443,"$":{"0":{"v":"Diagramming","n":1},"1":{"v":"\n\n[Fundamental Modeling Concepts](https://www.fmc-modeling.org/home)","n":0.577}}},{"i":444,"$":{"0":{"v":"Architecture Style","n":0.707},"1":{"v":"\n\nAt a very high-level, architecture style tells us how to organize our code. It’s the highest level of granularity and it specifies layers, high-level modules of the application and how those modules and layers interact with each other, the relations between them.\n\n## References\n\n[Architectural Styles vs. Architectural Patterns vs. Design Patterns](https://herbertograca.com/2017/07/28/architectural-styles-vs-architectural-patterns-vs-design-patterns/#:~:text=Architectural%20styles%20tell%20us%2C%20in,other%2C%20the%20relations%20between%20them.)\n\n","n":0.141}}},{"i":445,"$":{"0":{"v":"Microservices","n":1},"1":{"v":"\n\nLoosely-coupled lightweight services each with different resposibilities working together to make an application work.\n\n\nhttps://www.udemy.com/course/design-microservices-architecture-with-patterns-principles/?couponCode=LETSLEARNNOWPP\nhttps://medium.com/design-microservices-architecture-with-patterns/microservices-communications-f319f8d76b71\nhttps://www.architect.io/blog/2023-03-21/microservices-communication/\nhttps://www.sayonetech.com/blog/microservices-communication/","n":0.267}}},{"i":446,"$":{"0":{"v":"Layered Architecture","n":0.707},"1":{"v":"\nDivides the application into distinct layers, each with a different responsibility and role.\n\nTypically seperates the application into:\n\n1. **Presentation layer**: Manages UI\n2. **Service layer**: Orchestration of business logic and workflows. Handles user-requests and transactions.\n3. **Business logic (domain) layer**: Contains business-specific (functional) logic and rules, i.e. validations, calculations etc. \n4. **Data access (persistence) layer**: Interaction with DB\n5. **Infrastructure layer**: System and server etc. \n\n\n","n":0.127}}},{"i":447,"$":{"0":{"v":"Architecture Pattern","n":0.707},"1":{"v":"\n- An Architectural Pattern is a way to implement an [[arch.style]].\n- Going by the definition of [[arch]] and [[concepts.pattern]]. Architecture patterns are solutions which can be implemented for common system level problems.\n\n## Examples of questions it can involve\n\n- What classes will we have and how will they interact, in order to implement a system with a specific set of layers?\n- What high-level modules will have in our Service-Oriented Architecture and how will they communicate?\n- How many tiers will our Client-server Architecture have?\n\n## Impact\n\n- **Horizontal**\n    i.e.. how to structure the code inside a layer\n\n- **Vertical**\n    i.e. how a request is processed from the outer layers into the inner layers and back\n","n":0.095}}},{"i":448,"$":{"0":{"v":"Concurrency","n":1}}},{"i":449,"$":{"0":{"v":"Thread Pool","n":0.707},"1":{"v":"\naka **Replicated Workers** or **Worker-crew** model.\n\n## Problem\n\n- Frequent creation and destruction of threads for short-lived tasks can be expensive.\n\n## Solution\n\n- Maintain multiple threads waiting for a task to be assigned.\n- Queue the tasks and assign them to worker threads\n- Add tasks to completed tasks queue.\n\n```mermaid\nflowchart LR\n  TasksQueue & CompletedTasksQueue <--> ThreadPool\n```\n\n## Benefits\n\n- Thread creation-destruction overhead is contained to initial creation of the pool => may result in better performance and stability\n\n## Optimal Pool Size\n\n- Threads consume memory\n- Context-switching also takes time\n\n=> If the number of threads are excess, the above two will lead to memory wastage and performance penalties.\n\n- Thread creation + more threads = cost of creating unused threads\n- Thread creation + less threads = longer waiting time\n- Thread destruction + more threads = cost of creating them again later\n- Thread destruction + less threads = May starve other processes of resources (more unused threads in memory)\n\nThus, the pool size has to be very carefully tuned to a sweet-spot. This can be dynamically determined during the application's lifecycle based on the number of waiting tasks. \n\n","n":0.075}}},{"i":450,"$":{"0":{"v":"MVC","n":1},"1":{"v":"\n# Model-View-Controller \n\nA [[arch.style.layer]] pattern which segregates the application into three layers:\n\n1. Model\n2. View\n3. Controller","n":0.258}}},{"i":451,"$":{"0":{"v":"Messaging Pattern","n":0.707},"1":{"v":"\n[[arch.pattern]] which describes how two different parts of an application or systems will connect and communicate with each other. \n","n":0.224}}},{"i":452,"$":{"0":{"v":"Request-Response","n":1},"1":{"v":"\nIt is a [[arch.pattern.messaging]].\n\n## Model\n\n- Client sends a request\n- Server parses the request: Where does a request begin and end?\n- Server processes the request: Example, Deserializing JSON and then processing.\n- Server sends a response\n- Client parses the response and consume\n\n## Anatomy\n\n- Client and server need to define and agree upon the request/response structure.\n- Request/response has a boundary\n- Defined by protocol and message format.\n\n## Where is it used?\n\n- Web, HTTP, DNS, SSH.\n- Remote Procedure Call (RPC)\n- SQL and database protocols\n- APIs (REST/SOAP/GraphQL)\n\n## Where it doesn't work well?\n\n- Notification Service\n- Chat Applications\n- Very Long requests - What if client disconnects?\n\n","n":0.101}}},{"i":453,"$":{"0":{"v":"Push","n":1},"1":{"v":"\n## Use case\n\n- Client wants **real-time** notification from server.\n\n## Examples\n\n- User just logged in\n- Message just receieved (chat app)\n\n## Cons\n\n- Client must be online\n- Client must be able to handle ","n":0.183}}},{"i":454,"$":{"0":{"v":"Polling","n":1},"1":{"v":"\n# Or Short Polling\n\n- Request takes long time to process\n- ","n":0.316}}},{"i":455,"$":{"0":{"v":"Levels of Abstraction","n":0.577},"1":{"v":"\n\n- [[arch.style]] is application design at highest-level of abstraction.\n- [[arch.pattern]] is the way to implement it and hence is a step below.\n- [[arch.design.oo.patterns]] is a way to solve localised problem.\n\n## References\n\n[Architectural Styles vs. Architectural Patterns vs. Design Patterns](https://herbertograca.com/2017/07/28/architectural-styles-vs-architectural-patterns-vs-design-patterns/)\n","n":0.162}}},{"i":456,"$":{"0":{"v":"Design","n":1},"1":{"v":"\n\n- Pictures the implementation of some specific concerned domain.\n- Comparatively easier to change at a later stage according to changing requirements.\n","n":0.218}}},{"i":457,"$":{"0":{"v":"Oo","n":1}}},{"i":458,"$":{"0":{"v":"Use Cases For","n":0.577}}},{"i":459,"$":{"0":{"v":"Interface","n":1},"1":{"v":"\n\n### Unrelated Classes\n\nYou expect unrelated classes would implement your interface. For example, Comparable and Clonable are implemented by many unrelated classes.\n\n### Specifying Behaviour\n\nYou want to specify the behaviour of a particular data type, but not concerned about who implements this behaviour. For example, Clonable and Comparable.\n\n### Multiple Inheritance\n\nYou want to take advantage of multiple inheritance.\n\n## References\n\n- [Stack Overflow](https://stackoverflow.com/questions/20193091/recommendations-for-abstract-classes-vs-interfaces#:~:text=If%20you%20are%20designing%20small,component%2C%20use%20an%20abstract%20class.)\n    > If we are designing small, concise bits of functionality, use interfaces. If we are designing large functional units, use an abstract class.","n":0.111}}},{"i":460,"$":{"0":{"v":"Abstract Class","n":0.707},"1":{"v":"\n\n[[paradigm.oo.components.modifiers.abstract.class]]es are mostly used in one of two ways - \n\n- [[arch.design.oo.use cases for.abstract class.providing flexible behavior for related classes]]: If classes you extend have many common methods and fields, we tend.\n- [[arch.design.oo.use cases for.abstract class.helper]]: You want to share code among several closely related classes\n\nBoth these ways are better off substituted and hence an **abstract class should almost never be used** since you should try to prefer [[arch.design.oo.principles.composition over inheritance]].\n\nHowever, this is still a principle and [[philosophy.a principle in principle]].\n\nSome other scenarios where Abstract class may be used:\n\n- The classes you extend require methods with **access modifiers** other than public.\n- You want to declare **non-static or non-final fields**. This allows you to define methods that can access and modify the state of the object to which they belong.\n\nYou can still consider the above scenarios or use [[arch.design.oo.use cases for.abstract class.stepping stone]].\n\n## References\n\n\n- [Stack Overflow](https://stackoverflow.com/questions/20193091/recommendations-for-abstract-classes-vs-interfaces#:~:text=If%20you%20are%20designing%20small,component%2C%20use%20an%20abstract%20class.)\n    > If we are designing small, concise bits of functionality, use interfaces. If we are designing large functional units, use an abstract class.\n\n- [Nigel Thorne's answer to How to Unit Test Abstract Classes?](https://stackoverflow.com/a/2947823/14318926)\n","n":0.075}}},{"i":461,"$":{"0":{"v":"Abstract Class as Stepping Stone","n":0.447},"1":{"v":"\n\n## From my own experience\n\nI once had to implement a scenario, where there are different kinds of resources or configurations all sharing a similar structure and behavior with a little difference in some fields. But mostly the functionality would be same for all these resources.\n\nI went with abstract class as the base for these classes, since these were [[paradigm.oo.tags.same-same-but-different classes]].\n\nEven though I was using [[arch.design.oo.use cases for.abstract class.providing flexible behavior for related classes]] and also [[arch.design.oo.use cases for.abstract class.helper]], a little. If I went with implementing a third class as a utility to be consumed in all these classes, I would have more useless code for initializing these objects and calling the methods instead of the logic. Hence, I decided to go with the Abstract class.\n\nAs the code and requirements evolved, I made the base class as concrete and more dynamic. I now only had to use a child class for very specific scenarios. But that might change too.\n\nSometimes on this journey towards perfection, [[philosophy.bad code can lead to good code]].\n\n## Another beautiful excerpt from [Nigel Thorne's answer to How to Unit Test Abstract Classes?](https://stackoverflow.com/a/2947823/14318926)\n\n>Update 2 : Abstract Classes as a stepping stone (2014/06/12)\n>\n>I had a situation the other day where I used abstract, so I'd like to explore why.\n>\n>We have a standard format for our configuration files. This particular tool has 3 configuration files all in that format. I wanted a strongly typed class for each setting file so, through dependency injection, a class could ask for the settings it cared about.\n>\n>I implemented this by having an abstract base class that knows how to parse the settings files formats and derived classes that exposed those same methods, but encapsulated the location of the settings file.\n>\n>I could have written a \"SettingsFileParser\" that the 3 classes wrapped, and then delegated through to the base class to expose the data access methods. I chose not to do this yet as it would lead to 3 derived classes with more delegation code in them than anything else.\n>\n>However... as this code evolves and the consumers of each of these settings classes become clearer. Each settings users will ask for some settings and transform them in some way (as settings are text they may wrap them in objects of convert them to numbers etc.). As this happens I will start to extract this logic into data manipulation methods and push them back onto the strongly typed settings classes. This will lead to a higher level interface for each set of settings, that is eventually no longer aware it's dealing with 'settings'.\n>\n>At this point the strongly typed settings classes will no longer need the \"getter\" methods that expose the underlying 'settings' implementation.\n>\n>At that point I would no longer want their public interface to include the settings accessor methods; so I will change this class to encapsulate a settings parser class instead of derive from it.\n>\n>The Abstract class is therefore: a way for me to avoid delegation code at the moment, and a marker in the code to remind me to change the design later. I may never get to it, so it may live a good while... only the code can tell.\n>\n>I find this to be true with any rule... like \"no static methods\" or \"no private methods\". They indicate a smell in the code... and that's good. It keeps you looking for the abstraction that you have missed... and lets you carry on providing value to your customer in the mean time.\n>\n>I imagine rules like this one defining a landscape, where maintainable code lives in the valleys. As you add new behaviour, it's like rain landing on your code. Initially you put it wherever it lands.. then you refactor to allow the forces of good design to push the behaviour around until it all ends up in the valleys.\n\n## References\n\n[Nigel Thorne's answer to How to Unit Test Abstract Classes?](https://stackoverflow.com/a/2947823/14318926)\n\n","n":0.039}}},{"i":462,"$":{"0":{"v":"Abstract Class for Providing Flexible Behavior for Related Classes","n":0.333},"1":{"v":"\nIf there is a common interface for all concrete implmentations of your abstract class, it means you are just using [[paradigm.oo.principles.inheritance]] to define/change certain behaviour of the class.\n\n```mermaid\nclassDiagram\n  iCar <|-- AbstractCar\n  AbstractCar <|-- GoCart\n  AbstractCar <|-- FastCar  \n```\n\nYou should rather prefer [[arch.design.oo.principles.composition over inheritance]].\n\nJust turn your abstract class into a concrete implementation and inject the \"behaviour\" which you are trying to change from outside using [[arch.design.oo.patterns.gof.behavioural.strategy]].\n\n```mermaid\nclassDiagram\n  iCar <-- Car\n  class Car{\n    + iMotor motor\n  }\n  iMotor <-- FastMotor\n  iMotor <-- GoCartMotor  \n```\n\n## References\n\n[Nigel Thorne's answer to How to Unit Test Abstract Classes?](https://stackoverflow.com/a/2947823/14318926)\n","n":0.104}}},{"i":463,"$":{"0":{"v":"Abstract Class as a Helper Class","n":0.408},"1":{"v":"\n\nIf you have different interfaces for the child classes, but you are using the abstract class to factor out duplication within objects, then your abstract class is working as a base class.\n\n```mermaid\nclassDiagram\n    AbstractBaseThingWithMotor <-- LawnMower\n    AbstractBaseThingWithMotor <-- Car    \n```\n\nSee if this functionality can be moved to a concrete helper class instead.\n\n```mermaid\nclassDiagram\n    class LawnMower{\n        + iMotorHelper motorHelper\n    }\n    class Car{\n        + iMotorHelper motorHelper\n    }    \n    iMotorHelper <-- MotorHelper\n```\n\n## References\n\n[Nigel Thorne's answer to How to Unit Test Abstract Classes?](https://stackoverflow.com/a/2947823/14318926)\n","n":0.114}}},{"i":464,"$":{"0":{"v":"Principles","n":1}}},{"i":465,"$":{"0":{"v":"SOLID","n":1},"1":{"v":"\n- Single Responsibility\n- Open-Closed\n- [[arch.design.oo.principles.solid.liskov]]\n- Interface Segregation\n- Dependency Inversion ([[arch.design.oo.principles.ioc]])\n\n## References\n\n[Michael Feathers - the deep synergy between testability and good design](https://www.youtube.com/watch?v=4cVZvoFGJTU)\n","n":0.218}}},{"i":466,"$":{"0":{"v":"Liskov Substitution Principle","n":0.577},"1":{"v":"\n\n> If B is a subtype of A, then objects of type A may be replaced with objects of type B (i.e., an object of type A may be substituted with any object of a subtype B) without altering any of the desirable properties of the program (correctness, task performed, etc.)\n\n- For instance, if the type Cat is a subtype of Animal, then an expression of type Cat should be substitutable wherever an expression of type Animal is used.\n  - **Behavior**\n    Animal walks on four legs.\n    Cat walks on four legs.\n  - **Attribute**\n    Animal has two eyes.\n    Cat has two eyes.\n","n":0.1}}},{"i":467,"$":{"0":{"v":"Do NOT create dependencies","n":0.5},"1":{"v":"\n\n- Do no work in a constructor\n- Do not create significant dependencies directly but via [[arch.design.oo.patterns.gof.creational.factory]] or lazy initialization.\n","n":0.229}}},{"i":468,"$":{"0":{"v":"Law of Demeter or Principle of Least Knowledge","n":0.354},"1":{"v":"\n\n> Don't talk to strangers.\n\n## Statement\n\n**For all classes C, and for all methods M attached to C, all objects to which M sends a message must be:**\n\n- **M’s argument objects, including the self object or**\n- **The instance variable objects of C**\n\n**(Object created by M, or by functions or methods which M calls, and objects in global variables are considered as arguments of M).**\n\n*In the early days of Object-Orientation, objects were supposed to “send messages” to each other. That is how they communicated. So the term “objects to which M sends a message” roughly translates to “objects used by M,” or in a more practical definition “objects on which M calls a method on”.*\n\n## The Genius of Law of Demeter\n\n- Concepts like encapsulation, cohesion, single-responsibility principle or open/closed principle are not pragmatic enough and require interpretation, which makes them subjective and dependent of people's experience and knowledge.\n\n> The genius of the Law of Demeter comes from the succinct and exact definition, which allows for a direct application when writing code, while at the same time almost automatically guaranteeing proper encapsulation, cohesion, and loose coupling. The authors of the Law managed to take these abstract concepts and distil the essence of them into a clear set of rules that are universally applicable to Object-Oriented code. [[Source](https://dzone.com/articles/the-genius-of-the-law-of-demeter#:~:text=The%20genius%20of%20the%20Law%20of%20Demeter%20comes,that%20are%20universally%20applicable%20to%20Object%2DOriented%20code.)]\n\n## References\n\n[The Genius of Law of Demeter - dZone](https://dzone.com/articles/the-genius-of-the-law-of-demeter)\n","n":0.067}}},{"i":469,"$":{"0":{"v":"Inversion of Control","n":0.577},"1":{"v":"\n- IoC inverts the flow of control as compared to traditional control flow.\n- A software architecture with this design inverts control as compared to traditional procedural programming\n- Normally, what happens is your application code does most of the work and you might use certain libraries to add extra functionality. Or your class is dependent upon other classes to get the job done.\n\nIn case of IoC, the framework handles most of the jobs and you focus on just the specific implementation of your application.\n\n## Benefits\n\nAs mentioned, one of the benefits is you focus on just your specific logic and implementation and you let the framework handle the trivial stuff like creating an object, allocating memory etc.\n\nIt also allows us to depend more on abstraction rather than concrete implementations which in turn promotes:\n\n- loosely coupled architecture\n- Flexibility\n- plugability\n\n## References\n\n[Ryan Schachte - Dependency Injection & Inversion of Control - YouTube](https://www.youtube.com/watch?v=EPv9-cHEmQw&t=92s)\n","n":0.082}}},{"i":470,"$":{"0":{"v":"Composition over Inheritance","n":0.577},"1":{"v":"\n\naka **Composite reuse Principle**.\n\nIt is a OOP principle which encourages the usage of composition for code reuse instead of inheritance.\n\nHowever, it is still a principle and [[philosophy.a principle in principle]]. \n\nHence, this can be reframed better as -\n\n> If you are going to use inheritance - think again, chances are you need composition.\n\n## Trade-offs\n\n- [[paradigm.oo.principles.inheritance.purpose]] vs [[paradigm.oo.principles.inheritance.disadvantages]]\n- [[paradigm.oo.principles.association.aggregation.composition.benefits]] vs [[paradigm.oo.principles.association.aggregation.composition.disadvantages]]\n\n## References\n\n[Prefer composition over inheritance? - Stack Overflow](https://stackoverflow.com/questions/49002/prefer-composition-over-inheritance)\n","n":0.122}}},{"i":471,"$":{"0":{"v":"providing flexible behavior for related classes","n":0.408},"1":{"v":"\n\nGiving different variation of certain behavioural capability to a [[paradigm.oo.tags.same-same-but-different classes]] where the classes are related close-enough so as to be inheriting from a single class.\n","n":0.196}}},{"i":472,"$":{"0":{"v":"Design Pattern","n":0.707},"1":{"v":"\n[[arch.design]] [[concepts.pattern]]s represent a way to solve localized problem. More specifically, it is a way to structure classes to solve common problems.\n\n## References\n\n[Architectural Styles vs. Architectural Patterns vs. Design Patterns](https://herbertograca.com/2017/07/28/architectural-styles-vs-architectural-patterns-vs-design-patterns/)\n","n":0.183}}},{"i":473,"$":{"0":{"v":"Immutable Class","n":0.707},"1":{"v":"\nCannot be changed (mutated)\n\nWhenever changed - a new instance is created\n\n\n## What makes a class immutable?\n\n- Instance variable is final (value can't be changed)\n- class = final - So subclass can't be created\n- No setters\n\n## How to create an immutable class\n\n- Create **final** class with all **final data members**.\n- Whichever way you decide to initialize the object and add value to these fields make sure to perform a [[deep cloning|paradigm.oo.components.object.cloning#deep-cloning]] for any reference fields.\n- You have to be careful when there's a reference in the members as well. For example, arrays in Java are mutable objects. \n\n💡 Use [[clone method|lang.java.paradigms.oo.objects.cloning]] to perform deep cloning. You can use the same method for any [[lang.java.lib.interfaces.marker.cloneable]] object.\n\n```java\nfinal public class ImmutableClass {\n  final private int id;\n  final private Map<String, Integer> m;\n  final private int[] arr;\n\n  public ImmutableClass(int id, HashMap<String, Integer> m, int[] a){\n      this.id = id;\n      this.m = new HashMap<>();\n      this.arr = arr.clone();\n      \n\n      for (String key : m.keySet()) {\n          this.m.put(key, m.get(key));\n      }\n  }\n\n    public int getId() {\n        return id;\n    }\n\n    public int getMapValue(String key){\n      return this.m.getOrDefault(key, -1);\n    }\n\n    public int[] getArr(){\n        return arr.clone()\n    }\n}\n```\n\n## Benefits \n\nThe main benefits of immutability come in case of multi-threaded applications, functional programming and high-security systems.\n\n- Thead safety\n- Predictable behavior\n- Enhanced security: ensures that sensitive data cannot be modified after its created preventing unintended or malicious change.\n- Caching: \n    - Immutable objects can be safely shared across different parts of program.\n    - Hashcodes for hash-based structures can be precomputed and cached - since they won't change\n- Works well with [[paradigm.func]]\n    - Immutability is one of the principles of functional programming\n    - Immutable objects ensure that functions don't modify anything outside their scope\n\n## Use cases\n\n- \n\n## References\n\n- [How To Create an Immutable Class in Java](https://arc.net/l/quote/zfjjlivr)\n- [Java Immutable Class - Builder Pattern](https://www.journaldev.com/1432/java-immutable-class-builder) _dead_\n    - [Archive Link](https://web.archive.org/web/20220704144259/https://www.journaldev.com/1432/java-immutable-class-builder)\n- [Why do we need immutable class?](https://stackoverflow.com/questions/3769607/why-do-we-need-immutable-class)","n":0.058}}},{"i":474,"$":{"0":{"v":"GoF Design Pattern","n":0.577},"1":{"v":"\n**Gangs of Four** [[arch.design.oo.patterns]]s are collection of 23 design patterns from the book “_Design Patterns: Elements of Reusable Object-Oriented Software_”.\n\nThe authors are collectively called Gang of Four.\n\nThe 23 design patterns are divided into 3 categories:\n\n- [[arch.design.oo.patterns.gof.creational]]\n- [[arch.design.oo.patterns.gof.structural]]\n- [[arch.design.oo.patterns.gof.behavioural]]\n","n":0.162}}},{"i":475,"$":{"0":{"v":"Structural Design Pattern","n":0.577},"1":{"v":"\n[[arch.design.oo.patterns]] concerned with forming large structures out of classes and objects so that the structure is both flexible and efficient.","n":0.224}}},{"i":476,"$":{"0":{"v":"Marker Interface","n":0.707},"1":{"v":"\naka **Tag Interface**\n\n[[arch.design.oo.patterns.gof.structural]] used to associate metadata with a class.\n\n- Such interface generally does not contain its own interface components,\n- Denotes a particular behavior\n  - whereas Typical interfaces specify functionality\n- Serves as metadata\n  - provides a means to associate metadata with a class where the language does not have explicit support for such metadata.\n- Changes the way implementing classes are handled by the Compiler","n":0.125}}},{"i":477,"$":{"0":{"v":"Creational Design Pattern","n":0.577},"1":{"v":"\n[[arch.design.oo.patterns]]s concerning creation of an object.\n","n":0.408}}},{"i":478,"$":{"0":{"v":"Singleton","n":1},"1":{"v":"\n\n[[arch.design.oo.patterns.gof.creational]] in which only one instance of a class is allowed.\n\n## What is a **Singleton class?**\n\nOnly one instance is allowed\n\n## How to implement it?\n\nTo only allow one instance for your class:\n\n1. Create a static object of a class within the class\n2. Make default constructor private\n3. Create a static method which returns an instance of your class\n\n```java\nclass Abc{\n    public static Abc obj = new Abc();\n    int i;\n    private Abc();\n    public static Abc getInstance(){\n        return obj;\n    }\n}\n```\n\nNow, the only way an instance of this class can be obtained is through this method and since the method is static, it will return the same static instance which was the member of your class.\n\n## Why is this implementation eager?\n\nThis instance of the class will be created as soon as the class is loaded in the memory. It will be global and will be there in the memory even if its not used.\n\n## How to make it lazy?\n\nInstead of creating, if you just declare the object in the class and create it inside the function, it will become lazy. But this will mean that every time your function is called, it will return a new object. Hence, the class won't be singleton anymore.\n\n```java\nclass Abc{\n    public static Abc obj;\n    int i;\n    private Abc();\n    public static Abc getInstance(){\n        obj = new Abc(); // new object eveytime the function is called\n        return obj;\n    }\n}\n```\n\nTo prevent this, put the initialisation of object into an if condition which checks whether the object is null or not. → This will only create the object, the first time the function is called. Else it will return the old object.\n\n```java\nclass Abc{\n    public static Abc obj;\n    int i;\n    private Abc();\n    public static Abc getInstance(){\n        if(obj == null ) obj = new Abc(); // new object created only for the first time\n        return obj;\n    }\n}\n```\n\nAlthough this won't work if simultaneous calls are made to the method from multiple threads.\n\n## How to make it thread safe?\n\nYou can make your method *synchronized* to resolve this issue. But this will slow down your app.\n\n```java\nclass Abc{\n    public static Abc obj;\n    int i;\n    private Abc();\n    public static synchronized Abc getInstance(){\n        if(obj == null ) obj = new Abc(); // new object created only for the first time\n        return obj;\n    }\n}\n```\n\nTo solve this, you can perform a double checked locking. That is, don't put synchronize on the function but inside the function. Check if the object is null - twice. Once inside a synchronized block and once outside.\n\n```java\nclass Abc{\n    public static Abc obj;\n    int i;\n    private Abc();\n    public static Abc getInstance(){\n        if(obj == null ){\n            synchronized(Abc.class){\n                if(obj==null) \n                    obj = new Abc(); \n            }\n        }\n        return obj;\n    }\n}\n```\n\n## What is the best way to implement a Singleton class?\n\n```sql\nenum Abc {\n    INSTANCE;\n}\n```\n\n## Why is Singleton pattern/class used?\n\nIt is used to provide global point of access to an object. So it can be used in logging, caches, thread pools, configuration settings, device driver objects. Basically, wherever there is a possibility of multiple clients or users accessing and initializing a new object and we don't want that - Singleton design is used.\n\n## Why not create a static class for such requirements?\n\n- Singleton can implement interfaces and extend classes\n- Static class will have only static members\n- Can be lazily loaded. Static will be initialized when first loaded.\n- Stored in heap, static stored in stack\n- Clonable\n- Can use OO feature of polymorphism\n\n","n":0.042}}},{"i":479,"$":{"0":{"v":"Factory","n":1},"1":{"v":"\n## Goal\n  - Classes of more abstract levels shall not depend on classes on more detailed levels\n  - Classes shall only depend on abstractions, e.g. interfaces\n\n## Solution\n\nMove creation of objects to object factory class.\n\n## Object Factory \n\n- The single responsibility of an object factory class is to create objects of other classes\n- The factory decides if it provides the [[arch.design.oo.patterns.gof.creational.singleton]] or a new object every time\n- To prevent unwanted side effects due to the direct creation of the managed classes,\n\n```abap\nCLASS cl_managed DEFINITION\n    PUBLIC\n    CREATE PRIVATE \"Define the constructor of the factory-managed class as private\n    GLOBAL FRIENDS cl_factory \"Declare the factory as a global friend of the factory-managed class\n```\n\n### Factory using [[paradigm.oo.components.class.friend]]\n\n- Many programming languages support friend classes\n- Friend class has access to the class's private constructor and hence can contain the factory method.\n\n\n## Testability advantage\n\nOffers a single point of injection for [[Test Double]]s in unit tests and integration/system tests\n\n- Create the Interface and multiple implementation of same interface.\n- Factory method - used to hide the logic of object creation  - loose coupling and high cohesion\n- Create another class and initialize the object in a method over there. Return the object.\n","n":0.073}}},{"i":480,"$":{"0":{"v":"Builder","n":1},"1":{"v":"\nUsed to write readable and understandable code to set up complex objects.\n\nWhenever you create a class with some members, you pass the values you want them to have to the constructor while creating object. This could get very complex if there are too many members of different types.\n\nCreate another (builder) class with all the same members and setters of individual members and return object of the builder class.\n\n```java\nPhone newphone = new PhoneBuilder().setOS().setBattery().getPhone() \n//getPhone gives the object of Phone type\n```\n\nNo need to specify all the values too. Set only the values you want. Rest will have default values.\n","n":0.102}}},{"i":481,"$":{"0":{"v":"Don't dig too deep in chain calls","n":0.378},"1":{"v":"\n> Chain calls ko dil pe na lein.\n\nAvoid digging to deep into collaborators while creating chain calls as it can risk exposing internals and cause other issues.\n\n```cpp\n*the dog should bark\ndog->getHead( ) ->getMouth( ) -> getTongue( ) ->bark( ).\n```\n\n👆🏽Tight Coupling and dependencies\n\n- Hard to change/extend\n- No reuse of parts possible\n- Hard to test\n\nSolution\n\n```cpp\ndog->bark( ).\n```\n","n":0.137}}},{"i":482,"$":{"0":{"v":"Behavioural Design Patterns","n":0.577},"1":{"v":"\n[[arch.design.oo.patterns]] concerned with the behaviour i.e. the algorithm, responsibilities and communication among objects.\n","n":0.277}}},{"i":483,"$":{"0":{"v":"Template Method","n":0.707},"1":{"v":"\n[[arch.design.oo.patterns.gof.behavioural]]\n\n## Goal\n\nWhen you need to define certain steps in a particular order, but the internals of those steps can vary.\n\n## Solution\n\nCreate a superclass (usually an abstract superclass), with a method containing the steps in the desired sequence. These steps will be in form of methods, which the subclasses can choose to skip or implement in the specific way.\n\n## References\n\n[Template Method Design Pattern - Derek Banas](https://youtu.be/aR1B8MlwbRI?si=8QIkWnMnCegYec3A)","n":0.124}}},{"i":484,"$":{"0":{"v":"Strategy Pattern","n":0.707}}},{"i":485,"$":{"0":{"v":"Data Access Object","n":0.577},"1":{"v":"\nIts a [[arch.design.oo.patterns]] in which the data access object (DAO) is an object that provides an abstract interface to some type of database or other persistence mechanism. By mapping application calls to the persistence layer, DAO provide some specific data operations without exposing details of the database.\n\nBasically, ek class bana do StudentDAO type. Usme sab function rahega insert, get ye wo operation database mein karne ke liye. Fir kisi aur class se ye sab function ko directly value pass karo bass. This way, database mein peechhe kya chal raha is abstract.\n","n":0.105}}},{"i":486,"$":{"0":{"v":"Dependency Injection","n":0.707},"1":{"v":"\n```abap\nCLASS … DEFINITION … .\n DATA(lo_cash_provider) = NEW cl_cash_provider( ).\nENDCLASS\n```\n\n👆🏽 This here is a [[concepts.dependency]]\n\n- Dependency injection is a design pattern in which, instead of creating the object ourselves in our code, we let some other entity create the object and \"inject\" into our class.\n- ⇒ Dependency injection implements [[arch.design.oo.principles.ioc]]\n\nThe dependency can be injected via:\n\n- constructor -- [[arch.design.oo.patterns.di.constructor]]\n- setter method -- [[arch.design.oo.patterns.di.setter]]\n- parameter - [[arch.design.oo.patterns.di.parameter]]\n- backdoor - [[arch.design.oo.patterns.di.backdoor]]","n":0.121}}},{"i":487,"$":{"0":{"v":"Setter Injection","n":0.707},"1":{"v":"\n```abap\nCLASS … DEFINITION … .\n  PUBLIC SECTION.\n    METHODS set_cash_provider IMPORTING i_cash_provider TYPE REF TO if_cash_provider.\n  PRIVATE SECTION.\n    DATA m_cash_provider TYPE REF TO if_cash_provider.\n…\nENDCLASS.\n\nCLASS … IMPLEMENTATION.\n  METHOD set_cash_provider.\n    m_cash_provider = i_cash_provider.\n  ENDMETHOD.\n…\nENDCLASS.\n```\n","n":0.18}}},{"i":488,"$":{"0":{"v":"Parameter Injection","n":0.707},"1":{"v":"\n```abap\nCLASS … DEFINITION … .\n  PUBLIC SECTION.\n    METHODS get_amount_in_coins \n      IMPORTING\n        i_amount TYPE i\n        i_cash_provider TYPE REF TO if_cash_provider OPTIONAL\n      RETURNING VALUE(r_value) TYPE i.\n  PRIVATE SECTION.\n  DATA m_cash_provider TYPE REF TO if_cash_provider.\n…\nENDCLASS.\n\nCLASS … IMPLEMENTATION.\n  METHOD get_amount_in_coins.\n    DATA(cash_provider) = CAST if_cash_provider(\n                  COND #( WHEN i_cash_provider IS BOUND\n                      THEN i_cash_provider\n                      ELSE NEW cl_cash_provider( ) ) ).\n  …\n  ENDMETHOD.\n…\nENDCLASS\n```\n","n":0.134}}},{"i":489,"$":{"0":{"v":"Field Injection","n":0.707},"1":{"v":"\nWhen a field in a class is directly injected into upon initialization (by a framework or library).\n\nNot generally recommended though.","n":0.224}}},{"i":490,"$":{"0":{"v":"Constructor Injection","n":0.707},"1":{"v":"\n```abap\nCLASS … DEFINITION … .\n  PUBLIC SECTION.\n   METHODS constructor \n     IMPORTING i_cash_provider TYPE REF TO if_cash_provider OPTIONAL.\n PRIVATE SECTION.\n   DATA m_cash_provider TYPE REF TO if_cash_provider.\n …\nENDCLASS.\n\nCLASS … IMPLEMENTATION.\n  METHOD constructor.\n    m_cash_provider = COND #( WHEN i_cash_provider IS BOUND\n               THEN i_cash_provider\n               ELSE NEW cl_cash_provider( ) ).\n  ENDMETHOD.\n …\nENDCLASS.\n```\n","n":0.146}}},{"i":491,"$":{"0":{"v":"Backdoor Injection","n":0.707},"1":{"v":"\nInjection done using [[paradigm.oo.components.class.friend]].\n\n```abap\nCLASS … DEFINITION … .\n  PRIVATE SECTION.\n    DATA m_cash_provider TYPE REF TO if_cash_provider.\n    …\nENDCLASS.\n```\n\n```abap\nCLASS ltc_get_amount_in_coins DEFINITION DEFERRED.\nCLASS cl_money_machine DEFINITION\n    LOCAL FRIENDS ltc_get_amount_in_coins.\n\nCLASS ltc_get_amount_in_coins DEFINITION FOR TESTING … .\n…\nENDCLASS.\n\nCLASS ltc_get_amount_in_coins IMPLEMENTATION.\n  METHOD setup.\n    \"given\n    m_cut = NEW #( ).\n    m_cut->m_cash_provider = NEW ltd_cash_provider( ).\n  ENDMETHOD.\nENDCLASS.\n```\n","n":0.146}}},{"i":492,"$":{"0":{"v":"Application with No Constraints","n":0.5},"1":{"v":"\n\n#interview-question\n\n[Link to stackOverflow question](https://stackoverflow.com/questions/64003764/design-an-application-with-no-constraints?noredirect=1#comment113242537_64003764)\n\nHow will you design an app which -\n\n- Performs a number of tasks\n- the tasks can be anything (any operation or program or literally just anything)\n- there can be any number of tasks\n- those tasks can have any number of inputs\n- the task to be done may be sent as a payload\n- the inputs may be sent as payload\n- there can be any number of clients.\n- the client can send any kind of request (GET, PUT, POST etc.)\n\nList the classes and interfaces you'll create and describe the entire flow of the application. Everything should be \"loosely-coupled\".\n\n## StackOverflow conversation since the post got deleted\n\n> This sounds almost like a project that you want someone to hire you to do. Mind you, the first part of the solution would not even be classes, it will be infrastructure, like what is the platform you're targeting, languages etc. This is quite a loaded thing, and if you were asked this in an interview I guarantee you the interviewer did not want you to list classes or interfaces but wanted to see your experience designing distributed systems and knowledge of basic things like producer-consumer, distributed queues, concurrent execution etc,. – \nzaitsman\n Sep 23, 2020 at 0:15\n\n> I actually talked about the infrastructure to him. But he specifically asked to forget all that and tell him all the classes and interfaces I'll use for this kind of system. – \nChinmay Singh\n Sep 24, 2020 at 3:49   \n\n> Well, that just shows that the interviewer might need to work on asking, as the question is heaps open ended. Nevertheless, you need an input endpoint, a status check endpoint, a results grab endpoint (regardless of HTTP/TCP/other RPC protocol), a repository to fetch results (persisted somehow), a queue producer, a queue consumer, a task processor, and a repository to store results, most of these would be abstracted via CQRS or Service-Layer architecture and will thus have both an interface and a concrete implementation. – \nzaitsman\n Sep 24, 2020 at 3:54","n":0.055}}},{"i":493,"$":{"0":{"v":"System Design","n":0.707},"1":{"v":"\n\n## References\n\n[System Design for interview and beyond - LeetCode](https://leetcode.com/explore/featured/card/system-design-for-interviews-and-beyond/) #course","n":0.316}}}]}
